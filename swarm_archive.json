{
  "project_name": "brain",
  "meta_instruction": "\nYOU ARE THE ARCHITECT. \nThis is a POLISHED COGNITIVE MAP of the Swarm.\n1. 'system_map': Deduplicated Structure, Arity, Docs, and Complexity Scores.\n2. 'dependency_graph': Directed Graph (No self-loops).\n3. 'files': Source code with deep skeletons.\n",
  "system_map": {
    "SwarmBrain.MixProject": {
      "modules": [
        "SwarmBrain.MixProject"
      ],
      "functions": [
        "application/0",
        "deps/0",
        "project/0"
      ],
      "structs": [],
      "dependencies": [
        "Mix",
        "Mix.Project",
        "SwarmBrain.Application"
      ],
      "complexity": 3,
      "doc": null
    },
    "SwarmBrain.Blackboard": {
      "modules": [
        "SwarmBrain.Blackboard"
      ],
      "functions": [
        "ate_neighbors(cr/1",
        "ate_vision(de/2",
        "dle_cast({:/2",
        "dle_info({:/2",
        "init/1",
        "start_link/1"
      ],
      "structs": [
        "[\n    :crdt,\n    target_class: \"none\",\n    target_position: nil,\n    mission_status: :search,\n    swarm_census: 0\n  ]"
      ],
      "dependencies": [
        "GenServer",
        "Logger",
        "Server.ca",
        "e.li",
        "e.se",
        "ger.de",
        "rdt.set_n",
        "rmBrain.Sensor.Fusion, {",
        "t.fi",
        "taCrdt.AWLWWMap, s",
        "taCrdt.pu",
        "taCrdt.st"
      ],
      "complexity": 7,
      "doc": null
    },
    "SwarmBrain.Cortex": {
      "modules": [
        "SwarmBrain.Cortex"
      ],
      "functions": [
        "analyze/1"
      ],
      "structs": [],
      "dependencies": [
        "Application",
        "Nx.Tensor",
        "SwarmBrain.Cortex.ResNet"
      ],
      "complexity": 1,
      "doc": null
    },
    "SwarmBrain.Formation": {
      "modules": [
        "SwarmBrain.Formation"
      ],
      "functions": [
        "handle_info/2",
        "init/1",
        "start_link/1"
      ],
      "structs": [
        "[\n    :current_vector,\n    :formation_offset,\n    :last_seen_ts\n  ]"
      ],
      "dependencies": [
        "GenServer",
        "Keyword",
        "Logger",
        "Phoenix.PubSub",
        "SwarmBrain.PubSub",
        "SwarmBrain.Telemetry.Codec",
        "System"
      ],
      "complexity": 5,
      "doc": null
    },
    "SwarmBrain.Antenna": {
      "modules": [
        "SwarmBrain.Antenna"
      ],
      "functions": [
        "dle_info(_m/2",
        "dle_info({:/2",
        "init/1",
        "start_link/1"
      ],
      "structs": [],
      "dependencies": [
        "GenServer",
        "Logger",
        "enix.PubSub.br",
        "ing.tr",
        "rmBrain.PubSub, @"
      ],
      "complexity": 4,
      "doc": null
    },
    "SwarmBrain.Application": {
      "modules": [
        "SwarmBrain.Application"
      ],
      "functions": [
        "_jit(cortex/1",
        "start/2"
      ],
      "structs": [],
      "dependencies": [
        "(:",
        "(fn",
        "({",
        ".Actor.Network.init_rand",
        ".Actor.Network.predict(",
        ".PubSub, name:",
        ".Supervisor, [topo",
        "Application",
        "Code",
        "Logger",
        "ain.Blackboard, []},",
        "ain.ClusterSupervisor]]},",
        "ain.Cortex.Supervisor},",
        "ain.Hardware.Spine, []},",
        "ain.PubSub},",
        "ain.Sensor.Fusion, []},",
        "ain.Supervisor]",
        "ain.Switchboard, corte",
        "ain.Tracker, []}",
        "ain.Vision.Server, []},",
        "ger.wa",
        "info(\"",
        "ning(\"",
        "o(\"\u2705 S",
        "pervisor, name:",
        "sor.start_",
        "st",
        "ug(\".."
      ],
      "complexity": 4,
      "doc": null
    },
    "SwarmBrain.Pipeline": {
      "modules": [
        "SwarmBrain.Pipeline"
      ],
      "functions": [
        "find_best_cortex/0",
        "handle_analysis_result/2",
        "handle_cast/2",
        "handle_info/2",
        "init/1",
        "process_visual_data/1",
        "start_link/1"
      ],
      "structs": [],
      "dependencies": [
        "GenServer",
        "Horde.Registry",
        "Logger",
        "Map",
        "Observation",
        "Phoenix.PubSub",
        "SwarmBrain.Cortex",
        "SwarmBrain.HordeRegistry",
        "SwarmBrain.Observation",
        "SwarmBrain.Persistence",
        "SwarmBrain.PubSub",
        "Task"
      ],
      "complexity": 9,
      "doc": null
    },
    "SwarmBrain.Telemetry.Codec": {
      "modules": [
        "SwarmBrain.Telemetry.Codec"
      ],
      "functions": [
        "decode_vitals/1",
        "encode_vitals/1"
      ],
      "structs": [],
      "dependencies": [],
      "complexity": 2,
      "doc": null
    },
    "SwarmBrain.Location": {
      "modules": [
        "SwarmBrain.Location"
      ],
      "functions": [
        "get_current_gps/0",
        "stamp/1"
      ],
      "structs": [],
      "dependencies": [
        "Observation",
        "SwarmBrain.Observation"
      ],
      "complexity": 2,
      "doc": null
    },
    "SwarmBrain.Radio": {
      "modules": [
        "SwarmBrain.Radio"
      ],
      "functions": [
        "extract_rssi/1",
        "handle_info/2",
        "init/1",
        "start_link/1"
      ],
      "structs": [],
      "dependencies": [
        "Circuits.UART",
        "GenServer",
        "Logger",
        "Phoenix.PubSub",
        "SwarmBrain.PubSub",
        "UART"
      ],
      "complexity": 5,
      "doc": null
    },
    "SwarmBrain.Eye": {
      "modules": [
        "SwarmBrain.Eye"
      ],
      "functions": [
        "_test_pattern, do/0",
        "capture/1",
        "get_hardware_image/0",
        "orm_shutter do\n/0"
      ],
      "structs": [],
      "dependencies": [
        ".exi",
        ".rea",
        "Logger",
        "Observation",
        "Process",
        "SwarmBrain.Observation",
        "Task"
      ],
      "complexity": 6,
      "doc": null
    },
    "SwarmBrain.Watchman": {
      "modules": [
        "SwarmBrain.Watchman"
      ],
      "functions": [
        ":mnesia_tab/2",
        "e_info({:no/2",
        "info({:node/2",
        "init/1",
        "msg, state)/2",
        "nt_type, /2",
        "o({:observa/2",
        "start_link/1"
      ],
      "structs": [],
      "dependencies": [
        "(\"",
        "File",
        "GenServer",
        "Logger",
        "[",
        "d(top",
        "e(deta",
        "e(st",
        "list",
        "log_",
        "now() |>",
        "so8601()",
        "ts"
      ],
      "complexity": 10,
      "doc": null
    },
    "SwarmBrain.Tactician": {
      "modules": [
        "SwarmBrain.Tactician"
      ],
      "functions": [
        "e_call({:th/3",
        "init/1",
        "start_link/1",
        "think/1"
      ],
      "structs": [],
      "dependencies": [
        "Application",
        "File",
        "GenServer",
        "Logger",
        "gger.i"
      ],
      "complexity": 5,
      "doc": null
    },
    "SwarmBrain.Discovery": {
      "modules": [
        "SwarmBrain.Discovery"
      ],
      "functions": [
        "handle_info/2",
        "init/1",
        "start_link/1",
        "t_target_nodes do/0"
      ],
      "structs": [],
      "dependencies": [
        "Enum",
        "GenServer",
        "Logger",
        "Node",
        "SwarmBrain.Persistence",
        "cess.se",
        "m.ea",
        "sistence.ad"
      ],
      "complexity": 6,
      "doc": null
    },
    "SwarmBrain.Observation": {
      "modules": [
        "SwarmBrain.Observation"
      ],
      "functions": [
        "new/1",
        "prune_payload/1",
        "prune_payload/2"
      ],
      "structs": [
        "[\n    :id,\n    :class,\n    :confidence,\n    :bbox,\n    :timestamp,\n    :image_binary,\n    :lat, :lon, :alt,  # GPS Data\n    :predictions       # Full raw output from AI\n  ]"
      ],
      "dependencies": [
        "DateTime",
        "UUID"
      ],
      "complexity": 4,
      "doc": null
    },
    "SwarmBrain.Persistence": {
      "modules": [
        "SwarmBrain.Persistence"
      ],
      "functions": [
        "add_node_to_cluster/1",
        "dle_cast({:/2",
        "init/1",
        "log/1",
        "start_link/1"
      ],
      "structs": [],
      "dependencies": [
        "GenServer",
        "Logger",
        "ger.de"
      ],
      "complexity": 5,
      "doc": null
    },
    "SwarmBrain.Tracker": {
      "modules": [
        "SwarmBrain.Tracker"
      ],
      "functions": [
        "dle_info(:c/2",
        "init/1",
        "le_loop, do: /0",
        "start_link/1"
      ],
      "structs": [],
      "dependencies": [
        "Actor.Network",
        "GenServer",
        "Logger",
        "Sensor.Fusion",
        "Sensor.Proprioception",
        "SwarmBrain",
        "Tensor{}",
        "Vision.Server",
        "br",
        "co",
        "fl",
        "fr",
        "ion.ge",
        "ne",
        "prioception.ge",
        "s.send_",
        "te",
        "ver.ge",
        "work.in",
        "work.pr"
      ],
      "complexity": 6,
      "doc": null
    },
    "SwarmBrain.Telemetry.Dispatcher": {
      "modules": [
        "SwarmBrain.Telemetry.Dispatcher"
      ],
      "functions": [
        "dispatch_batch/1",
        "message_queue_len/0",
        "process_batch/1"
      ],
      "structs": [],
      "dependencies": [
        "Logger",
        "Phoenix.PubSub",
        "Process",
        "Stream",
        "SwarmBrain.PubSub",
        "SwarmBrain.Telemetry.Guard",
        "System",
        "Task"
      ],
      "complexity": 6,
      "doc": null
    },
    "SwarmBrain.Telemetry.Guard": {
      "modules": [
        "SwarmBrain.Telemetry.Guard"
      ],
      "functions": [
        "validate/2",
        "validate_payload/2"
      ],
      "structs": [],
      "dependencies": [
        "Logger",
        "Map",
        "SwarmBrain.Telemetry.Codec",
        "SwarmBrain.Telemetry.Monitor"
      ],
      "complexity": 5,
      "doc": null
    },
    "SwarmBrain.Telemetry.Monitor": {
      "modules": [
        "SwarmBrain.Telemetry.Monitor"
      ],
      "functions": [
        "handle_info/2",
        "init/1",
        "log_packet/1",
        "start_link/1"
      ],
      "structs": [],
      "dependencies": [
        "Float",
        "GenServer",
        "Logger",
        "Task"
      ],
      "complexity": 7,
      "doc": null
    },
    "SwarmBrain.Logic.Tactician": {
      "modules": [
        "SwarmBrain.Logic.Tactician"
      ],
      "functions": [],
      "structs": [],
      "dependencies": [
        "Nx",
        "Nx.Defn"
      ],
      "complexity": 0,
      "doc": null
    },
    "SwarmBrain.Actor.Network": {
      "modules": [
        "SwarmBrain.Actor.Network"
      ],
      "functions": [
        "build_model/0",
        "init_random_params/0",
        "predict/2"
      ],
      "structs": [],
      "dependencies": [
        "Axon",
        "EXLA",
        "Nx"
      ],
      "complexity": 3,
      "doc": null
    },
    "SwarmBrain.Cortex.ResNet": {
      "modules": [
        "SwarmBrain.Cortex.ResNet"
      ],
      "functions": [
        "analyze/1"
      ],
      "structs": [],
      "dependencies": [
        "Nx",
        "Nx.Tensor",
        "PreProcessor",
        "SwarmBrain.Cortex.Model",
        "SwarmBrain.Vision.PreProcessor"
      ],
      "complexity": 2,
      "doc": null
    },
    "SwarmBrain.Cortex.Yolo": {
      "modules": [
        "SwarmBrain.Cortex.Yolo"
      ],
      "functions": [
        "init/0",
        "oco_label(id) /1",
        "ze(%Nx./1"
      ],
      "structs": [],
      "dependencies": [
        ".load",
        ".run(",
        "Application",
        "Backend)",
        "Logger",
        "Nx.Defn",
        "SwarmBrain.Cortex.Model",
        "SwarmBrain.Vision.PreProcessor",
        "_f",
        "_n",
        "ac",
        "ck",
        "du",
        "gm",
        "nsor{} =",
        "ocessor.prep"
      ],
      "complexity": 5,
      "doc": null
    },
    "SwarmBrain.Switchboard": {
      "modules": [
        "SwarmBrain.Switchboard"
      ],
      "functions": [
        "get_active_model/0",
        "handle_call/3",
        "init/1",
        "start_link/1",
        "swap_model/1"
      ],
      "structs": [],
      "dependencies": [
        "GenServer",
        "Logger"
      ],
      "complexity": 5,
      "doc": null
    },
    "SwarmBrain.Cortex.Model": {
      "modules": [
        "SwarmBrain.Cortex.Model"
      ],
      "functions": [],
      "structs": [],
      "dependencies": [
        "Nx.Tensor",
        "String"
      ],
      "complexity": 0,
      "doc": null
    },
    "SwarmBrain.Cortex.Watchdog": {
      "modules": [
        "SwarmBrain.Cortex.Watchdog"
      ],
      "functions": [
        "dle_cast({:/2",
        "dle_hysteresis(_,/2",
        "handle_cast/2",
        "init/1",
        "input_confidence/1",
        "input_imu/1",
        "report_latency/1",
        "start_link/1"
      ],
      "structs": [],
      "dependencies": [
        "GenServer",
        "Logger",
        "System",
        "ger.in",
        "ger.wa",
        "rmBrain.Cortex.MobileNet)",
        "rmBrain.Cortex.ResNet)",
        "rmBrain.Switchboard.sw",
        "tem.mo"
      ],
      "complexity": 13,
      "doc": null
    },
    "SwarmBrain.Llama.Summarizer": {
      "modules": [
        "SwarmBrain.Llama.Summarizer"
      ],
      "functions": [
        "generate_prompt/2"
      ],
      "structs": [],
      "dependencies": [
        "DateTime",
        "Enum",
        "Float"
      ],
      "complexity": 1,
      "doc": null
    },
    "SwarmBrain.Hardware.Spine": {
      "modules": [
        "SwarmBrain.Hardware.Spine"
      ],
      "functions": [
        "_call(:get_/3",
        "_cast({:com/2",
        "_info({:cir/2",
        "_pwm(val) /1",
        "_rc_payload(r, p,/4",
        "e_xor_checksum(size,/3",
        "get_imu_state/0",
        "init/1",
        "send_controls/4",
        "sp(cmd_i/2",
        "start_link/1",
        "t_ident(pid),/1"
      ],
      "structs": [
        "[:uart_pid, :mode, :last_attitude]"
      ],
      "dependencies": [
        "Application",
        "File",
        "GenServer",
        "Logger",
        "cuits.UART.op",
        "cuits.UART.st",
        "e.bxor(",
        "ger.wa",
        "ts.UART.write"
      ],
      "complexity": 14,
      "doc": null
    },
    "SwarmBrain.Blackboard.Fusion": {
      "modules": [
        "SwarmBrain.Blackboard.Fusion"
      ],
      "functions": [],
      "structs": [],
      "dependencies": [
        "Nx",
        "Nx.Defn"
      ],
      "complexity": 0,
      "doc": null
    },
    "SwarmBrain.Sensor.Proprioception": {
      "modules": [
        "SwarmBrain.Sensor.Proprioception"
      ],
      "functions": [
        "get_kinematics/0",
        "get_optical_flow/0"
      ],
      "structs": [],
      "dependencies": [
        "Native",
        "Nx",
        "Server",
        "SwarmBrain.Vision"
      ],
      "complexity": 5,
      "doc": null
    },
    "SwarmBrain.Sensor.Fusion": {
      "modules": [
        "SwarmBrain.Sensor.Fusion"
      ],
      "functions": [
        "dle_info(_m/2",
        "dle_info({:/2",
        "get_visual_target/0",
        "init/1",
        "start_link/1"
      ],
      "structs": [],
      "dependencies": [
        "GenServer",
        "Logger",
        "t.fi"
      ],
      "complexity": 7,
      "doc": null
    },
    "SwarmBrain.Vision.Native": {
      "modules": [
        "SwarmBrain.Vision.Native"
      ],
      "functions": [
        "check_health/1",
        "detect_change/1",
        "error/0",
        "get_flow_grid/1",
        "get_fused_state/1",
        "get_latest_frame/1",
        "get_spatial_state/3",
        "init_retina/3",
        "init_state/0",
        "setup_queryable/0",
        "start_camera/3",
        "update_spatial_state/4"
      ],
      "structs": [],
      "dependencies": [
        "Rustler"
      ],
      "complexity": 12,
      "doc": null
    },
    "SwarmBrain.Vision.Retina": {
      "modules": [
        "SwarmBrain.Vision.Retina"
      ],
      "functions": [
        "cess_frame(fr/1",
        "dle_cast({:/2",
        "init/1",
        "r_full_inference(frame/1",
        "start_link/1",
        "tensor(evisi/1"
      ],
      "structs": [],
      "dependencies": [
        ".analy",
        "Application",
        "GenServer",
        "Logger",
        "Server.ca",
        "SwarmBrain.Cortex",
        "SwarmBrain.Vision.Native",
        "SwarmBrain.Vision.Server",
        "ha",
        "ive.de",
        "m_",
        "n.Mat.from_",
        "n.Mat.roi({",
        "n.Mat.shape",
        "n.Mat.to_bi",
        "ver.ge"
      ],
      "complexity": 9,
      "doc": null
    },
    "SwarmBrain.Vision.Behaviour": {
      "modules": [
        "SwarmBrain.Vision.Behaviour"
      ],
      "functions": [],
      "structs": [],
      "dependencies": [],
      "complexity": 0,
      "doc": null
    },
    "SwarmBrain.Vision.NMS": {
      "modules": [
        "SwarmBrain.Vision.NMS"
      ],
      "functions": [
        "nms/2"
      ],
      "structs": [],
      "dependencies": [
        "Rustler"
      ],
      "complexity": 1,
      "doc": null
    },
    "SwarmBrain.Vision.Server": {
      "modules": [
        "SwarmBrain.Vision.Server"
      ],
      "functions": [
        "(tensor) do\n   /1",
        ":inference_/2",
        ":tick, stat/2",
        "do: Process.s/0",
        "get_resource/0",
        "init/1",
        "logy!(resource) d/1",
        "on, _stat/2",
        "start_link/1"
      ],
      "structs": [],
      "dependencies": [
        ".get_vision_",
        ".start_child(Sw",
        "Application",
        "GenServer",
        "Logger",
        "Native",
        "SharedBuffer",
        "SwarmBrain.Cortex.Yolo",
        "SwarmBrain.Vision",
        "_healt",
        "e.init",
        "e.star",
        "ex.Supervisor, fn ->\n      r",
        "kboard.update_vision(",
        "ng(\"\ud83d\udc7b",
        "nsor",
        "or(\"\u274c",
        "r.info",
        "ter(sel"
      ],
      "complexity": 14,
      "doc": null
    },
    "SwarmBrain.Vision.SharedBuffer": {
      "modules": [
        "SwarmBrain.Vision.SharedBuffer"
      ],
      "functions": [
        "get_vision_tensor/1"
      ],
      "structs": [],
      "dependencies": [
        "Application",
        "Logger",
        "Native",
        "Nx",
        "Server",
        "SwarmBrain.Vision"
      ],
      "complexity": 3,
      "doc": null
    },
    "SwarmBrain.Vision.PreProcessor": {
      "modules": [
        "SwarmBrain.Vision.PreProcessor"
      ],
      "functions": [
        "prepare_yolo/1"
      ],
      "structs": [],
      "dependencies": [
        "Nx",
        "Nx.Defn",
        "NxImage"
      ],
      "complexity": 1,
      "doc": null
    },
    "SwarmBrain.Vision.Decoder": {
      "modules": [
        "SwarmBrain.Vision.Decoder"
      ],
      "functions": [],
      "structs": [],
      "dependencies": [
        "Nx",
        "Nx.Defn"
      ],
      "complexity": 0,
      "doc": null
    },
    "SwarmBrain.Vision.Yolo.PostProcessor": {
      "modules": [
        "SwarmBrain.Vision.Yolo.PostProcessor"
      ],
      "functions": [],
      "structs": [],
      "dependencies": [
        "Nx",
        "Nx.Defn"
      ],
      "complexity": 0,
      "doc": null
    }
  },
  "dependency_graph": "graph TD\n  subgraph Swarm\n    SwarmBrain_MixProject[SwarmBrain.MixProject]\n    SwarmBrain_Blackboard[SwarmBrain.Blackboard]\n    SwarmBrain_Cortex[SwarmBrain.Cortex]\n    SwarmBrain_Formation[SwarmBrain.Formation]\n    SwarmBrain_Antenna[SwarmBrain.Antenna]\n    SwarmBrain_Application[SwarmBrain.Application]\n    SwarmBrain_Pipeline[SwarmBrain.Pipeline]\n    SwarmBrain_Telemetry_Codec[SwarmBrain.Telemetry.Codec]\n    SwarmBrain_Location[SwarmBrain.Location]\n    SwarmBrain_Radio[SwarmBrain.Radio]\n    SwarmBrain_Eye[SwarmBrain.Eye]\n    SwarmBrain_Watchman[SwarmBrain.Watchman]\n    SwarmBrain_Tactician[SwarmBrain.Tactician]\n    SwarmBrain_Discovery[SwarmBrain.Discovery]\n    SwarmBrain_Observation[SwarmBrain.Observation]\n    SwarmBrain_Persistence[SwarmBrain.Persistence]\n    SwarmBrain_Tracker[SwarmBrain.Tracker]\n    SwarmBrain_Telemetry_Dispatcher[SwarmBrain.Telemetry.Dispatcher]\n    SwarmBrain_Telemetry_Guard[SwarmBrain.Telemetry.Guard]\n    SwarmBrain_Telemetry_Monitor[SwarmBrain.Telemetry.Monitor]\n    SwarmBrain_Logic_Tactician[SwarmBrain.Logic.Tactician]\n    SwarmBrain_Actor_Network[SwarmBrain.Actor.Network]\n    SwarmBrain_Cortex_ResNet[SwarmBrain.Cortex.ResNet]\n    SwarmBrain_Cortex_Yolo[SwarmBrain.Cortex.Yolo]\n    SwarmBrain_Switchboard[SwarmBrain.Switchboard]\n    SwarmBrain_Cortex_Model[SwarmBrain.Cortex.Model]\n    SwarmBrain_Cortex_Watchdog[SwarmBrain.Cortex.Watchdog (C:13)]:::complex\n    SwarmBrain_Llama_Summarizer[SwarmBrain.Llama.Summarizer]\n    SwarmBrain_Hardware_Spine[SwarmBrain.Hardware.Spine (C:14)]:::complex\n    SwarmBrain_Blackboard_Fusion[SwarmBrain.Blackboard.Fusion]\n    SwarmBrain_Sensor_Proprioception[SwarmBrain.Sensor.Proprioception]\n    SwarmBrain_Sensor_Fusion[SwarmBrain.Sensor.Fusion]\n    SwarmBrain_Vision_Native[SwarmBrain.Vision.Native (C:12)]:::complex\n    SwarmBrain_Vision_Retina[SwarmBrain.Vision.Retina]\n    SwarmBrain_Vision_Behaviour[SwarmBrain.Vision.Behaviour]\n    SwarmBrain_Vision_NMS[SwarmBrain.Vision.NMS]\n    SwarmBrain_Vision_Server[SwarmBrain.Vision.Server (C:14)]:::complex\n    SwarmBrain_Vision_SharedBuffer[SwarmBrain.Vision.SharedBuffer]\n    SwarmBrain_Vision_PreProcessor[SwarmBrain.Vision.PreProcessor]\n    SwarmBrain_Vision_Decoder[SwarmBrain.Vision.Decoder]\n    SwarmBrain_Vision_Yolo_PostProcessor[SwarmBrain.Vision.Yolo.PostProcessor]\n    SwarmBrain_MixProject --> SwarmBrain_Application\n    SwarmBrain_Cortex --> SwarmBrain_Cortex_ResNet\n    SwarmBrain_Formation --> SwarmBrain_Telemetry_Codec\n    SwarmBrain_Pipeline --> SwarmBrain_Cortex\n    SwarmBrain_Pipeline --> SwarmBrain_Observation\n    SwarmBrain_Pipeline --> SwarmBrain_Persistence\n    SwarmBrain_Location --> SwarmBrain_Observation\n    SwarmBrain_Eye --> SwarmBrain_Observation\n    SwarmBrain_Discovery --> SwarmBrain_Persistence\n    SwarmBrain_Telemetry_Dispatcher --> SwarmBrain_Telemetry_Guard\n    SwarmBrain_Telemetry_Guard --> SwarmBrain_Telemetry_Codec\n    SwarmBrain_Telemetry_Guard --> SwarmBrain_Telemetry_Monitor\n    SwarmBrain_Cortex_ResNet --> SwarmBrain_Cortex_Model\n    SwarmBrain_Cortex_ResNet --> SwarmBrain_Vision_PreProcessor\n    SwarmBrain_Cortex_Yolo --> SwarmBrain_Cortex_Model\n    SwarmBrain_Cortex_Yolo --> SwarmBrain_Vision_PreProcessor\n    SwarmBrain_Vision_Retina --> SwarmBrain_Cortex\n    SwarmBrain_Vision_Retina --> SwarmBrain_Vision_Native\n    SwarmBrain_Vision_Retina --> SwarmBrain_Vision_Server\n    SwarmBrain_Vision_Server --> SwarmBrain_Cortex_Yolo\n  end\n  classDef complex fill:#f96,stroke:#333,stroke-width:2px;",
  "files": [
    {
      "path": "repo_to_json.py",
      "content": "import os\nimport json\nimport fnmatch\nimport re\nimport hashlib\n\n# --- CONFIGURATION ---\nMAX_FILE_SIZE = 64 * 1024  \nIGNORE_DIRS = [\n    '.git', '__pycache__', 'deps', '_build', 'node_modules', \n    '.elixir_ls', '.idea', '.vscode','target',\n    'Mnesia.*', 'mnesia.*', 'priv', 'assets'\n]\nIGNORE_EXTENSIONS = [\n    '.beam', '.ez', '.dll', '.so', '.o', '.a',\n    '.DCD', '.DAT', '.LOG', '.dcd', '.dat', '.log',\n    '.jpg', '.jpeg', '.png', '.gif', '.mp3', '.wav',\n    '.zip', '.tar', '.gz', '.lock'\n]\n\n# --- THE SOUL GEM (Meta-Instructions) ---\nMETA_INSTRUCTION = \"\"\"\nYOU ARE THE ARCHITECT. \nThis JSON file represents the complete nervous system of an Elixir Drone Swarm.\n1. 'system_map': High-level overview of modules and their capabilities.\n2. 'dependency_graph': A Mermaid diagram showing how modules connect.\n3. 'runtime_config': The wiring that connects these modules at boot time.\n4. 'files': The raw code bones and skeletons.\n\"\"\"\n\n\n# --- THE X-RAY SCANNER (v8.0 - HOLOGRAPHIC) ---\n\ndef extract_config_skeleton(content):\n    configs = []\n    matches = re.findall(r'^\\s*config\\s+:([a-zA-Z0-9_]+),\\s*:([a-zA-Z0-9_]+),\\s*(.+)', content, re.MULTILINE)\n    for app, key, val in matches:\n        configs.append(f\":{app} | :{key} => {val.strip()}\")\n    return configs\n\ndef extract_elixir_skeleton(content):\n    skeleton = {\n        \"doc\": None,\n        \"modules\": [],\n        \"dependencies\": [], \n        \"behaviors\": [],   \n        \"structs\": [],     \n        \"functions\": [],    \n        \"types\": [],\n        \"attributes\": [],   \n        \"todos\": []         \n    }\n    \n    doc_match = re.search(r'@moduledoc\\s+\"\"\"(.*?)\"\"\"', content, re.DOTALL)\n    if doc_match:\n        skeleton[\"doc\"] = doc_match.group(1).strip()[:200].replace(\"\\n\", \" \") + \"...\"\n\n    modules = re.findall(r'defmodule\\s+([A-Z][a-zA-Z0-9\\._]*)', content)\n    skeleton[\"modules\"] = modules\n    \n    # Capture raw alias names for the Graph\n    raw_aliases = re.findall(r'^\\s*alias\\s+([A-Z][a-zA-Z0-9\\._]*)', content, re.MULTILINE)\n    skeleton[\"dependencies\"].extend([f\"alias {a}\" for a in raw_aliases])\n    \n    imports = re.findall(r'^\\s*import\\s+([A-Z][a-zA-Z0-9\\._]*)', content, re.MULTILINE)\n    skeleton[\"dependencies\"].extend([f\"import {i}\" for i in imports])\n\n    uses = re.findall(r'^\\s*use\\s+([A-Z][a-zA-Z0-9\\._]*)', content, re.MULTILINE)\n    skeleton[\"behaviors\"].extend([f\"use {u}\" for u in uses])\n    \n    behaviours = re.findall(r'^\\s*@behaviour\\s+([A-Z][a-zA-Z0-9\\._]*)', content, re.MULTILINE)\n    skeleton[\"behaviors\"].extend([f\"implements {b}\" for b in behaviours])\n\n    struct_match = re.search(r'defstruct\\s+\\[(.*?)\\]', content, re.DOTALL)\n    if struct_match:\n        raw_keys = struct_match.group(1)\n        keys = re.findall(r':([a-z_][a-zA-Z0-9_]*)', raw_keys)\n        skeleton[\"structs\"] = keys\n\n    specs = re.findall(r'^\\s*@spec\\s+(.+)', content, re.MULTILINE)\n    skeleton[\"types\"].extend([f\"@spec {s.strip()}\" for s in specs])\n\n    def_matches = re.finditer(r'^\\s*(def|defp)\\s+([a-z_][a-zA-Z0-9_]*[\\?!]?)\\s*(\\(.*\\))?\\s*(do|,)', content, re.MULTILINE)\n    for m in def_matches:\n        kind = m.group(1)\n        name = m.group(2)\n        args_str = m.group(3)\n        arity = 0\n        if args_str:\n            arity = args_str.count(',') + 1\n        skeleton[\"functions\"].append(f\"{kind} {name}/{arity}\")\n\n    attrs = re.findall(r'^\\s*(@[a-z_]+)\\s+(.+)', content, re.MULTILINE)\n    skeleton[\"attributes\"] = [f\"{k} = {v}\" for k, v in attrs if k not in ['@moduledoc', '@doc', '@behaviour', '@spec', '@type']]\n\n    todos = re.findall(r'#\\s*(TODO|FIXME|HACK|NOTE):?\\s*(.*)', content, re.IGNORECASE)\n    skeleton[\"todos\"] = [f\"{tag.upper()}: {msg.strip()}\" for tag, msg in todos]\n\n    return skeleton, raw_aliases\n\ndef generate_mermaid_graph(system_map):\n    \"\"\"Generates a visual dependency graph for the LLM.\"\"\"\n    graph = [\"graph TD;\"]\n    for module, data in system_map.items():\n        # Shorten module names for cleaner graph (SwarmBrain.Radio -> Radio)\n        short_mod = module.split(\".\")[-1]\n        \n        for dep in data.get(\"raw_aliases\", []):\n            short_dep = dep.split(\".\")[-1]\n            # Avoid self-loops and common libs\n            if short_mod != short_dep and short_dep not in [\"Logger\", \"GenServer\", \"Application\"]:\n                graph.append(f\"    {short_mod} --> {short_dep};\")\n    \n    return \"\\n\".join(graph)\n\ndef generate_tree(path, prefix=\"\"):\n    tree_str = \"\"\n    try:\n        items = os.listdir(path)\n    except PermissionError:\n        return \"\"\n    items.sort(key=lambda x: (not os.path.isdir(os.path.join(path, x)), x))\n    filtered_items = []\n    for item in items:\n        if not any(fnmatch.fnmatch(item, pattern) for pattern in IGNORE_DIRS):\n            filtered_items.append(item)\n    pointers = [(\"\u251c\u2500\u2500 \" if i < len(filtered_items) - 1 else \"\u2514\u2500\u2500 \") for i in range(len(filtered_items))]\n    for pointer, item in zip(pointers, filtered_items):\n        full_path = os.path.join(path, item)\n        tree_str += prefix + pointer + item + \"\\n\"\n        if os.path.isdir(full_path):\n            extension = \"\u2502   \" if pointer == \"\u251c\u2500\u2500 \" else \"    \"\n            tree_str += generate_tree(full_path, prefix + extension)\n    return tree_str\n\ndef is_binary(file_path):\n    try:\n        with open(file_path, 'rb') as f:\n            chunk = f.read(1024)\n            if b'\\0' in chunk:\n                return True\n            try:\n                chunk.decode('utf-8')\n            except UnicodeDecodeError:\n                return True\n    except Exception:\n        return True\n    return False\n\ndef get_file_hash(file_path):\n    h = hashlib.md5()\n    try:\n        with open(file_path, 'rb') as f:\n            for chunk in iter(lambda: f.read(4096), b\"\"):\n                h.update(chunk)\n        return h.hexdigest()[:8]\n    except:\n        return \"error\"\n\ndef pack_repo(repo_path, output_file):\n    system_map = {} \n    runtime_config = []\n\n    repo_data = {\n        \"meta_instruction\": META_INSTRUCTION.strip(), # <--- The Soul Gem\n        \"project_name\": os.path.basename(os.path.abspath(repo_path)),\n        \"tree_view\": generate_tree(repo_path),\n        \"dependency_graph\": \"\", # <--- The Visual Cortex\n        \"system_map\": {}, \n        \"runtime_config\": [], \n        \"files\": []\n    }\n\n    print(f\"\ud83d\udc80 X-Raying Architecture: {repo_path}\")\n\n    for root, dirs, files in os.walk(repo_path):\n        for i in range(len(dirs) - 1, -1, -1):\n            d = dirs[i]\n            if any(fnmatch.fnmatch(d, pattern) for pattern in IGNORE_DIRS):\n                dirs.pop(i)\n\n        for file in files:\n            file_path = os.path.join(root, file)\n            rel_path = os.path.relpath(file_path, repo_path)\n            \n            _, ext = os.path.splitext(file)\n            if ext in IGNORE_EXTENSIONS:\n                continue\n\n            file_size = os.path.getsize(file_path)\n            file_type = \"binary\" if is_binary(file_path) else \"text\"\n            \n            if file_type == \"text\":\n                try:\n                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n                        full_content = f.read() \n                        \n                        skeleton = None\n                        if ext in ['.ex', '.exs']:\n                            # Extract Skeleton AND raw aliases for the graph\n                            skeleton, raw_aliases = extract_elixir_skeleton(full_content)\n                            \n                            if skeleton[\"modules\"]:\n                                mod_name = skeleton[\"modules\"][0]\n                                system_map[mod_name] = {\n                                    \"doc\": skeleton[\"doc\"], \n                                    \"functions\": skeleton[\"functions\"],\n                                    \"types\": skeleton[\"types\"],\n                                    \"dependencies\": skeleton[\"dependencies\"],\n                                    \"raw_aliases\": raw_aliases # Stored for graph gen\n                                }\n                                \n                            if \"config\" in rel_path and ext == \".exs\":\n                                config_lines = extract_config_skeleton(full_content)\n                                runtime_config.extend(config_lines)\n\n                        if file_size > MAX_FILE_SIZE:\n                            head = full_content[:2000]\n                            display_content = head + f\"\\n\\n[... \u2702\ufe0f VOID CUT: File too large ({file_size} bytes). Skeleton extracted below. ...]\"\n                            print(f\"\u26a0\ufe0f Truncating content for: {rel_path}\")\n                        else:\n                            display_content = full_content\n                        \n                        file_entry = {\n                            \"path\": rel_path,\n                            \"content\": display_content\n                        }\n\n                        if skeleton:\n                            file_entry[\"skeleton\"] = skeleton\n                        \n                        repo_data[\"files\"].append(file_entry)\n\n                except Exception as e:\n                    print(f\"\u274c Error: {rel_path} - {e}\")\n            else:\n                repo_data[\"files\"].append({\n                    \"path\": rel_path,\n                    \"size\": file_size,\n                    \"type\": \"binary\",\n                    \"hash\": get_file_hash(file_path)\n                })\n\n    # Inject Maps and Graphs\n    repo_data[\"system_map\"] = system_map\n    repo_data[\"runtime_config\"] = runtime_config\n    \n    # REVOLUTIONARY: Generate the Mermaid Graph\n    repo_data[\"dependency_graph\"] = generate_mermaid_graph(system_map)\n\n    print(f\"\ud83d\udcbe Compressing into the Void: {output_file}\")\n    with open(output_file, 'w', encoding='utf-8') as f:\n        json.dump(repo_data, f, indent=2)\n    print(\"\u2705 Analysis Complete.\")\n\nif __name__ == \"__main__\":\n    pack_repo(\".\", \"swarm_archive.json\")"
    },
    {
      "path": "enrich_with_vectors.py",
      "content": "# enrich_with_vectors.py\nimport json\nfrom sentence_transformers import SentenceTransformer\n\n# 1. Load the Brain (Fast, Local model)\n# \"all-MiniLM-L6-v2\" is a tiny, fast model perfect for code concepts.\nprint(\"\ud83e\udde0 Loading Neural Model...\")\nmodel = SentenceTransformer('all-MiniLM-L6-v2')\n\n# 2. Load the Archive\nwith open('swarm_archive.json', 'r') as f:\n    archive = json.load(f)\n\nprint(f\"\ud83d\udcc2 Loaded {len(archive['files'])} files. Injecting Neural Vectors...\")\n\n# 3. Inject Intelligence\nfor entry in archive['files']:\n    # We embed the code content. \n    # Optimization: Embed the *Skeleton* if the file is huge, or the *Module Doc* if available.\n    text_to_embed = entry.get('content', '')\n    \n    if text_to_embed:\n        # Turn text into math\n        vector = model.encode(text_to_embed).tolist()\n        \n        # Inject into JSON\n        entry['embedding_vector'] = vector\n        print(f\"    \u2728 Vectorized: {entry['path']}\")\n\n# 4. Save the \"Smart\" Archive\nwith open('swarm_archive_neural.json', 'w') as f:\n    json.dump(archive, f)\n\nprint(\"\u2705 Neural Injection Complete. The Archive can now 'think'.\")"
    },
    {
      "path": "mix.exs",
      "content": "defmodule SwarmBrain.MixProject do\n  use Mix.Project\n\n  def project do\n    [\n      app: :swarm_brain,\n      version: \"0.1.0\",\n      elixir: \"~> 1.15\",\n      start_permanent: Mix.env() == :prod,\n      deps: deps(),\n      rustler_crates: [\n        swarm_brain_tactician: [],\n        swarm_brain_nms: [],\n        swarm_vision: [mode: :release]\n      ]\n    ]\n  end\n\n  def application do\n    [\n      extra_applications: [:logger, :runtime_tools, :os_mon, :mnesia],\n      mod: {SwarmBrain.Application, []}\n    ]\n  end\n\n  defp deps do\n    [\n      # --- The Nervous System ---\n      {:phoenix_pubsub, \"~> 2.1\"},\n      {:horde, \"~> 0.9.0\"},\n      {:elixir_uuid, \"~> 1.2\"},\n      {:rustler, \"~> 0.30\"},\n      {:evision, \"~> 0.1\"},\n\n      # [NEW] Hive Mind Protocols\n      {:libcluster, \"~> 3.3\"},  # UDP Gossip Discovery\n      {:delta_crdt, \"~> 0.6\"},  # Anti-Entropy Data Sync\n\n      # --- The Hardware Interface ---\n      {:circuits_uart, \"~> 1.5\"},\n\n      # --- The Vision Cortex ---\n      {:bumblebee, \"~> 0.6.0\"},\n      {:exla, \"~> 0.9.0\"},\n      {:nx, \"~> 0.9.0\"},\n      {:axon, \"~> 0.7.0\"},\n      {:ortex, \"~> 0.1.9\"}\n    ]\n  end\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.MixProject"
        ],
        "functions": [
          "application/0",
          "deps/0",
          "project/0"
        ],
        "structs": [],
        "dependencies": [
          "Mix",
          "Mix.Project",
          "SwarmBrain.Application"
        ],
        "complexity": 3,
        "doc": null
      }
    },
    {
      "path": "flake.nix",
      "content": "{\n  description = \"The Unified Swarm: One Environment to Rule Them All\";\n\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-unstable\";\n    flake-utils.url = \"github:numtide/flake-utils\";\n  };\n\n  outputs = { self, nixpkgs, flake-utils }:\n    flake-utils.lib.eachDefaultSystem (system:\n      let\n        pkgs = import nixpkgs {\n          inherit system;\n          config.allowUnfree = true;\n        };\n\n        # ======================================================================\n        # \u26a0\ufe0f  ARCHITECT'S NOTE TO FUTURE TRAVELERS (AI OR HUMAN)  \u26a0\ufe0f\n        # ======================================================================\n        # THIS FLAKE IMPLEMENTS \"CLANG SUPREMACY\".\n        #\n        # We enforce the use of `clangStdenv` and explicitly link `libclang` to \n        # reconcile the Rust and Elixir compilation toolchains. \n        #\n        # DO NOT introduce GCC or standard `stdenv` overrides without understanding \n        # the delicate treaty between Rustler (NIFs) and the BEAM.\n        #\n        # Any change here must preserve:\n        # 1. LIBCLANG_PATH export.\n        # 2. BINDGEN_EXTRA_CLANG_ARGS with -isystem includes.\n        # 3. The exclusion of conflicting C standard libraries.\n        # ======================================================================\n        \n        # 1. Core BEAM Stack\n        beamStack = with pkgs; [ elixir_1_18 erlang_27 rebar3 ];\n\n        # 2. Scout & Archiver Tools\n        scoutTools = with pkgs; [ \n          python3 \n          python3Packages.tree-sitter\n          # We provide the raw grammars here. The Python script will \n          # build the binaries from these sources.\n          tree-sitter-grammars.tree-sitter-elixir\n          tree-sitter-grammars.tree-sitter-rust\n          \n          python3Packages.pymavlink \n          python3Packages.onnx \n          python3Packages.onnxruntime \n          python3Packages.numpy \n          python3Packages.sympy\n\n          python3Packages.sentence-transformers\n        ];\n        \n        # 3. Brain Tools (Aligned with Clang)\n        brainTools = with pkgs; [\n          libgphoto2 \n          opencv4 \n          pkg-config \n          cmake \n          libusb1 \n          ffmpeg-full \n          gnumake\n          libclang.lib\n          cargo \n          rustc\n        ];\n\n      in {\n        # CRITICAL: We override the standard environment with Clang.\n        devShells.default = pkgs.mkShell.override { stdenv = pkgs.clangStdenv; } {\n          name = \"swarm-unified\";\n          \n          nativeBuildInputs = [ \n            pkgs.libclang.lib \n            pkgs.pkg-config \n            pkgs.cmake \n          ]; \n          \n          buildInputs = beamStack ++ scoutTools ++ brainTools;\n\n          shellHook = ''\n            export MIX_ENV=dev\n            export NODE_NAME=\"$(hostname)\"\n            export EXLA_TARGET=host\n            export XLA_TARGET=cpu\n            export MIX_BUILD_PATH=\"$PWD/_build\"\n            export MIX_DEPS_PATH=\"$PWD/deps\"\n\n            # --- THE BUILDER'S BRIDGE (Clang Supremacy) ---\n            export LIBCLANG_PATH=\"${pkgs.libclang.lib}/lib\"\n\n            # CRITICAL: Bindgen headers for Rust/C++ interop\n            export BINDGEN_EXTRA_CLANG_ARGS=\" \\\n              -isystem ${pkgs.llvmPackages.libclang.lib}/lib/clang/${pkgs.llvmPackages.libclang.version}/include \\\n              -isystem ${pkgs.glibc.dev}/include\"\n\n            # --- THE NEURO-SCANNER LINK (Tree-Sitter Source Paths) ---\n            # We export the paths to the grammar SOURCES. \n            # The Python script will use these to compile the library on the fly.\n            export TS_ELIXIR_SRC=\"${pkgs.tree-sitter-grammars.tree-sitter-elixir}\"\n            export TS_RUST_SRC=\"${pkgs.tree-sitter-grammars.tree-sitter-rust}\"\n\n            echo \"\ud83d\udc1d Unified Swarm Environment Loaded\"\n            echo \"   - Toolchain: Clang Supremacy (Verified)\"\n            echo \"   - Context: Tree-Sitter Grammars Linked\"\n          '';\n        };\n      }\n    );\n}"
    },
    {
      "path": "ignite.sh",
      "content": "#!/usr/bin/env bash\n\n\n# \ud83d\udd75\ufe0f Auto-detect the local LAN IP\n# This grabs the first non-loopback IP address. \n# If it guesses wrong on the HP, just hardcode IP=\"192.168.1.147\"\nIP=$(ifconfig | grep -Eo 'inet (addr:)?([0-9]*\\.){3}[0-9]*' | grep -Eo '([0-9]*\\.){3}[0-9]*' | grep -v '127.0.0.1' | head -n1)\n\n# If ifconfig is missing in NixOS minimal, use 'ip':\nif [ -z \"$IP\" ]; then\n    IP=$(ip addr show | grep -oP '(?<=inet\\s)\\d+(\\.\\d+){3}' | grep -v '127.0.0.1' | head -n1)\nfi\n\nNAME=\"brain@$IP\"\nCOOKIE=\"swarm_class_a_secret\"\n\necho \"\ud83d\ude80 IGNITING SWARM NODE: $NAME\"\necho \"   - \ud83c\udf6a Cookie: Class A Secret\"\necho \"   - \ud83d\udee3\ufe0f  Ports: 40000-40100 (Firewall Lane)\"\n\n# The Magic Command\niex --name \"$NAME\" \\\n    --cookie \"$COOKIE\" \\\n    --erl \"-kernel inet_dist_listen_min 40000 inet_dist_listen_max 40100\" \\\n    -S mix"
    },
    {
      "path": "eye.jpg",
      "size": 4249073,
      "note": "Content Omitted (Too Large)"
    },
    {
      "path": "mirror.sh",
      "content": "#!/usr/bin/env bash\n\n# HP -> ASUS Sync\nTARGET_IP=\"192.168.1.243\" # Put your ASUS IP here\nTARGET_DIR=\"~/brain/\"\n\necho \"\ud83d\ude80 Swarm Intelligence Flow: HP -> ASUS\"\n\n# We watch EVERYTHING in the folder, but use rsync's exclusion to stay light.\n# This way, if you edit mix.exs or flake.nix, the ASUS gets it too.\nls -d ./* | entr -d rsync -avz \\\n    --exclude '_build' \\\n    --exclude 'deps' \\\n    --exclude '.git' \\\n    --exclude '.direnv' \\\n    . buddha@$TARGET_IP:$TARGET_DIR"
    },
    {
      "path": "brain_observations.csv",
      "content": "timestamp,label,score\n2026-01-06T03:29:02.993879Z,digital watch,0.6051\n2026-01-06T03:29:23.007748Z,stopwatch, stop watch,0.6688\n2026-01-06T03:29:41.611045Z,plastic bag,0.3439\n2026-01-06T03:29:58.005136Z,analog clock,0.9754\n2026-01-06T03:30:24.300711Z,analog clock,0.9664\n2026-01-06T03:30:40.755381Z,analog clock,0.9587\n2026-01-06T03:30:57.213873Z,analog clock,0.9554\n2026-01-06T03:31:14.427416Z,analog clock,0.9497\n2026-01-06T03:31:30.955959Z,analog clock,0.9749\n2026-01-06T03:31:47.616821Z,analog clock,0.9743\n2026-01-06T03:32:06.788626Z,analog clock,0.9798\n2026-01-06T03:32:23.249963Z,analog clock,0.9954\n2026-01-06T03:32:40.446610Z,analog clock,0.9957\n2026-01-06T03:32:57.008177Z,analog clock,0.9975\n2026-01-06T03:33:13.850068Z,analog clock,0.9975\n2026-01-06T03:33:31.064472Z,analog clock,0.9972\n2026-01-06T03:33:48.307230Z,analog clock,0.9976\n2026-01-07T17:48:09.979592Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T17:48:42.839427Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T17:49:16.053966Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T17:49:49.290233Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T17:50:22.481913Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T17:50:54.766080Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T17:51:27.111182Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T17:51:59.478315Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T17:52:31.871509Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T17:53:04.244999Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T17:53:36.646099Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T17:54:09.486646Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T17:54:42.001185Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T17:55:14.599836Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T17:55:47.085882Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T17:56:19.462206Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T17:56:51.857405Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T17:57:24.262521Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T17:57:56.731964Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T17:58:29.486961Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T17:59:01.877045Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T17:59:34.223593Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:00:06.649546Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:00:38.928866Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:01:11.328704Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:01:44.044639Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:02:16.377468Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:02:49.024814Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:03:21.916046Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:03:54.260803Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:04:26.591532Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:04:58.933539Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:05:31.265172Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:06:04.033692Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:06:36.676214Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:07:09.186192Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:07:41.595346Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:08:14.206375Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:08:46.725169Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:09:19.052586Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:09:51.429554Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:10:23.781557Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:10:56.412493Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:11:29.055721Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:12:01.354713Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:12:33.815989Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:13:06.240030Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:13:38.556823Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:14:10.972442Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:14:43.445665Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:15:15.818871Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:15:48.217034Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:16:20.515283Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:16:52.944290Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:17:25.383435Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:17:57.817248Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:18:30.331724Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:19:02.650286Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:19:35.236302Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:20:08.101777Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:20:40.423740Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:21:12.823357Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:21:45.177941Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:22:17.525583Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:22:50.166513Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:23:23.206329Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:23:55.511837Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:24:27.966472Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:25:00.336193Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:25:32.654913Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:26:05.242873Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:26:39.161033Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:27:15.353458Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:27:49.830597Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:28:23.417991Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:28:56.795457Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:29:30.448752Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:30:03.542974Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:30:36.666377Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:31:10.040362Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:31:43.093274Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:32:15.913717Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:32:48.568369Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:33:21.356034Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:33:53.647570Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:34:26.024061Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:34:58.342570Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:35:30.889361Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:36:03.738261Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:36:36.373866Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:37:09.039317Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:37:41.457012Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:38:14.076705Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:38:47.208730Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:39:19.666149Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:39:52.070029Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:40:24.651123Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:40:57.507879Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:41:31.095592Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:42:05.527105Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:42:37.931372Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:43:10.867388Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:43:43.746074Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:44:16.375063Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:44:48.854646Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:45:21.642227Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:45:55.274662Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:46:27.850945Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:47:00.431767Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:47:32.792081Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:48:05.467200Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:48:38.751027Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:49:11.929691Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:49:44.625502Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:50:17.157728Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:50:50.016319Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:51:52.556865Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:52:24.927441Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:52:57.707936Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:53:30.108493Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:54:02.542661Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:54:35.157047Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:55:07.918591Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:55:40.284454Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:56:12.698499Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:56:45.083170Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:57:17.518175Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:57:50.080701Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:58:22.503742Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:58:54.818999Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:59:27.109672Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T18:59:59.572633Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:00:31.977307Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:01:04.461587Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:01:36.913722Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:02:09.358394Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:03:11.418634Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:03:44.731444Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:04:17.188308Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:04:49.788099Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:05:22.367572Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:05:54.784646Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:06:27.138214Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:06:59.458047Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:07:31.898295Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:08:04.524159Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:08:37.015628Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:09:09.467355Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:09:41.911712Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:10:14.432848Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:10:47.230559Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:11:19.748709Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:21:21.411684Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:21:53.841915Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:22:26.389389Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:22:58.827988Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:23:31.134168Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:24:03.861055Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:24:36.326019Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:25:09.031049Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:25:41.658772Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:26:14.467613Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:26:46.877533Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:27:19.435708Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:27:51.940203Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:28:24.376381Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:28:56.728235Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:29:29.619693Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:30:01.999663Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:30:34.323416Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:31:06.709982Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:31:39.040371Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:32:11.391569Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:32:43.802611Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:33:16.133152Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:33:48.551573Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:34:21.878338Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:34:54.284643Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:35:26.798133Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:35:59.251435Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:36:31.527062Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:37:04.508203Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:37:36.917686Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:37:40.878691Z,CONNECTION,\"Swarm became one with node: brain@192.168.1.243\"\n2026-01-07T19:38:09.680019Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:38:42.120122Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:39:14.678582Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:40:11.025638Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:40:44.455746Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:41:16.801451Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:41:49.451171Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:42:22.529296Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:42:54.891718Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:43:27.416952Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:43:59.863973Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:44:32.277103Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:45:04.920367Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:45:38.154787Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:46:10.683034Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:46:43.446631Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:47:15.897687Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:47:48.359652Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:48:21.192223Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:48:53.613056Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:49:25.977347Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:49:58.638320Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:50:31.063411Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:51:03.719033Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:51:36.791038Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:52:09.688302Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:52:42.801247Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:53:15.383080Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:53:47.776449Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:54:20.249550Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:54:52.632259Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:55:24.993739Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:55:57.574077Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:56:30.066901Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:57:02.412580Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:57:34.895276Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:58:07.729238Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:58:40.086634Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:59:13.205375Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T19:59:45.725641Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:00:18.096717Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:00:50.717507Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:01:23.287094Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:01:55.577732Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:02:28.113332Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:03:00.541553Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:03:33.146163Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:04:05.632497Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:04:38.001344Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:05:10.355913Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:05:17.725194Z,DISCONNECT,\"Lost connection to node: brain@192.168.1.243\"\n2026-01-07T20:05:43.138911Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:06:15.605351Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:06:47.936239Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:07:20.252181Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:07:44.474535Z,CONNECTION,\"Swarm became one with node: brain@192.168.1.243\"\n2026-01-07T20:07:52.600731Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:08:24.991789Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:08:57.436052Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:09:29.969749Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:10:37.953373Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:11:10.481098Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:11:44.192776Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:12:16.617176Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:12:49.685828Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:13:23.066723Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:15:21.671285Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:15:55.120982Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:16:27.685483Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:17:00.521513Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:17:32.897592Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:18:05.709805Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:18:39.094746Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:19:11.376439Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:19:18.293114Z,DISCONNECT,\"Lost connection to node: brain@192.168.1.243\"\n2026-01-07T20:19:44.064997Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:19:55.072175Z,CONNECTION,\"Swarm became one with node: brain@192.168.1.243\"\n2026-01-07T20:20:16.413447Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:20:49.150248Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:21:03.004738Z,DISCONNECT,\"Lost connection to node: brain@192.168.1.243\"\n2026-01-07T20:21:21.943204Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:21:54.255135Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:22:26.642456Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:22:58.980059Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:23:31.353975Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:24:04.054085Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:24:36.670845Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:25:09.342320Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:26:24.594246Z,CONNECTION,\"Swarm became one with node: brain@192.168.1.243\"\n2026-01-07T20:26:33.068124Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:27:05.487825Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:27:37.954787Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:28:10.392087Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:28:43.376343Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:29:15.891638Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:29:48.443119Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:30:20.913177Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:30:53.369671Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:31:25.785095Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:31:58.581974Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:32:31.880435Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:33:04.682346Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:33:37.193380Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:34:09.556633Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:34:42.120138Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:35:14.704699Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:35:47.227366Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:36:19.831973Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:36:52.305132Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:37:25.450495Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:37:58.390902Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:38:30.983641Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:39:03.501637Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:39:36.266322Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:40:08.971742Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:40:42.258595Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:41:14.906888Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:41:47.651331Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:42:20.176597Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:42:52.899408Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:43:25.391166Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:43:57.936135Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:44:30.579635Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:45:03.165301Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:45:35.910513Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:46:09.597364Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:46:42.860096Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:47:15.490404Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:47:47.940899Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:48:20.758329Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:48:53.428485Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:49:26.088566Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:49:58.532787Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:50:30.917580Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:51:03.530914Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:51:37.115823Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:52:09.612900Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:52:42.154264Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:53:14.613705Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:53:47.038004Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:54:19.376864Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:54:51.860574Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:54:58.798830Z,DISCONNECT,\"Lost connection to node: brain@192.168.1.243\"\n2026-01-07T20:55:24.217278Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:55:56.820637Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:56:04.562582Z,CONNECTION,\"Swarm became one with node: brain@192.168.1.243\"\n2026-01-07T20:56:29.407261Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:57:01.841652Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:57:34.199916Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:58:06.487310Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:58:38.908980Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:59:05.276137Z,DISCONNECT,\"Lost connection to node: brain@192.168.1.243\"\n2026-01-07T20:59:11.269087Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T20:59:43.807199Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:00:16.277619Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:00:48.565403Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:01:21.142375Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:01:53.452862Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:01:53.453814Z,CONNECTION,\"Swarm became one with node: brain@192.168.1.243\"\n2026-01-07T21:02:25.868334Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:02:58.159004Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:03:30.543313Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:04:02.975569Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:04:24.866818Z,DISCONNECT,\"Lost connection to node: brain@192.168.1.243\"\n2026-01-07T21:04:35.547728Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:05:08.156707Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:05:40.664876Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:06:13.026547Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:06:45.444283Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:07:17.798794Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:07:30.895675Z,CONNECTION,\"Swarm became one with node: brain@192.168.1.243\"\n2026-01-07T21:07:50.262028Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:08:22.708577Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:08:55.093631Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:09:27.452196Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:09:59.904341Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:10:32.255174Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:11:04.885936Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:11:37.175306Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:12:09.569989Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:12:42.088533Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:12:42.089473Z,DISCONNECT,\"Lost connection to node: brain@192.168.1.243\"\n2026-01-07T21:13:14.534442Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:13:47.005200Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:14:19.301994Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:14:19.303864Z,CONNECTION,\"Swarm became one with node: brain@192.168.1.243\"\n2026-01-07T21:14:51.704262Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:15:24.085894Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:15:56.500752Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:16:29.351503Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:16:47.893286Z,DISCONNECT,\"Lost connection to node: brain@192.168.1.243\"\n2026-01-07T21:17:18.761552Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:17:51.170703Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:18:23.527404Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:18:40.423478Z,CONNECTION,\"Swarm became one with node: brain@192.168.1.243\"\n2026-01-07T21:18:56.009584Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:19:28.602994Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:20:01.028014Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:20:33.415716Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:21:05.677055Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:21:38.109876Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:22:10.770509Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:22:22.005340Z,DISCONNECT,\"Lost connection to node: brain@192.168.1.243\"\n2026-01-07T21:22:43.341254Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:23:15.804257Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:23:48.570780Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:24:21.782906Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:24:54.189678Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:25:26.889853Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:25:59.459357Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:26:31.790940Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:27:04.558125Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:27:38.033278Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:28:11.557610Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:28:44.009585Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:29:16.545432Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:29:49.345579Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:30:22.023523Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:30:54.454239Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:31:26.814894Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:31:59.284678Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:32:31.637305Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:33:04.229337Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:33:36.890392Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:34:09.484500Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:34:42.062916Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:35:14.572014Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:35:46.976031Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:36:19.371224Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:36:51.708086Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:37:24.140792Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:37:56.745735Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:38:29.570369Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:39:01.957585Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:39:34.275364Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:40:06.635903Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:40:39.042445Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:41:11.420941Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:41:43.930017Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:42:47.954933Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:43:20.441210Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:43:52.666482Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:44:07.121417Z,CONNECTION,\"Swarm became one with node: brain@192.168.1.243\"\n2026-01-07T21:44:24.898309Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:44:57.292609Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:45:29.646409Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:46:01.820625Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:46:34.045211Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:47:06.236904Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:47:38.441543Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:48:10.906260Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:48:45.759193Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:49:18.176595Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:49:50.754587Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:50:23.034545Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:50:31.405308Z,DISCONNECT,\"Lost connection to node: brain@192.168.1.243\"\n2026-01-07T21:50:37.341200Z,CONNECTION,\"Swarm became one with node: brain@192.168.1.243\"\n2026-01-07T21:50:55.223432Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:51:27.384176Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:51:59.507032Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:52:24.213222Z,DISCONNECT,\"Lost connection to node: brain@192.168.1.243\"\n2026-01-07T21:52:31.700669Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:52:37.433693Z,CONNECTION,\"Swarm became one with node: brain@192.168.1.243\"\n2026-01-07T21:53:04.080524Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:53:36.706074Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:54:09.587582Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:54:42.080559Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:55:14.461290Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:55:46.765740Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:56:18.995528Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:56:51.400706Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:57:23.628606Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:57:56.029414Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:58:28.523600Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:59:00.840914Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T21:59:33.046277Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:00:05.281022Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:00:38.429735Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:01:12.919390Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:01:45.348656Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:02:17.566279Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:02:50.129996Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:03:22.589714Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:03:54.902979Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:04:27.047019Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:04:59.260022Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:05:31.585611Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:06:04.440155Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:06:36.848109Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:07:09.033528Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:07:41.251242Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:08:13.427560Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:08:45.956876Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:09:20.237428Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:09:52.625704Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:10:24.835430Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:10:57.169645Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:11:29.537333Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:12:01.729975Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:12:34.115820Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:13:06.330440Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:13:38.556267Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:14:10.720661Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:14:43.682037Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:15:16.314677Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:15:48.608018Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:16:20.882721Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:16:53.228605Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:17:25.398023Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:17:57.716587Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:18:30.099729Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:19:02.326361Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:19:34.699052Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:20:07.287503Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:20:39.494031Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:21:11.786845Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:21:44.227087Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:22:16.451975Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:22:48.665956Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:23:21.043586Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:23:53.207473Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:24:25.346875Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:24:58.191971Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:25:30.545113Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:26:02.697587Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:26:35.132717Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:27:07.667230Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:27:40.028462Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:28:12.228765Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:28:44.474278Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:29:16.685387Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:29:48.967577Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:30:21.359703Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:30:53.527972Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:31:27.973368Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:32:02.685457Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:32:37.381076Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:33:12.208977Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:33:45.223517Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:34:19.073132Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:34:52.387685Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:35:24.695364Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:35:34.486061Z,DISCONNECT,\"Lost connection to node: brain@192.168.1.243\"\n2026-01-07T22:35:57.117482Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:36:29.634374Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:37:02.079337Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:37:34.295544Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:38:06.649246Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:38:38.904615Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:39:11.266506Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:39:43.793037Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:40:16.062520Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:40:48.304996Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:41:20.675204Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:41:52.983490Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:42:26.000410Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:42:58.278202Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:43:31.003413Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:44:03.610332Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:44:36.683848Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:45:09.789771Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:45:42.903139Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:46:15.684510Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:46:48.010567Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:47:20.331657Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:47:53.431982Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:48:26.007488Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:48:58.245305Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:49:30.415612Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:50:04.356665Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:50:36.735333Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:51:09.569458Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:51:41.870094Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:52:14.631458Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:52:46.949766Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:53:19.391004Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:53:51.656586Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:54:24.041128Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:54:57.627801Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:55:31.010257Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:56:36.955776Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:57:09.352719Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:57:42.106428Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:58:14.707434Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:58:47.117152Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:59:19.435229Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-07T22:59:51.709063Z,OBSERVATION,\"digital watch (96.09%)\"\n2026-01-08T22:06:44.767076Z,SIGHTING,\"Detected digital watch (96.1%) at [49.8481, 24.0397] by brain@192.168.1.147\"\n2026-01-08T22:34:14.055846Z,SIGHTING,\"Detected digital watch (96.1%) at [49.8481, 24.0397] by brain@192.168.1.147\"\n2026-01-08T22:56:56.550303Z,SIGHTING,\"Detected digital watch (96.1%) at [49.8481, 24.0397] by brain@192.168.1.147\"\n2026-01-09T00:23:50.795059Z,CONNECTION,\"Swarm became one with node: brain@192.168.1.243\"\n2026-01-09T00:28:05.046424Z,DISCONNECT,\"Lost connection to node: brain@192.168.1.243\"\n2026-01-09T00:29:25.307108Z,CONNECTION,\"Swarm became one with node: brain@192.168.1.243\"\n2026-01-09T00:29:40.600168Z,DISCONNECT,\"Lost connection to node: brain@192.168.1.243\"\n2026-01-09T00:37:07.217256Z,CONNECTION,\"Swarm became one with node: brain@192.168.1.243\"\n2026-01-09T02:09:51.148609Z,DISCONNECT,\"Lost connection to node: brain@192.168.1.243\"\n"
    },
    {
      "path": "neural_search.py",
      "content": "import json\nimport numpy as np\nfrom sentence_transformers import SentenceTransformer\n\n# --- CONFIGURATION ---\nARCHIVE_FILE = \"swarm_archive_neural.json\"\nMODEL_NAME = 'all-MiniLM-L6-v2'\n\ndef cosine_similarity(a, b):\n    return np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b))\n\ndef load_archive():\n    print(f\"\ud83d\udcc2 Loading the Neural Archive: {ARCHIVE_FILE}...\")\n    try:\n        with open(ARCHIVE_FILE, 'r') as f:\n            return json.load(f)\n    except FileNotFoundError:\n        print(\"\u274c Error: Archive not found. Did you run enrich_with_vectors.py?\")\n        exit(1)\n\ndef main():\n    # 1. Load Data & Model\n    archive = load_archive()\n    print(f\"\ud83e\udde0 Loading Neural Model ({MODEL_NAME})...\")\n    model = SentenceTransformer(MODEL_NAME)\n    \n    files = archive.get('files', [])\n    # Filter only files that have vectors\n    vectorized_files = [f for f in files if 'embedding_vector' in f]\n    print(f\"\u2728 Index active. {len(vectorized_files)} neural nodes ready.\")\n\n    print(\"\\n\ud83d\udd2e THE VOID ARCHITECT LISTENS. (Type 'exit' to quit)\")\n    \n    while True:\n        query = input(\"\\n\u2753 Query: \")\n        if query.lower() in ['exit', 'quit']:\n            break\n            \n        # 2. Vectorize the User's Query\n        query_vector = model.encode(query)\n        \n        # 3. Search (Compare Query Vector to Code Vectors)\n        results = []\n        for entry in vectorized_files:\n            code_vector = entry['embedding_vector']\n            score = cosine_similarity(query_vector, code_vector)\n            results.append((score, entry))\n            \n        # 4. Sort by Similarity\n        results.sort(key=lambda x: x[0], reverse=True)\n        \n        # 5. Display Top 3 Matches\n        print(f\"\\n\ud83d\udd39 Top Matches for '{query}':\")\n        for i in range(min(3, len(results))):\n            score, entry = results[i]\n            print(f\"   {i+1}. [{score:.4f}] {entry['path']}\")\n            # Optional: Show a snippet of why it matched\n            # print(f\"      Context: {entry['content'][:100]}...\")\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "path": "models/yolov8n/model.safetensors",
      "size": 102482854,
      "note": "Content Omitted (Too Large)"
    },
    {
      "path": "native/swarm_vision/Cargo.toml",
      "content": "[package]\nname = \"swarm_vision\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[lib]\nname = \"swarm_vision\"\ncrate-type = [\"cdylib\"]\n\n[dependencies]\n# Match Elixir's Rustler version\nrustler = \"0.36.0\"\n\n# The Standard Vision Stack\n# We disable default features to avoid compiling heavy AV1/TIFF codecs\nimage = { version = \"0.25\", default-features = false, features = [\"png\", \"jpeg\"] }\n\n# Future-Proofing: Algorithms for ROI, Edges, and Geometry\nimageproc = { version = \"0.25\", default-features = false }"
    },
    {
      "path": "native/swarm_vision/src/lib.rs",
      "content": "use rustler::{ResourceArc, Binary, Env, Term, Atom, Encoder};\nuse std::sync::RwLock;\nuse image::{GrayImage, ImageBuffer, Luma};\n\nmod atoms {\n    rustler::atoms! {\n        ok,\n        error,\n        no_change,\n        change,\n        invalid_shape\n    }\n}\n\nstruct RetinaState {\n    // We use GrayImage (8-bit Luma) for maximum speed and compatibility\n    last_frame: RwLock<Option<GrayImage>>,\n    width: u32,\n    height: u32,\n    threshold: u32,\n}\n\n#[rustler::nif]\nfn init_retina(width: u32, height: u32, threshold: u32) -> (Atom, ResourceArc<RetinaState>) {\n    let state = RetinaState {\n        last_frame: RwLock::new(None),\n        width,\n        height,\n        threshold,\n    };\n    (atoms::ok(), ResourceArc::new(state))\n}\n\n#[rustler::nif]\nfn detect_change<'a>(env: Env<'a>, resource: ResourceArc<RetinaState>, input: Binary<'a>) -> Term<'a> {\n    let mut state = resource.last_frame.write().unwrap();\n    \n    // Safety: Ensure input binary matches expected dimensions\n    if input.len() != (resource.width * resource.height) as usize {\n        return (atoms::error(), atoms::invalid_shape()).encode(env);\n    }\n\n    // 1. Ingest: Zero-copy creation of the container (vectors own data)\n    let current_bytes = input.as_slice().to_vec();\n    let current_img = match GrayImage::from_raw(resource.width, resource.height, current_bytes) {\n        Some(img) => img,\n        None => return (atoms::error(), atoms::invalid_shape()).encode(env),\n    };\n\n    match &*state {\n        Some(previous_img) => {\n            // 2. Fast Entropy Calculation (SAD)\n            // We iterate manually for SIMD-friendly linear scanning\n            let sad: u32 = current_img.as_raw().iter()\n                .zip(previous_img.as_raw().iter())\n                .map(|(a, b)| (*a as i32 - *b as i32).abs() as u32)\n                .sum();\n\n            if sad < resource.threshold {\n                *state = Some(current_img);\n                atoms::no_change().encode(env)\n            } else {\n                // 3. ROI Calculation\n                // Note: In the future, we can use imageproc::contours here!\n                let (x, y, w, h) = calculate_roi(&current_img, previous_img);\n                *state = Some(current_img);\n                (atoms::change(), (x, y, w, h)).encode(env)\n            }\n        }\n        None => {\n            *state = Some(current_img);\n            atoms::no_change().encode(env)\n        }\n    }\n}\n\n// Tactical ROI Scanner\nfn calculate_roi(current: &GrayImage, previous: &GrayImage) -> (u32, u32, u32, u32) {\n    let width = current.width();\n    let height = current.height();\n    let mut min_x = width;\n    let mut max_x = 0;\n    let mut min_y = height;\n    let mut max_y = 0;\n    \n    let noise_gate = 15; \n\n    // Linear scan is cache-friendly\n    for (i, (p1, p2)) in current.as_raw().iter().zip(previous.as_raw().iter()).enumerate() {\n        let diff = (*p1 as i32 - *p2 as i32).abs();\n        \n        if diff > noise_gate {\n            let x = (i as u32) % width;\n            let y = (i as u32) / width;\n\n            if x < min_x { min_x = x; }\n            if x > max_x { max_x = x; }\n            if y < min_y { min_y = y; }\n            if y > max_y { max_y = y; }\n        }\n    }\n\n    if max_x < min_x {\n        return (0, 0, width, height);\n    }\n\n    (min_x, min_y, max_x - min_x, max_y - min_y)\n}\n\nrustler::init!(\"Elixir.SwarmBrain.Vision.Native\", [init_retina, detect_change], load = on_load);\n\nfn on_load(env: Env, _info: Term) -> bool {\n    rustler::resource!(RetinaState, env);\n    true\n}",
      "skeleton": {
        "structs": [
          "RetinaState"
        ],
        "functions": [
          "calculate_roi",
          "detect_change",
          "init_retina",
          "on_load"
        ],
        "complexity": 11
      }
    },
    {
      "path": "native/swarm_brain_nms/Cargo.toml",
      "content": "[package]\nname = \"swarm_brain_nms\"\nversion = \"0.1.0\"\nauthors = []\nedition = \"2021\"\n\n[lib]\ncrate-type = [\"cdylib\"]\n\n[dependencies]\nrustler = \"0.37.0\"\n"
    },
    {
      "path": "native/swarm_brain_nms/README.md",
      "content": "# NIF for SwarmBrain.Vision.NMS\n\n## To build the NIF module:\n\n- Your NIF will now build along with your project.\n\n## To load the NIF:\n\n```elixir\ndefmodule SwarmBrain.Vision.NMS do\n  use Rustler, otp_app: :swarm_brain, crate: \"swarm_brain_nms\"\n\n  # When your NIF is loaded, it will override this function.\n  def add(_a, _b), do: :erlang.nif_error(:nif_not_loaded)\nend\n```\n\n## Examples\n\n[This](https://github.com/rusterlium/NifIo) is a complete example of a NIF written in Rust.\n"
    },
    {
      "path": "native/swarm_brain_nms/src/lib.rs",
      "content": "use rustler::{NifStruct, Atom, Term};\n\n#[derive(NifStruct, Clone, Debug)]\n#[module = \"SwarmBrain.Vision.Box\"]\npub struct Rect {\n    pub x1: f32,\n    pub y1: f32,\n    pub x2: f32,\n    pub y2: f32,\n    pub score: f32,\n    pub label: String,\n}\n\n#[rustler::nif]\npub fn nms(boxes: Vec<Rect>, iou_threshold: f32) -> Vec<Rect> {\n    let mut detections = boxes;\n\n    // Optimization: Sort Ascending so .pop() gives the highest score efficiently\n    detections.sort_by(|a, b| a.score.partial_cmp(&b.score).unwrap_or(std::cmp::Ordering::Equal));\n\n    let mut kept = Vec::with_capacity(detections.len());\n\n    while let Some(best) = detections.pop() {\n        kept.push(best.clone());\n\n        // Remove any remaining box that overlaps too much with 'best'\n        // We iterate backwards to safely remove items\n        detections.retain(|item| calculate_iou(&best, item) < iou_threshold);\n    }\n    \n    kept\n}\n\nfn calculate_iou(a: &Rect, b: &Rect) -> f32 {\n    let x_left = a.x1.max(b.x1);\n    let y_top = a.y1.max(b.y1);\n    let x_right = a.x2.min(b.x2);\n    let y_bottom = a.y2.min(b.y2);\n\n    if x_right < x_left || y_bottom < y_top {\n        return 0.0;\n    }\n\n    let intersection_area = (x_right - x_left) * (y_bottom - y_top);\n    let area_a = (a.x2 - a.x1) * (a.y2 - a.y1);\n    let area_b = (b.x2 - b.x1) * (b.y2 - b.y1);\n\n    intersection_area / (area_a + area_b - intersection_area)\n}\n\nrustler::init!(\"Elixir.SwarmBrain.Vision.NMS\", [nms]);",
      "skeleton": {
        "structs": [
          "Rect"
        ],
        "functions": [
          "calculate_iou",
          "nms"
        ],
        "complexity": 1
      }
    },
    {
      "path": "native/swarm_native/Cargo.toml",
      "content": "[package]\nname = \"swarm_native\"\nversion = \"0.1.0\"\nauthors = [\"SwarmBrain Architect\"]\nedition = \"2021\"\n\n[lib]\nname = \"swarm_native\"\npath = \"src/lib.rs\"\ncrate-type = [\"cdylib\"]\n\n[dependencies]\n# Pinning to modern stable versions to prevent cascades\nrustler = \"0.37.0\"\nzenoh = \"1.7.2\"\ndashmap = \"6.1.0\"\nlazy_static = \"1.4\"\nbincode = \"1.3.3\" # do not change this stable version to maintain predictability of API interation\nserde = { version = \"1.0\", features = [\"derive\"] }\nimage = \"0.25.2\""
    },
    {
      "path": "native/swarm_native/src/lib.rs",
      "content": "// native/swarm_native/src/lib.rs\n\n//! # THE IRON LUNG (SwarmNative) - Refactored\n//! \n//! This is the \"Diamond\" tip of the architecture, now modularized \n//! for Class A performance and maintainability.\n\n// 1. Module Registration\n// These must match the folder names in src/\nmod types;\nmod state;\nmod vision;\nmod nifs;\n\nuse rustler::{Env, Term};\n\n/// The 'on_load' handler. \n/// Registers the SwarmState resource so the BEAM can manage its lifecycle.\nfn load(env: Env, _info: Term) -> bool {\n    // Matches src/state/arena.rs\n    rustler::resource!(state::arena::SwarmState, env);\n    true\n}\n\n// THE FINAL MANIFEST\nrustler::init!(\n    \"Elixir.SwarmBrain.Vision.Native\",\n    [\n        // 1. Control Path (nifs/control.rs)\n        nifs::control::init_state,\n        nifs::control::start_camera,\n        nifs::control::check_health,\n\n        // 2. Telemetry Path (nifs/telemetry.rs)\n        // CHANGED: 'sensing' -> 'telemetry' to match your file name\n        nifs::telemetry::get_latest_frame,\n        nifs::telemetry::get_fused_state,\n        nifs::telemetry::get_flow_grid,\n\n        // 3. Legacy Path (nifs/legacy.rs)\n        // Note: Removed 'setup_queryable'/'init_retina' as they are not in legacy.rs\n        nifs::legacy::detect_change,\n        nifs::legacy::update_spatial_state,\n        nifs::legacy::get_spatial_state\n    ],\n    load = load\n);",
      "skeleton": {
        "structs": [],
        "functions": [
          "load"
        ],
        "complexity": 0
      }
    },
    {
      "path": "native/swarm_native/src/types/atomic_f32.rs",
      "content": "// native/swarm_native/src/types/atomic_f32.rs\n\nuse std::sync::atomic::{AtomicU32, Ordering};\n\n/// A floating-point number that can be safely shared between threads.\n///\n/// # ARCHITECTURAL TACTIC: Cache Isolation\n/// We use `#[repr(align(64))]` to ensure that this value occupies its own\n/// exclusive cache line. This prevents \"False Sharing\" where a write to 'vx'\n/// invalidates the CPU cache for 'vy' just because they are neighbors.\n///\n/// Size penalty: Each float takes 64 bytes instead of 4.\n/// Benefit: Zero bus contention between Camera (Write) and Elixir (Read).\n#[repr(align(64))]\npub struct AtomicF32 {\n    storage: AtomicU32,\n}\n\nimpl AtomicF32 {\n    /// Create a new atomic float.\n    pub fn new(val: f32) -> Self {\n        let bit_cast = val.to_bits();\n        Self {\n            storage: AtomicU32::new(bit_cast),\n        }\n    }\n\n    /// Load the value (Elixir Reading).\n    /// Ordering::Acquire ensures we see the latest write from the camera loop.\n    #[inline(always)]\n    pub fn load(&self) -> f32 {\n        let bit_cast = self.storage.load(Ordering::Acquire);\n        f32::from_bits(bit_cast)\n    }\n\n    /// Store a value (Camera Writing).\n    /// Ordering::Release ensures that all math prior to this store is visible\n    /// to the reader.\n    #[inline(always)]\n    pub fn store(&self, val: f32) {\n        let bit_cast = val.to_bits();\n        self.storage.store(bit_cast, Ordering::Release);\n    }\n}\n\n// Allow default initialization (0.0)\nimpl Default for AtomicF32 {\n    fn default() -> Self {\n        Self::new(0.0)\n    }\n}",
      "skeleton": {
        "structs": [
          "AtomicF32"
        ],
        "functions": [
          "default",
          "load",
          "new",
          "store"
        ],
        "complexity": 0
      }
    },
    {
      "path": "native/swarm_native/src/types/mod.rs",
      "content": "// native/swarm_native/src/types/mod.rs\n\npub mod atomic_f32;\n\n// Re-export the primitive for easier access\npub use atomic_f32::AtomicF32;\n\n/// The Physiological State of the Drone.\n///\n/// This struct aggregates the atomic telemetry.\n/// Because each `AtomicF32` is aligned to 64 bytes (cache line isolation),\n/// this struct guarantees no \"False Sharing\" between the Camera Thread (Writer)\n/// and the NIF Thread (Reader).\npub struct Kinematics {\n    pub vx: AtomicF32, // Velocity X\n    pub vy: AtomicF32, // Velocity Y\n    pub px: AtomicF32, // Position X (Integrated)\n    pub py: AtomicF32, // Position Y (Integrated)\n}\n\n// Zero-initialization for boot\nimpl Default for Kinematics {\n    fn default() -> Self {\n        Self {\n            vx: AtomicF32::new(0.0),\n            vy: AtomicF32::new(0.0),\n            px: AtomicF32::new(0.0),\n            py: AtomicF32::new(0.0),\n        }\n    }\n}",
      "skeleton": {
        "structs": [
          "Kinematics"
        ],
        "functions": [
          "default"
        ],
        "complexity": 0
      }
    },
    {
      "path": "native/swarm_native/src/state/arena.rs",
      "content": "// native/swarm_native/src/state/arena.rs\n\nuse std::sync::{Arc, Mutex, RwLock};\nuse std::sync::atomic::{AtomicU32, AtomicUsize};\nuse std::process::Child;\nuse dashmap::DashMap; // <--- Critical for legacy support\nuse crate::types::Kinematics;\n\n// Constants for Pre-Allocation\npub const FRAME_WIDTH: usize = 640;\npub const FRAME_HEIGHT: usize = 480;\npub const FRAME_CHANNELS: usize = 3;\npub const FRAME_SIZE: usize = FRAME_WIDTH * FRAME_HEIGHT * FRAME_CHANNELS;\n\n/// The Raw Frame container.\npub struct FrameBuffer {\n    pub data: Mutex<Vec<u8>>,\n}\n\n/// The Triple Buffer state machine.\n/// Note: 'last_flow_grid' is REMOVED here because it is now thread-local in camera.rs\npub struct TripleBufferState {\n    pub slots: [Arc<FrameBuffer>; 3],\n    pub write_idx: AtomicUsize, \n    pub ready_idx: AtomicUsize,\n}\n\n/// The Swarm Resource (The \"God Object\" handle).\n#[derive(Clone)] // 1. Allow cloning the handle\npub struct SwarmState {\n    // 1. The Nervous System (400Hz Path)\n    pub physiology: Arc<Kinematics>,        \n    \n    // 2. The Visual Cortex (30Hz Path)\n    pub memory: Arc<TripleBufferState>,     \n    \n    // 3. The Health Monitor (Process Path)\n    pub child_process: Arc<Mutex<Option<Child>>>,\n    \n    // 4. The Kill Switch (Control Path)\n    pub running: Arc<AtomicU32>,            \n    \n    // 5. The Insect Eye (Math Path - Optical Flow Grid)\n    pub flow_grid: Arc<RwLock<[f32; 200]>>, \n\n    // 6. The Spatial Memory (Legacy/Spatial Path)\n    // Kept here so NIFs can access it via the main resource handle.\n    pub spatial_memory: Arc<DashMap<(i32, i32), u32>>, \n}\n\nimpl SwarmState {\n    pub fn new() -> Self {\n        let buffer = Arc::new(TripleBufferState {\n            slots: [\n                Arc::new(FrameBuffer { data: Mutex::new(vec![0u8; FRAME_SIZE]) }),\n                Arc::new(FrameBuffer { data: Mutex::new(vec![0u8; FRAME_SIZE]) }),\n                Arc::new(FrameBuffer { data: Mutex::new(vec![0u8; FRAME_SIZE]) }),\n            ],\n            write_idx: AtomicUsize::new(0),\n            ready_idx: AtomicUsize::new(2),\n        });\n\n        Self {\n            physiology: Arc::new(Kinematics::default()),\n            memory: buffer,\n            child_process: Arc::new(Mutex::new(None)),\n            running: Arc::new(AtomicU32::new(1)),\n            flow_grid: Arc::new(RwLock::new([0.0; 200])),\n            spatial_memory: Arc::new(DashMap::new()), // Initialize the storage\n        }\n    }\n}\n\nimpl std::panic::RefUnwindSafe for SwarmState {}",
      "skeleton": {
        "structs": [
          "FrameBuffer",
          "SwarmState",
          "TripleBufferState"
        ],
        "functions": [
          "new"
        ],
        "complexity": 0
      }
    },
    {
      "path": "native/swarm_native/src/state/mod.rs",
      "content": "// native/swarm_native/src/state/mod.rs\n\npub mod arena;"
    },
    {
      "path": "native/swarm_native/src/nifs/telemetry.rs",
      "content": "// native/swarm_native/src/nifs/telemetry.rs\n\nuse rustler::{Env, ResourceArc, Binary, OwnedBinary};\nuse std::sync::atomic::Ordering;\nuse crate::state::arena::{SwarmState, FRAME_SIZE};\n\n/// Returns the Optical Flow grid (200 floats) as a raw binary.\n/// Elixir Nx can cast this directly to a Tensor:\n/// t = Nx.from_binary(bin, {:f, 32})\n#[rustler::nif]\npub fn get_flow_grid(env: Env, state: ResourceArc<SwarmState>) -> Binary {\n    let grid_lock = state.flow_grid.read().unwrap();\n    \n    // Create an owned binary of the correct size (200 floats * 4 bytes)\n    let mut binary = OwnedBinary::new(200 * 4).unwrap();\n    \n    // Unsafe copy for speed (we know the sizes match perfectly)\n    let src_ptr = grid_lock.as_ptr() as *const u8;\n    let dst_ptr = binary.as_mut_slice().as_mut_ptr();\n    \n    unsafe {\n        std::ptr::copy_nonoverlapping(src_ptr, dst_ptr, 200 * 4);\n    }\n    \n    binary.release(env)\n}\n\n/// Returns the latest camera frame from the Triple Buffer.\n/// Logic: Read 'ready_idx', lock that slot, copy to Binary.\n#[rustler::nif]\npub fn get_latest_frame(env: Env, state: ResourceArc<SwarmState>) -> Binary {\n    let ready_idx = state.memory.ready_idx.load(Ordering::Acquire);\n    let slot = &state.memory.slots[ready_idx];\n    \n    let frame_guard = slot.data.lock().unwrap();\n    \n    // Copy the frame data into an Elixir Binary\n    let mut binary = OwnedBinary::new(FRAME_SIZE).unwrap();\n    binary.as_mut_slice().copy_from_slice(&frame_guard);\n    \n    binary.release(env)\n}\n\n/// Returns the Fused Kinematics (Vx, Vy, Px, Py)\n#[rustler::nif]\npub fn get_fused_state(state: ResourceArc<SwarmState>) -> (f32, f32, f32, f32) {\n    let phys = &state.physiology;\n    (\n        phys.vx.load(),\n        phys.vy.load(),\n        phys.px.load(),\n        phys.py.load()\n    )\n}",
      "skeleton": {
        "structs": [],
        "functions": [
          "get_flow_grid",
          "get_fused_state",
          "get_latest_frame"
        ],
        "complexity": 0
      }
    },
    {
      "path": "native/swarm_native/src/nifs/control.rs",
      "content": "// native/swarm_native/src/nifs/control.rs\n\nuse rustler::ResourceArc;\nuse crate::state::arena::SwarmState;\nuse crate::vision::camera;\nuse rustler::Atom; // Add Atom to imports\n\n/// The Watchdog Probe.\n/// Checks if the FFmpeg child process is still running.\n/// Returns :ok if alive, :error if dead or missing.\n#[rustler::nif]\npub fn check_health(state: ResourceArc<SwarmState>) -> Atom {\n    // Lock the child process mutex\n    let mut lock = state.child_process.lock().unwrap();\n    \n    match *lock {\n        Some(ref mut child) => {\n            // try_wait() is non-blocking. \n            // It returns Ok(Some(status)) if the process has exited.\n            // It returns Ok(None) if the process is still running.\n            match child.try_wait() {\n                Ok(None) => rustler::types::atom::ok(),       // Alive\n                Ok(Some(_)) => rustler::types::atom::error(), // Dead (Exited)\n                Err(_) => rustler::types::atom::error(),      // Error checking\n            }\n        },\n        None => rustler::types::atom::error(), // No camera started\n    }\n}\n\n/// Tactic 1: The Anchor\n/// Allocates the entire memory arena (Triple Buffer + Flow Grid) upfront.\n#[rustler::nif]\npub fn init_state() -> ResourceArc<SwarmState> {\n    ResourceArc::new(SwarmState::new())\n}\n\n/// Tactic 4: The Heartbeat\n/// Spawns the dedicated OS thread for FFmpeg.\n\n#[rustler::nif]\npub fn start_camera(state: ResourceArc<SwarmState>, width: u32, height: u32) -> Atom {    \n    // FIX: Dereference the ResourceArc (*) to get to the SwarmState, \n    // then Clone it to get an owned struct.\n    let state_owned = (*state).clone(); \n    \n    camera::spawn_heartbeat(state_owned, width, height);\n    rustler::types::atom::ok()\n}",
      "skeleton": {
        "structs": [],
        "functions": [
          "check_health",
          "init_state",
          "start_camera"
        ],
        "complexity": 2
      }
    },
    {
      "path": "native/swarm_native/src/nifs/legacy.rs",
      "content": "// native/swarm_native/src/nifs/legacy.rs\n\nuse rustler::ResourceArc;\nuse std::sync::atomic::Ordering;\nuse crate::state::arena::{SwarmState, FRAME_WIDTH, FRAME_HEIGHT};\nuse crate::vision::detector; // Import the Logic\n\n#[rustler::nif]\npub fn update_spatial_state(state: ResourceArc<SwarmState>, x: i32, y: i32, status: u32) -> String {\n    state.spatial_memory.insert((x, y), status);\n    \"ok\".to_string()\n}\n\n#[rustler::nif]\npub fn get_spatial_state(state: ResourceArc<SwarmState>, x: i32, y: i32) -> u32 {\n    match state.spatial_memory.get(&(x, y)) {\n        Some(val) => *val,\n        None => 0,\n    }\n}\n\n/// The \"Wake-on-Motion\" Trigger.\n///\n/// Tactic: Triple Buffer Roulette.\n/// We compare the 'Ready' slot (Current) against the 'Idle' slot (Reference).\n/// This allows us to detect change without allocating a dedicated background buffer.\n#[rustler::nif]\npub fn detect_change(state: ResourceArc<SwarmState>) -> (u32, u32, u32, u32) {\n    let memory = &state.memory;\n\n    // 1. Identify the Slots\n    // We load Acquire to ensure we see the latest updates from the camera thread.\n    let ready_idx = memory.ready_idx.load(Ordering::Acquire);\n    let write_idx = memory.write_idx.load(Ordering::Acquire);\n\n    // Find the \"Cold\" slot. It's the one that is neither Ready nor Writing.\n    // In a 3-slot system, there is always exactly one such slot.\n    let ref_idx = (0..3)\n        .find(|&i| i != ready_idx && i != write_idx)\n        .unwrap_or((ready_idx + 1) % 3); // Fallback (should never happen)\n\n    // 2. Lock and Load\n    // We lock the slots to prevent data tearing, though contention is low.\n    let current_slot = &memory.slots[ready_idx];\n    let ref_slot = &memory.slots[ref_idx];\n\n    // Lock scopes\n    let current_guard = current_slot.data.lock().unwrap();\n    let ref_guard = ref_slot.data.lock().unwrap();\n\n    // 3. Execute the Vision Logic (Stateless)\n    // Step 10 = Scan every 10th pixel (High speed, lower accuracy)\n    let result = detector::calculate_motion_bbox(\n        &current_guard,\n        &ref_guard,\n        FRAME_WIDTH,\n        FRAME_HEIGHT,\n        10 \n    );\n\n    // 4. Return to Elixir\n    match result {\n        Some(roi) => (roi.x, roi.y, roi.w, roi.h),\n        None => (0, 0, 0, 0),\n    }\n}",
      "skeleton": {
        "structs": [],
        "functions": [
          "detect_change",
          "get_spatial_state",
          "update_spatial_state"
        ],
        "complexity": 2
      }
    },
    {
      "path": "native/swarm_native/src/nifs/mod.rs",
      "content": "// native/swarm_native/src/nifs/mod.rs\n\npub mod control;   // init_state, start_camera\npub mod telemetry; // get_fused_state, get_latest_frame\npub mod legacy;    // detect_change, update_spatial_state"
    },
    {
      "path": "native/swarm_native/src/vision/math.rs",
      "content": "// native/swarm_native/src/vision/math.rs\n\n/// THE INSECT EYE (Optical Flow Core)\n/// Tactic 3: Zero-Copy Math.\n/// We treat the RGB buffer as a flat signal and sample the 'Green' channel \n/// (index 1) for the highest luminance signal-to-noise ratio.\n\n#[inline(always)]\npub fn calculate_optical_flow(\n    current: &[u8],\n    prev: &[u8],\n    width: usize,\n    height: usize,\n    grid_out: &mut [f32; 200], // 10x10 grid, 2 floats per point\n) -> (f32, f32) {\n    let mut total_dx = 0;\n    let mut total_dy = 0;\n    let mut points = 0;\n\n    let step_x = width / 10;\n    let step_y = height / 10;\n    \n    // Safety Margin: Search Range (4) + Block Radius (4) + Padding\n    let margin = 20; \n\n    for g_y in 0..10 {\n        for g_x in 0..10 {\n            // Grid point coordinates\n            let x = margin + g_x * step_x;\n            let y = margin + g_y * step_y;\n            \n            // Analyze the 8x8 block at this position\n            let (dx, dy, score) = find_best_block_match(current, prev, x, y, width, 4);\n\n            let idx = (g_y * 10 + g_x) * 2;\n            grid_out[idx] = dx as f32;\n            grid_out[idx + 1] = dy as f32;\n\n            // Strict threshold: SAD score per pixel must be low\n            // 8x8 = 64 pixels. Score < 800 means avg error < 12.5 per pixel\n            if score < 800 { \n                total_dx += dx;\n                total_dy += dy;\n                points += 1;\n            }\n        }\n    }\n\n    if points > 0 {\n        (total_dx as f32 / points as f32, total_dy as f32 / points as f32)\n    } else {\n        (0.0, 0.0)\n    }\n}\n\n/// TRUE Block Matcher (8x8 Kernel)\n/// Now using an inner loop so LLVM can actually vectorize the subtraction.\n#[inline(always)]\nfn find_best_block_match(\n    current: &[u8],\n    prev: &[u8],\n    cx: usize,      // Center X\n    cy: usize,      // Center Y\n    width: usize,\n    range: i32,     // Search range (e.g., +/- 4 pixels)\n) -> (i32, i32, u32) {\n    let mut best_sad = u32::MAX;\n    let mut best_dx = 0;\n    let mut best_dy = 0;\n\n    // 1. Iterate through search candidates (The \"Motion Vector\" candidates)\n    for dy in -range..=range {\n        for dx in -range..=range {\n            \n            let mut sad: u32 = 0;\n\n            // 2. Iterate through the 8x8 Block (The \"Texture Matcher\")\n            // We compare a 8x8 patch centered at (cx, cy) in 'prev'\n            // to a 8x8 patch centered at (cx+dx, cy+dy) in 'current'\n            for by in 0..8 {\n                // Optimization: Pre-calculate row pointers\n                let p_row_y = cy + by - 4;\n                let c_row_y = (cy as i32 + dy + by as i32 - 4) as usize;\n                \n                let p_row_offset = p_row_y * width * 3; // stride * 3 channels\n                let c_row_offset = c_row_y * width * 3;\n\n                for bx in 0..8 {\n                    let p_x = cx + bx - 4;\n                    let c_x = (cx as i32 + dx + bx as i32 - 4) as usize;\n\n                    // Sample GREEN channel (index 1)\n                    let p_idx = p_row_offset + p_x * 3 + 1;\n                    let c_idx = c_row_offset + c_x * 3 + 1;\n\n                    let p_val = prev[p_idx] as i32;\n                    let c_val = current[c_idx] as i32;\n\n                    sad += (p_val - c_val).abs() as u32;\n                }\n            }\n\n            // 3. Update Best Match\n            if sad < best_sad {\n                best_sad = sad;\n                best_dx = dx;\n                best_dy = dy;\n            }\n        }\n    }\n\n    (best_dx, best_dy, best_sad)\n}",
      "skeleton": {
        "structs": [],
        "functions": [
          "calculate_optical_flow",
          "find_best_block_match"
        ],
        "complexity": 9
      }
    },
    {
      "path": "native/swarm_native/src/vision/camera.rs",
      "content": "// native/swarm_native/src/vision/camera.rs\n\nuse std::io::Read;\nuse std::process::{Command, Stdio};\nuse std::sync::atomic::Ordering;\nuse std::thread;\nuse std::time::Instant;\n\nuse crate::state::arena::{SwarmState, FRAME_SIZE, FRAME_WIDTH, FRAME_HEIGHT};\nuse crate::vision::math; \n\n// [CORRECT] Taking state by value (SwarmState), not reference or Arc wrapper\npub fn spawn_heartbeat(state: SwarmState, width: u32, height: u32) {\n    // OPTIMIZATION: Removed the redundant .clone() lines here.\n    // Since we move 'state' into the thread below, we can access \n    // state.memory, state.physiology, etc. directly inside the loop.\n\n    thread::spawn(move || {\n        // 1. Ignite FFmpeg\n        let child = Command::new(\"ffmpeg\")\n            .args(&[\n                \"-f\", \"v4l2\", \"-framerate\", \"30\", \"-video_size\", &format!(\"{}x{}\", width, height),\n                \"-i\", \"/dev/video1\", \n                \"-f\", \"rawvideo\", \"-pix_fmt\", \"rgb24\", \"-\"\n            ])\n            .stdout(Stdio::piped())\n            .stderr(Stdio::null())\n            .spawn()\n            .expect(\"Failed to ignite FFmpeg heartbeat\");\n\n        // 2. Health Monitor: Store the child process handle\n        {\n            // [CORRECT] Accessing the new Arc<Mutex<>> defined in arena.rs\n            let mut process_lock = state.child_process.lock().unwrap();\n            *process_lock = Some(child);\n        }\n\n        // 3. Re-acquire stdout for the hot loop\n        let mut stdout = {\n            let mut lock = state.child_process.lock().unwrap();\n            lock.as_mut().unwrap().stdout.take().unwrap()\n        };\n\n        let mut last_time = Instant::now();\n        let mut current_w_idx = 0;\n        let mut local_grid = [0.0f32; 200];\n\n        // Thread-local previous frame buffer (The Evolutionary Step)\n        let mut prev_frame = vec![0u8; FRAME_SIZE];\n\n        // 4. The Iron Lung Loop\n        // [CLEANUP] Access state directly instead of using the old _ref variables\n        while state.running.load(Ordering::Acquire) == 1 {\n            \n            // Triple Buffer Logic\n            let r_idx = state.memory.ready_idx.load(Ordering::Acquire);\n            let next_w_idx = (current_w_idx + 1) % 3;\n            let final_w_idx = if next_w_idx == r_idx { (next_w_idx + 1) % 3 } else { next_w_idx };\n\n            let slot = &state.memory.slots[final_w_idx];\n\n            {\n                let mut data = slot.data.lock().unwrap();\n                \n                if stdout.read_exact(&mut data).is_err() { break; }\n\n                let (dx, dy) = math::calculate_optical_flow(\n                    &data, \n                    &prev_frame, \n                    FRAME_WIDTH, \n                    FRAME_HEIGHT, \n                    &mut local_grid\n                );\n                \n                let dt = last_time.elapsed().as_secs_f32();\n                last_time = Instant::now();\n                \n                // Direct access to physiology\n                let vx = state.physiology.vx.load() * 0.7 + dx * 0.3;\n                let vy = state.physiology.vy.load() * 0.7 + dy * 0.3;\n                \n                state.physiology.vx.store(vx);\n                state.physiology.vy.store(vy);\n                state.physiology.px.store(state.physiology.px.load() + vx * dt);\n                state.physiology.py.store(state.physiology.py.load() + vy * dt);\n\n                if let Ok(mut g) = state.flow_grid.write() {\n                    g.copy_from_slice(&local_grid);\n                }\n                \n                prev_frame.copy_from_slice(&data);\n            }\n\n            state.memory.ready_idx.store(final_w_idx, Ordering::Release);\n            state.memory.write_idx.store(final_w_idx, Ordering::Release);\n            current_w_idx = final_w_idx;\n        }\n    });\n}",
      "skeleton": {
        "structs": [],
        "functions": [
          "spawn_heartbeat"
        ],
        "complexity": 3
      }
    },
    {
      "path": "native/swarm_native/src/vision/mod.rs",
      "content": "// native/swarm_native/src/vision/mod.rs\n\npub mod camera;   // The FFmpeg Heartbeat\npub mod math;     // The Optical Flow Logic\npub mod detector; // The Motion Watchdog"
    },
    {
      "path": "native/swarm_native/src/vision/detector.rs",
      "content": "// native/swarm_native/src/vision/detector.rs\n\n/// THE WATCHDOG (Motion Detection)\n///\n/// This module implements a \"Sparse Pixel Difference\" algorithm.\n/// Unlike the Optical Flow (which runs at 30Hz on the GPU/SIMD path),\n/// this is a lightweight CPU scan intended for \"Wake-on-Motion\" or \n/// security triggers.\n///\n/// Refactored from the original 'detect_change' in lib.rs.\n\n#[derive(Debug, Clone, Copy)]\npub struct MotionROI {\n    pub x: u32,\n    pub y: u32,\n    pub w: u32,\n    pub h: u32,\n}\n\n/// Scans two frame slices for pixel differences.\n/// \n/// # Arguments\n/// * `current` - The active frame buffer (RGB24).\n/// * `reference` - The background or previous frame to compare against.\n/// * `width` - Frame width (640).\n/// * `height` - Frame height (480).\n/// * `step` - Scan density (e.g., 10 = check every 10th pixel).\n///\n/// # Returns\n/// * `Some(MotionROI)` if changes exceed the threshold.\n/// * `None` if the scene is stable.\npub fn calculate_motion_bbox(\n    current: &[u8], \n    reference: &[u8], \n    width: usize, \n    _height: usize, \n    step: usize\n) -> Option<MotionROI> {\n    \n    // Safety check: Buffer sizes must match\n    if current.len() != reference.len() {\n        return None;\n    }\n\n    let mut diff_count = 0;\n    \n    // Bounding box accumulators (inverted init)\n    let mut min_x = width;\n    let mut max_x = 0;\n    let mut min_y = usize::MAX; // temporary use usize for logic\n    let mut max_y = 0;\n\n    // We step by (step * 3) to jump pixels while respecting RGB stride\n    let stride = step * 3;\n    let limit = current.len();\n\n    // The Scan Loop\n    // We start at 0 (or 1 in original) and jump by 'stride'\n    for i in (0..limit).step_by(stride) {\n        // Fast path: Direct integer comparison\n        let val_c = current[i] as i32;\n        let val_ref = reference[i] as i32;\n\n        // Threshold hardcoded to 30 (approx 12% brightness change)\n        if (val_c - val_ref).abs() > 30 {\n            diff_count += 1;\n\n            let pixel_idx = i / 3;\n            let x = pixel_idx % width;\n            let y = pixel_idx / width;\n\n            if x < min_x { min_x = x; }\n            if x > max_x { max_x = x; }\n            if y < min_y { min_y = y; }\n            if y > max_y { max_y = y; }\n        }\n    }\n\n    // \"Sensitivity\" Threshold: 50 changed points required to trigger\n    if diff_count > 50 {\n        let w = if max_x > min_x { max_x - min_x } else { 0 };\n        let h = if max_y > min_y { max_y - min_y } else { 0 };\n\n        Some(MotionROI {\n            x: min_x as u32,\n            y: min_y as u32,\n            w: w as u32,\n            h: h as u32,\n        })\n    } else {\n        None\n    }\n}",
      "skeleton": {
        "structs": [
          "MotionROI"
        ],
        "functions": [
          "calculate_motion_bbox"
        ],
        "complexity": 10
      }
    },
    {
      "path": "native/swarm_brain_tactician/Cargo.toml",
      "content": "[package]\nname = \"swarm_brain_tactician\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[lib]\ncrate-type = [\"cdylib\"]\n\n[dependencies]\nrustler = \"0.37.0\"\n# We use the 'pure' feature to avoid complex C++ linking issues on NixOS if possible,\n# but 'default' is usually faster if the flake env is correct.\n# The Engine. We enable 'cublas' if you had a GPU, but for now standard CPU.\nllama-cpp-2 = \"0.1.66\"\nanyhow = \"1.0\""
    },
    {
      "path": "native/swarm_brain_tactician/README.md",
      "content": "# NIF for SwarmBrain.Tactician.Native\n\n## To build the NIF module:\n\n- Your NIF will now build along with your project.\n\n## To load the NIF:\n\n```elixir\ndefmodule SwarmBrain.Tactician.Native do\n  use Rustler, otp_app: :swarm_brain, crate: \"swarm_brain_tactician\"\n\n  # When your NIF is loaded, it will override this function.\n  def add(_a, _b), do: :erlang.nif_error(:nif_not_loaded)\nend\n```\n\n## Examples\n\n[This](https://github.com/rusterlium/NifIo) is a complete example of a NIF written in Rust.\n"
    },
    {
      "path": "native/swarm_brain_tactician/src/lib.rs",
      "content": "use rustler::{NifStruct, Env, Term, NifResult};\nuse std::path::Path;\n\n#[rustler::nif(schedule = \"DirtyCpu\")]\nfn load_model(path: String) -> NifResult<String> {\n    if Path::new(&path).exists() {\n        Ok(format!(\"\ud83e\udde0 Tactician Core online. Memory mapped: {}\", path))\n    } else {\n        Ok(format!(\"\u274c Error: Brain file not found at {}\", path))\n    }\n}\n\n#[rustler::nif(schedule = \"DirtyCpu\")]\nfn think(context_text: String) -> String {\n    // SIMULATED REASONING (The \"Tube Amp\" Warm-up)\n    // This proves the pipeline works.\n    \n    if context_text.contains(\"person\") {\n        \"DECISION: TRACK_TARGET. REASON: Unauthorized human detected.\"\n    } else if context_text.contains(\"watch\") {\n        \"DECISION: HOVER. REASON: High-value asset identified.\"\n    } else {\n        \"DECISION: SEARCH. REASON: Sector clear.\"\n    }.to_string()\n}\n\nrustler::init!(\"Elixir.SwarmBrain.Tactician.Native\", [load_model, think]);",
      "skeleton": {
        "structs": [],
        "functions": [
          "(cont",
          "load_model"
        ],
        "complexity": 3
      }
    },
    {
      "path": "Mnesia.brain@192.168.1.147/DECISION_TAB.LOG",
      "content": "\u0001\u0002\u0003\u0004cXM\u000b\u0000\u0000\u0000RbWLAh\u0006w\nlog_headerw\fdecision_tabk\u0000\u00031.0k\u0000\u00064.23.5w\u0013brain@192.168.1.147h\u0003b\u0000\u0000\u0006b\u0000\u0000\n?b\u0000\u0007T\u0000\u0000\u0000ibWLAh\u0002w\ndecision_listl\u0000\u0000\u0000\u0002h\u0004w\u000bmnesia_downw\u0013brain@192.168.1.243h\u0003b\u0000\u0000\u0007a\u0001a\th\u0003a\u0004a\ta3h\u0003w\ttrans_tidw\u0006serialb\u0000\u0000\u0004j"
    },
    {
      "path": "Mnesia.brain@192.168.1.147/schema.DAT",
      "content": "\u0000\u0000%6\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0000\u0000\u0000\t\u0000\u0000\u0002\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0002\u0000\u0000\u0002\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000K|w*\u0014\u0013{^\u007fI\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00058\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\n8\u0000\u0000\u00158\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000#8\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0002$\u0000\u0000\u001d8\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0002$\u00124Vx\u0000\u0000\u0002\u001ch\u0003w\u0006schemaw\tsightingsl\u0000\u0000\u0000\u0012h\u0002w\u0004namew\tsightingsh\u0002w\u0004typew\u0003seth\u0002w\nram_copiesjh\u0002w\u000bdisc_copiesl\u0000\u0000\u0000\u0002w\u0013brain@192.168.1.147w\u0013brain@192.168.1.243jh\u0002w\u0010disc_only_copiesjh\u0002w\nload_ordera\u0000h\u0002w\u000baccess_modew\nread_writeh\u0002w\bmajorityw\u0005falseh\u0002w\u0005indexjh\u0002w\u0004snmpjh\u0002w\nlocal_contentw\u0005falseh\u0002w\u000brecord_namew\tsightingsh\u0002w\nattributesl\u0000\u0000\u0000\u0007w\u0002idw\u0005labelw\u0005scorew\u0003latw\u0003lonw\ttimestampw\u0004nodejh\u0002w\u000fuser_propertiesjh\u0002w\u000ffrag_propertiesjh\u0002w\u0012storage_propertiesjh\u0002w\u0006cookieh\u0002h\u0003n\b\u0000M?\u0018n\b\u0001\u0007a\u0001w\u0013brain@192.168.1.243h\u0002w\u0007versionh\u0002h\u0002a\u0003a\u0000h\u0002w\u0013brain@192.168.1.147h\u0003b\u0000\u0000\u0006b\u0000\u000e\u000fb\u0000\u000bCj\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0003\u0000\u0000\u0001h\u0003w\u0006schemaw\tsightingsl\u0000\u0000\u0000\u0012h\u0002w\u0004namew\tsightingsh\u0002w\u0004typew\u0003seth\u0002w\nram_copiesjh\u0002w\u000bdisc_copiesl\u0000\u0000\u0000\u0001w\u0013brain@192.168.1.243jh\u0002w\u0010disc_only_copiesjh\u0002w\nload_ordera\u0000h\u0002w\u000baccess_modew\nread_writeh\u0002w\bmajorityw\u0005falseh\u0002w\u0005indexjh\u0002w\u0004snmpjh\u0002w\nlocal_contentw\u0005falseh\u0002w\u000brecord_namew\tsightingsh\u0002w\nattributesl\u0000\u0000\u0000\u0007w\u0002idw\u0005labelw\u0005scorew\u0003latw\u0003lonw\ttimestampw\u0004nodejh\u0002w\u000fuser_propertiesjh\u0002w\u000ffrag_propertiesjh\u0002w\u0012storage_propertiesjh\u0002w\u0006cookieh\u0002h\u0003n\b\u0000M?\u0018n\b\u0001\u0007a\u0001w\u0013brain@192.168.1.243h\u0002w\u0007versionh\u0002h\u0002a\u0002a\u0000jj\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u00124Vx\u0000\u0000\u0001h\u0003w\u0006schemaw\u0006schemal\u0000\u0000\u0000\u0012h\u0002w\u0004namew\u0006schemah\u0002w\u0004typew\u0003seth\u0002w\nram_copiesjh\u0002w\u000bdisc_copiesl\u0000\u0000\u0000\u0002w\u0013brain@192.168.1.147w\u0013brain@192.168.1.243jh\u0002w\u0010disc_only_copiesjh\u0002w\nload_ordera\u0000h\u0002w\u000baccess_modew\nread_writeh\u0002w\bmajorityw\u0005falseh\u0002w\u0005indexjh\u0002w\u0004snmpjh\u0002w\nlocal_contentw\u0005falseh\u0002w\u000brecord_namew\u0006schemah\u0002w\nattributesl\u0000\u0000\u0000\u0002w\u0005tablew\u0007cstructjh\u0002w\u000fuser_propertiesjh\u0002w\u000ffrag_propertiesjh\u0002w\u0012storage_propertiesjh\u0002w\u0006cookieh\u0002h\u0003n\b\u0000a\u0018n\b\u0001\u007f\u0007a\u0001w\u0013brain@192.168.1.243h\u0002w\u0007versionh\u0002h\u0002a\u0004a\u0000h\u0002w\u0013brain@192.168.1.147h\u0003b\u0000\u0000\u0006b\u0000\u000e\u000fb\u0000\nj\u0000\u0000\u0000\u0010\u0003\u0000\u0000\u0000\n\u0000\u0000!8\u0000\u0000\u0000\u0010\u0003\u0000\u0000\u0000\f\u0000\u0000%8\u0000\u0000\u0000\u0010\u0003\u0000\u0000\u0000\n\u0000\u0000-8\u0000\u0000\u0000\u0010\u0003\u0000\u0000\u0000\u000e\u0000\u0000=8\u0000\u0000\u0000\u0010\u0003\u0000\u0000\u0000\u000f\u0000\u0000]8\u0000\u0000\u0000\u0010\u0003\u0000\u0000\u0000\u0010\u0000\u00008\u0000\u0000\u0000\u0010\u0003\u0000\u0000\u0000\u0011\u0000\u0001\u001d8\u0000\u0000\u0000\u0010\u0003\u0000\u0000\u0000\u0012\u0000\u0002\u001d8\u0000\u0000\u0000\u0010\u0003\u0000\u0000\u0000\u0013\u0000\u0004\u001d8\u0000\u0000\u0000\u0010\u0003\u0000\u0000\u0000\u0014\u0000\b\u001d8\u0000\u0000\u0000\u0010\u0003\u0000\u0000\u0000\u0015\u0000\u0010\u001d8\u0000\u0000\u0000\u0010\u0003\u0000\u0000\u0000\u0016\u0000 \u001d8\u0000\u0000\u0000\u0010\u0003\u0000\u0000\u0000\u0017\u0000@\u001d8\u0000\u0000\u0000\u0010\u0003\u0000\u0000\u0000\u0018\u0000\u001d8\u0000\u0000\u0000\u0010\u0003\u0000\u0000\u0000\u0019\u0001\u0000\u001d8\u0000\u0000\u0000\u0010\u0003\u0000\u0000\u0000\u001a\u0002\u0000\u001d8\u0000\u0000\u0000\u0010\u0003\u0000\u0000\u0000\u001b\u0004\u0000\u001d8\u0000\u0000\u0000\u0010\u0003\u0000\u0000\u0000\u001c\b\u0000\u001d8\u0000\u0000\u0000\u0010\u0003\u0000\u0000\u0000\u001d\u0010\u0000\u001d8\u0000\u0000\u0000\u0010\u0003\u0000\u0000\u0000\u001e \u0000\u001d8\u0000\u0000\u0000\u0010\u0003\u0000\u0000\u0000\u001f@\u0000\u001d8\u0000\u0000\u0000\f\u0003\u0000\u000009\u0000\u0000&"
    },
    {
      "path": "Mnesia.brain@192.168.1.147/sightings.DCD",
      "content": "\u0001\u0002\u0003\u0004cXM\u000b\u0000\u0000\u0000MbWLAh\u0006w\nlog_headerw\u0007dcd_logk\u0000\u00031.0k\u0000\u00064.23.5w\u0013brain@192.168.1.147h\u0003b\u0000\u0000\u0006b\u0000\u000e\u000fb\u0000\n&"
    },
    {
      "path": "Mnesia.brain@192.168.1.147/LATEST.LOG",
      "content": "\u0001\u0002\u0003\u0004\u0006\u0007\b\t\u0000\u0000\u0000ObWLAh\u0006w\nlog_headerw\ttrans_logk\u0000\u00034.3k\u0000\u00064.23.5w\u0013brain@192.168.1.147h\u0003b\u0000\u0000\u0006b\u0000\u0000\n?b\u0000\f"
    },
    {
      "path": "lib/swarm_brain/blackboard.ex",
      "content": "defmodule SwarmBrain.Blackboard do\n  @moduledoc \"The Distributed Hive Mind.\"\n  use GenServer\n  require Logger\n\n  @sync_interval 50\n\n  defstruct [\n    :crdt,\n    target_class: \"none\",\n    target_position: nil,\n    mission_status: :search,\n    swarm_census: 0\n  ]\n\n  def start_link(_opts), do: GenServer.start_link(__MODULE__, [], name: __MODULE__)\n\n  def init(_) do\n    Logger.info(\"\ud83d\udce1 Blackboard: Initializing Hive Connectivity...\")\n\n    # 1. Start CRDT\n    {:ok, crdt_pid} = DeltaCrdt.start_link(DeltaCrdt.AWLWWMap, sync_interval: @sync_interval)\n\n    # 2. Monitor Nodes\n    :net_kernel.monitor_nodes(true)\n    update_neighbors(crdt_pid)\n\n    # 3. Return PROPER Struct\n    {:ok, %__MODULE__{crdt: crdt_pid}}\n  end\n\n  # --- API ---\n\n  def update_vision(detections, _meta) do\n    GenServer.cast(__MODULE__, {:update_local_vision, detections})\n  end\n\n  # --- CALLBACKS ---\n\n  def handle_cast({:update_local_vision, detections}, state) do\n    # 1. Hive Sync\n    best = List.first(detections) || %{label: \"none\"}\n    DeltaCrdt.put(state.crdt, :vision_summary, %{node: Node.self(), label: best[:label]})\n\n    # 2. Local Reflex\n    send(SwarmBrain.Sensor.Fusion, {:visual_contact, detections})\n\n    {:noreply, state}\n  end\n\n  # Handle Node Join/Leave events from :net_kernel\n  def handle_info({:nodeup, _node}, state) do\n    update_neighbors(state.crdt)\n    {:noreply, state}\n  end\n\n  def handle_info({:nodedown, _node}, state) do\n    update_neighbors(state.crdt)\n    {:noreply, state}\n  end\n\n  # --- PRIVATE ---\n\n  defp update_neighbors(crdt_pid) do\n    # [FIX] DeltaCrdt requires a LIST, not a MapSet.\n    # We explicitly convert Node.list() (which is a list) just to be safe,\n    # but more importantly, we ensure we don't pass a MapSet if we were doing set math.\n    neighbors = Node.list()\n\n    Logger.debug(\"\ud83d\udce1 Blackboard: Syncing with neighbors: #{inspect(neighbors)}\")\n    DeltaCrdt.set_neighbours(crdt_pid, neighbors)\n  end\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Blackboard"
        ],
        "functions": [
          "ate_neighbors(cr/1",
          "ate_vision(de/2",
          "dle_cast({:/2",
          "dle_info({:/2",
          "init/1",
          "start_link/1"
        ],
        "structs": [
          "[\n    :crdt,\n    target_class: \"none\",\n    target_position: nil,\n    mission_status: :search,\n    swarm_census: 0\n  ]"
        ],
        "dependencies": [
          "GenServer",
          "Logger",
          "Server.ca",
          "e.li",
          "e.se",
          "ger.de",
          "rdt.set_n",
          "rmBrain.Sensor.Fusion, {",
          "t.fi",
          "taCrdt.AWLWWMap, s",
          "taCrdt.pu",
          "taCrdt.st"
        ],
        "complexity": 7,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/cortex.ex",
      "content": "defmodule SwarmBrain.Cortex do\n  @moduledoc \"\"\"\n  The High-Level Cognitive Processor.\n  It coordinates specific neural modules (like ResNet) to analyze observations.\n  \"\"\"\n\n  # --- THE CONTRACT ---\n  # This makes Cortex a proper behaviour that other modules can implement.\n  @callback analyze(image_tensor :: Nx.Tensor.t()) :: {:ok, map()} | {:error, term()}\n\n  # --- CLIENT API ---\n\n  def analyze(image_tensor) do\n    # Dynamically find which brain module is active (configured in config.exs)\n    # Defaulting to ResNet if not specified.\n    brain_module = Application.get_env(:swarm_brain, :cortex_module, SwarmBrain.Cortex.ResNet)\n\n    brain_module.analyze(image_tensor)\n  end\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Cortex"
        ],
        "functions": [
          "analyze/1"
        ],
        "structs": [],
        "dependencies": [
          "Application",
          "Nx.Tensor",
          "SwarmBrain.Cortex.ResNet"
        ],
        "complexity": 1,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/formation.ex",
      "content": "\ndefmodule SwarmBrain.Formation do\n  use GenServer\n  require Logger\n\n\n  # Safety: If no signal for 2 seconds, stop moving.\n  @signal_timeout 2000\n\n  defstruct [\n    :current_vector,\n    :formation_offset,\n    :last_seen_ts\n  ]\n\n  def start_link(opts) do\n    GenServer.start_link(__MODULE__, opts, name: __MODULE__)\n  end\n\n  def init(opts) do\n    Phoenix.PubSub.subscribe(SwarmBrain.PubSub, \"radio:telemetry\")\n    initial_offset = Keyword.get(opts, :offset, %{x: 0, y: 0})\n\n    {:ok, %__MODULE__{\n      current_vector: %{heading: 0.0, velocity: 0.0},\n      formation_offset: initial_offset,\n      last_seen_ts: System.monotonic_time(:millisecond)\n    }}\n  end\n\n\n  def handle_info({:udp, _socket, _ip, _port, binary_data}, state) do\n    # FIX: The Codec returns a map directly, not a tuple.\n    # We catch crashes using a try/rescue block if the data is malformed,\n    # or rely on the supervisor to restart us (the \"Class A\" approach).\n\n    vitals = SwarmBrain.Telemetry.Codec.decode_vitals(binary_data)\n\n    # Update state based on the raw map\n    new_state = %{state |\n      heading: vitals.heading,\n      velocity: vitals.velocity\n    }\n\n    # Logic to adjust formation based on new vitals...\n    {:noreply, new_state}\n  end\n\n  def handle_info(:check_safety, state) do\n    now = System.monotonic_time(:millisecond)\n    if (now - state.last_seen_ts) > @signal_timeout do\n      # FIXED: Logger.warn is deprecated\n      Logger.warning(\"\u26a0\ufe0f Leader Lost. Engaging Hover.\")\n      {:noreply, %{state | current_vector: %{heading: state.current_vector.heading, velocity: 0.0}}}\n    else\n      {:noreply, state}\n    end\n  end\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Formation"
        ],
        "functions": [
          "handle_info/2",
          "init/1",
          "start_link/1"
        ],
        "structs": [
          "[\n    :current_vector,\n    :formation_offset,\n    :last_seen_ts\n  ]"
        ],
        "dependencies": [
          "GenServer",
          "Keyword",
          "Logger",
          "Phoenix.PubSub",
          "SwarmBrain.PubSub",
          "SwarmBrain.Telemetry.Codec",
          "System"
        ],
        "complexity": 5,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/vision_serving.ex",
      "content": "# defmodule SwarmBrain.VisionServing do\n#   @moduledoc \"\"\"\n#   The YOLOX-Small Engine.\n#   Handles image normalization and raw tensor inference.\n#   \"\"\"\n#   use GenServer\n#   require Logger\n\n#   def start_link(opts), do: GenServer.start_link(__MODULE__, opts, name: __MODULE__)\n\n#   @impl true\n#   def init(_opts) do\n#     Logger.info(\"\ud83d\udc41\ufe0f VisionServing: Initializing YOLOX-Small...\")\n#     model_path = \"priv/yolox_s.onnx\"\n\n#     if File.exists?(model_path) do\n#       model = Ortex.load(model_path)\n#       Logger.info(\"\ud83d\udc41\ufe0f VisionServing: Sight is Online.\")\n#       {:ok, %{model: model}}\n#     else\n#       Logger.error(\"\u274c VisionServing: Brain file missing at #{model_path}\")\n#       {:stop, :missing_brain}\n#     end\n#   end\n\n#   @impl true\n#   def handle_call({:detect, image_binary}, _from, %{model: model} = state) do\n#     # 1. DECODE: Use .shape instead of .height\n#     {:ok, img} = StbImage.read_binary(image_binary)\n#     {h, w, _c} = img.shape\n\n#     # 2. PRE-PROCESS: Use NxImage (no underscore)\n#     input_tensor =\n#       Nx.from_binary(img.data, img.type)\n#       |> Nx.reshape({h, w, 3})\n#       |> NxImage.resize({640, 640})\n#       |> Nx.transpose(axes: [2, 0, 1])\n#       |> Nx.reshape({1, 3, 640, 640})\n#       |> Nx.as_type(:f32)\n#       |> Nx.divide(255.0)\n\n#     # 3. INFERENCE\n#     {output_tensor} = Ortex.run(model, input_tensor)\n\n#     # Return a clean {:ok, tensor} tuple\n#     {:reply, {:ok, output_tensor}, state}\n#   end\n# end\n"
    },
    {
      "path": "lib/swarm_brain/antenna.ex",
      "content": "defmodule SwarmBrain.Antenna do\n  @moduledoc \"\"\"\n  The Hardware Interface for RF Communication (LoRa/ELRS).\n  Formerly 'Radio'.\n  \"\"\"\n  use GenServer\n  require Logger\n  # alias Circuits.UART # Uncomment when running on real hardware\n\n  @topic \"radio:telemetry\"\n\n  def start_link(opts) do\n    GenServer.start_link(__MODULE__, opts, name: __MODULE__)\n  end\n\n  @impl true\n  def init(_opts) do\n    Logger.info(\"\ud83d\udce1 Antenna Listening on UART...\")\n    # Mocking UART connection for development\n    # In production: UART.open(...)\n    {:ok, %{port: nil, rssi: -60}}\n  end\n\n  @impl true\n  def handle_info({:circuits_uart, _port, data}, state) do\n    # 1. Strip noise\n    clean_data = String.trim(data)\n\n    # 2. Broadcast to the Swarm (Formation, Pipeline, etc.)\n    # We do NOT call Pipeline directly anymore.\n    Phoenix.PubSub.broadcast(SwarmBrain.PubSub, @topic, {:telemetry_packet, clean_data, state.rssi})\n\n    {:noreply, state}\n  end\n\n  # Catch-all for when we are running without real hardware\n  @impl true\n  def handle_info(_msg, state) do\n    {:noreply, state}\n  end\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Antenna"
        ],
        "functions": [
          "dle_info(_m/2",
          "dle_info({:/2",
          "init/1",
          "start_link/1"
        ],
        "structs": [],
        "dependencies": [
          "GenServer",
          "Logger",
          "enix.PubSub.br",
          "ing.tr",
          "rmBrain.PubSub, @"
        ],
        "complexity": 4,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/application.ex",
      "content": "defmodule SwarmBrain.Application do\n  use Application\n  require Logger\n\n  def start(_type, _args) do\n    # 1. Configuration Bias\n    topologies = Application.get_env(:libcluster, :topologies) || []\n    cortex = Application.get_env(:swarm_brain, :cortex_module)\n\n    # --- SYNCHRONOUS BRAIN LOADING ---\n    Code.ensure_loaded(cortex)\n\n    if function_exported?(cortex, :init, 0) do\n      Logger.info(\"\ud83e\udde0 Pre-loading Cortex: #{inspect(cortex)}\")\n      cortex.init()\n    else\n      Logger.warning(\"\u26a0\ufe0f Cortex #{inspect(cortex)} has no init/0 callback.\")\n    end\n\n    # ---------------------------------------\n\n    children = [\n      # 1. Cluster Manager\n      {Cluster.Supervisor, [topologies, [name: SwarmBrain.ClusterSupervisor]]},\n\n      # 2. Nervous System\n      {Phoenix.PubSub, name: SwarmBrain.PubSub},\n\n      # 3. The Spinal Cord\n      {SwarmBrain.Hardware.Spine, []},\n\n      # 4. Model Switching Logic\n      {SwarmBrain.Switchboard, cortex},\n\n      # 5. Shared Consciousness\n      {SwarmBrain.Blackboard, []},\n\n      # [RESTORED] The Inner Ear (Supervised Process)\n      {SwarmBrain.Sensor.Fusion, []},\n\n      # 6. Supervision for Async Tasks\n      {Task.Supervisor, name: SwarmBrain.Cortex.Supervisor},\n\n      # 7. The Iron Lung (Vision System)\n      {SwarmBrain.Vision.Server, []},\n\n      # 8. The Pilot (RL Agent)\n      {SwarmBrain.Tracker, []}\n    ]\n\n    opts = [strategy: :one_for_one, name: SwarmBrain.Supervisor]\n\n    with {:ok, pid} <- Supervisor.start_link(children, opts) do\n      # 3. JIT WARMING (Async)\n      warm_up_jit(cortex)\n      {:ok, pid}\n    end\n  end\n\n  defp warm_up_jit(cortex) do\n    Logger.info(\"\ud83d\udd25 Ignition Sequence: Warming up Neural Pathways...\")\n\n    Task.start(fn ->\n      # 1. Warm Up Vision (YOLO)\n      Logger.debug(\"... Warming Eyes (Yolo)\")\n      dummy_image = Nx.broadcast(0, {480, 640, 3}) |> Nx.as_type({:u, 8})\n\n      try do\n        cortex.analyze(dummy_image)\n      rescue\n        e -> Logger.warning(\"Vision Warm-up skipped: #{inspect(e)}\")\n      end\n\n      # 2. Warm Up Pilot (RL Network)\n      Logger.debug(\"... Warming Pilot (RL Network)\")\n\n      # Dummy input matching the Tracker's shape {1, 207}\n      dummy_state = Nx.broadcast(0.0, {1, 207}) |> Nx.as_type(:f32)\n\n      try do\n        SwarmBrain.Actor.Network.predict(\n          SwarmBrain.Actor.Network.init_random_params(),\n          dummy_state\n        )\n      rescue\n        e -> Logger.warning(\"Pilot Warm-up skipped: #{inspect(e)}\")\n      end\n\n      Logger.info(\"\u2705 System Ready.\")\n    end)\n  end\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Application"
        ],
        "functions": [
          "_jit(cortex/1",
          "start/2"
        ],
        "structs": [],
        "dependencies": [
          "(:",
          "(fn",
          "({",
          ".Actor.Network.init_rand",
          ".Actor.Network.predict(",
          ".PubSub, name:",
          ".Supervisor, [topo",
          "Application",
          "Code",
          "Logger",
          "ain.Blackboard, []},",
          "ain.ClusterSupervisor]]},",
          "ain.Cortex.Supervisor},",
          "ain.Hardware.Spine, []},",
          "ain.PubSub},",
          "ain.Sensor.Fusion, []},",
          "ain.Supervisor]",
          "ain.Switchboard, corte",
          "ain.Tracker, []}",
          "ain.Vision.Server, []},",
          "ger.wa",
          "info(\"",
          "ning(\"",
          "o(\"\u2705 S",
          "pervisor, name:",
          "sor.start_",
          "st",
          "ug(\".."
        ],
        "complexity": 4,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/pipeline.ex",
      "content": "defmodule SwarmBrain.Pipeline do\n  use GenServer\n  require Logger\n  alias SwarmBrain.Observation\n\n  # Threshold: If signal is worse than -85dBm, stop sending JPEGs.\n  @rssi_emergency_threshold -85\n\n  def start_link(_opts) do\n    # FIXED: Initialize with a default RSSI of -60 (Good Signal)\n    GenServer.start_link(__MODULE__, %{rssi: -60}, name: __MODULE__)\n  end\n\n  def init(state) do\n    Phoenix.PubSub.subscribe(SwarmBrain.PubSub, \"radio:telemetry\")\n    {:ok, state}\n  end\n\n  # Receive Data + Signal Strength\n  def handle_info({:telemetry_packet, _data, rssi}, state) do\n    # Update local state with signal quality\n    {:noreply, Map.put(state, :rssi, rssi)}\n  end\n\n  @doc \"\"\"\n  Main Entry Point: The Eye sees something.\n  \"\"\"\n  def process_visual_data(image_binary) do\n    GenServer.cast(__MODULE__, {:process_image, image_binary})\n  end\n\n  def handle_cast({:process_image, image}, state) do\n    # 1. Decide WHERE to process (Horde / Global Grid)\n    processor_pid = find_best_cortex()\n\n    # Capture RSSI safely before spawning task\n    current_rssi = Map.get(state, :rssi, -60)\n\n    # 2. Decide WHAT to send back (Dynamic Compression)\n    # If we are the processor, we do the work.\n    Task.start(fn ->\n      # Let it crash. Isolate the heavy math.\n      result = GenServer.call(processor_pid, {:analyze, image}, 15_000)\n      handle_analysis_result(result, current_rssi)\n    end)\n\n    {:noreply, state}\n  end\n\n  # --- The \"Horde\" Global Grid Lookup ---\n  defp find_best_cortex do\n    # Ask Horde Registry for a process named \"GlobalCortex\"\n    # If it exists (e.g., on the Mother Ship), use it.\n    # If not, fall back to our local Cortex.\n    case Horde.Registry.lookup(SwarmBrain.HordeRegistry, \"GlobalCortex\") do\n      [{pid, _} | _] -> pid\n      [] -> SwarmBrain.Cortex # Local Atom\n    end\n  end\n\n  # --- Dynamic Compression Logic ---\ndefp handle_analysis_result(observation, rssi) do\n\n  # 1. Broadcast to the Nervous System (Tracker, UI, etc.)\n    Phoenix.PubSub.broadcast(\n      SwarmBrain.PubSub,\n      \"vision:analysis\",\n      {:visual_contact, observation}\n    )\n\n    payload =\n      if rssi < @rssi_emergency_threshold do\n        # Emergency Mode: Prune everything except Class ID and Coordinates\n        Observation.prune_payload(observation, :emergency)\n      else\n        # Full Mode: Include Metadata, Confidence scores, etc.\n        Observation.prune_payload(observation, :full)\n      end\n\n    # Send to persistence / ground station\n    SwarmBrain.Persistence.log(payload)\n  end\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Pipeline"
        ],
        "functions": [
          "find_best_cortex/0",
          "handle_analysis_result/2",
          "handle_cast/2",
          "handle_info/2",
          "init/1",
          "process_visual_data/1",
          "start_link/1"
        ],
        "structs": [],
        "dependencies": [
          "GenServer",
          "Horde.Registry",
          "Logger",
          "Map",
          "Observation",
          "Phoenix.PubSub",
          "SwarmBrain.Cortex",
          "SwarmBrain.HordeRegistry",
          "SwarmBrain.Observation",
          "SwarmBrain.Persistence",
          "SwarmBrain.PubSub",
          "Task"
        ],
        "complexity": 9,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/codec.ex",
      "content": "defmodule SwarmBrain.Telemetry.Codec do\n  @moduledoc \"\"\"\n  Pure functional core for bit-level swarm communications.\n  Optimized for minimal bandwidth using Erlang binary pattern matching.\n  \"\"\"\n\n  @doc \"Packs vitals into 3 bytes: 10b Heading, 8b Velocity, 6b Battery\"\n  def encode_vitals(%{heading: h, velocity: v, battery: b}) do\n    # Clamp values to prevent bit-overflow crashes\n    h_int = h |> round() |> rem(360)\n    v_int = min(v, 255)\n    b_int = min(b, 100)\n\n    <<h_int::size(10), v_int::size(8), b_int::size(6)>>\n  end\n\n  @doc \"Decodes the 24-bit vital packet.\"\n  def decode_vitals(<<heading::size(10), velocity::size(8), battery::size(6)>>) do\n    %{\n      heading: heading,\n      velocity: velocity,\n      battery: battery\n    }\n  end\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Telemetry.Codec"
        ],
        "functions": [
          "decode_vitals/1",
          "encode_vitals/1"
        ],
        "structs": [],
        "dependencies": [],
        "complexity": 2,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/location.ex",
      "content": "defmodule SwarmBrain.Location do\n  alias SwarmBrain.Observation\n\n  def stamp(%Observation{} = obs) do\n    # In the future: call mavlink or gpsd here\n    {lat, lon, alt} = get_current_gps()\n\n    %{obs | lat: lat, lon: lon, alt: alt}\n  end\n\n  defp get_current_gps do\n    # Placeholder: Lviv High Castle\n    {49.8481, 24.0397, 350.0}\n  end\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Location"
        ],
        "functions": [
          "get_current_gps/0",
          "stamp/1"
        ],
        "structs": [],
        "dependencies": [
          "Observation",
          "SwarmBrain.Observation"
        ],
        "complexity": 2,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/radio.ex",
      "content": "defmodule SwarmBrain.Radio do\n  use GenServer\n  require Logger\n  alias Circuits.UART\n\n  # The Void listens on this topic\n  @topic \"radio:telemetry\"\n\n  def start_link(opts) do\n    GenServer.start_link(__MODULE__, opts, name: __MODULE__)\n  end\n\n  def init(_opts) do\n    {:ok, uart_pid} = UART.start_link()\n\n    # Initialize UART (Assuming connection to EMAX/ELRS module)\n    # Active: true means messages are sent as Erlang messages, not polling.\n    UART.open(uart_pid, \"/dev/ttyAMA0\", speed: 420_000, active: true)\n\n    # Configure generic UART framing (Packet mode) if applicable\n    # UART.configure(uart_pid, framing: {UART.Framing.Line, separator: \"\\n\"})\n\n    {:ok, %{uart: uart_pid, rssi: -60}}\n  end\n\n  # --- The \"Async-Ack\" Implementation ---\n\n  # Standard Data Packet\n  def handle_info({:circuits_uart, _port, data}, state) do\n    # 1. Parse RSSI from hardware (Implementation depends on specific ELRS/Hardware module)\n    # For simulation, we pretend the hardware injects RSSI at end of frame\n    {clean_data, current_rssi} = extract_rssi(data)\n\n    # 2. BROADCAST IMMEDIATELY. Do not call Pipeline. Do not block.\n    # The system is now event-driven.\n    Phoenix.PubSub.broadcast(SwarmBrain.PubSub, @topic, {:telemetry_packet, clean_data, current_rssi})\n\n    {:noreply, %{state | rssi: current_rssi}}\n  end\n\n  def handle_info({:uart_error, _port, reason}, state) do\n    Logger.error(\"Radio interference detected: #{inspect(reason)}\")\n    {:noreply, state}\n  end\n\n  # --- Helpers ---\n\n  # Mockup of RSSI extraction. In real ELRS CRSF protocol, this is in the LinkStatistics frame.\n  defp extract_rssi(data) do\n    # If using Crossfire protocol, we would parse the LinkStats frame here.\n    # Returning dummy data for the skeleton.\n    {data, -50}\n  end\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Radio"
        ],
        "functions": [
          "extract_rssi/1",
          "handle_info/2",
          "init/1",
          "start_link/1"
        ],
        "structs": [],
        "dependencies": [
          "Circuits.UART",
          "GenServer",
          "Logger",
          "Phoenix.PubSub",
          "SwarmBrain.PubSub",
          "UART"
        ],
        "complexity": 5,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/eye.ex",
      "content": "defmodule SwarmBrain.Eye do\n  @moduledoc \"\"\"\n  The Input Stage.\n  Responsible for hardware interaction and signal conditioning.\n  \"\"\"\n  require Logger\n  alias SwarmBrain.Observation\n\n  # 1. THE REVOLUTIONARY PIPELINE STEP\n  # This function fits perfectly into a |> pipe.\n  def capture(_opts \\\\ []) do\n    # Emit a 'signal start' pulse for the dashboard\n    :telemetry.execute([:swarm, :eye, :capture], %{count: 1})\n\n    image_data = get_hardware_image()\n\n    # Return the pure signal\n    Observation.new(image_data)\n  end\n\n  # --- HARDWARE ABSTRACTION ---\n\n  defp get_hardware_image do\n    # In a real scenario, this detects if we are Linux/Mac/RPi\n    # For now, we use the robust \"Task\" approach to prevent hanging.\n    task = Task.async(fn ->\n      # Simulating hardware latency\n      Process.sleep(100)\n      perform_shutter()\n    end)\n\n    case Task.yield(task, 2000) do\n      {:ok, binary} -> binary\n      nil ->\n        Task.shutdown(task, :brutal_kill)\n        Logger.error(\"\u26a0\ufe0f Camera Hardware Timeout! Returning static.\")\n        read_test_pattern()\n    end\n  end\n\n  defp perform_shutter do\n    cond do\n      File.exists?(\"eye.jpg\") -> File.read!(\"eye.jpg\")\n      true ->\n        # Fallback to a 1x1 pixel black dot if nothing exists\n        <<0::size(8)>>\n    end\n  end\n\n  defp read_test_pattern, do: \"PLACEHOLDER_BINARY\"\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Eye"
        ],
        "functions": [
          "_test_pattern, do/0",
          "capture/1",
          "get_hardware_image/0",
          "orm_shutter do\n/0"
        ],
        "structs": [],
        "dependencies": [
          ".exi",
          ".rea",
          "Logger",
          "Observation",
          "Process",
          "SwarmBrain.Observation",
          "Task"
        ],
        "complexity": 6,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/watchman.ex",
      "content": "defmodule SwarmBrain.Watchman do\n  use GenServer\n  require Logger\n\n  @log_file \"brain_observations.csv\"\n\n  # --- Client API ---\n\n  def start_link(_) do\n    GenServer.start_link(__MODULE__, %{}, name: __MODULE__)\n  end\n\n  # --- Server Callbacks ---\n\n  @impl true\n  def init(_) do\n    # 1. Cluster Monitoring\n    :net_kernel.monitor_nodes(true)\n\n    # 2. Subscribe to Mnesia (Legacy/Redundant backup)\n    :mnesia.subscribe({:table, :sightings, :detailed})\n\n    # 3. Setup CSV\n    if !File.exists?(@log_file), do: File.write!(@log_file, \"timestamp,event,details\\n\")\n\n    # REMOVED: schedule_vision_check() - We are now Passive listeners!\n\n    Logger.info(\"\ud83d\udd75\ufe0f Watchman is active. Waiting for Pipeline signals.\")\n    {:ok, %{nodes: Node.list()}}\n  end\n\n  # --- Handling the Swarm Events (Node Up/Down) ---\n\n  @impl true\n  def handle_info({:nodeup, node}, state) do\n    log_event(\"CONNECTION\", \"Swarm became one with node: #{node}\")\n    IO.puts(\"\u2728 [SWARM] Node connected: #{node}. Symmetrical state syncing...\")\n    {:noreply, %{state | nodes: [node | state.nodes]}}\n  end\n\n  @impl true\n  def handle_info({:nodedown, node}, state) do\n    log_event(\"DISCONNECT\", \"Lost connection to node: #{node}\")\n    IO.puts(\"\ud83d\udea8 [SWARM] Node lost: #{node}. Entering autonomous mode.\")\n    {:noreply, %{state | nodes: List.delete(state.nodes, node)}}\n  end\n\n  # --- NEW: Handling the Pipeline Signal ---\n  # This receives the struct from SwarmBrain.Pipeline\n  @impl true\n  def handle_info({:observation_stored, obs}, state) do\n    # 1. Unpack the signal\n    %{predictions: preds, lat: lat, lon: lon, source_node: node} = obs\n\n    # 2. Format the output\n    top_label = case preds do\n      [top | _] -> \"#{top.label} (#{Float.round(top.score * 100, 1)}%)\"\n      [] -> \"Unknown Object\"\n    end\n\n    details = \"Detected #{top_label} at [#{lat}, #{lon}] by #{node}\"\n\n    # 3. Log to CSV and Screen\n    log_event(\"SIGHTING\", details)\n    IO.puts(\"\ud83d\udd14 [WATCHMAN] #{details}\")\n\n    {:noreply, state}\n  end\n\n  # Fallback for other Mnesia events\n  @impl true\n  def handle_info({:mnesia_table_event, _}, state), do: {:noreply, state}\n\n  # Catch-all\n  @impl true\n  def handle_info(_msg, state), do: {:noreply, state}\n\n  # --- Private Helpers ---\n\n  defp log_event(event_type, details) do\n    timestamp = DateTime.utc_now() |> DateTime.to_iso8601()\n    clean_details = String.replace(details, \"\\\"\", \"'\")\n    entry = \"#{timestamp},#{event_type},\\\"#{clean_details}\\\"\\n\"\n    File.write!(@log_file, entry, [:append])\n  end\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Watchman"
        ],
        "functions": [
          ":mnesia_tab/2",
          "e_info({:no/2",
          "info({:node/2",
          "init/1",
          "msg, state)/2",
          "nt_type, /2",
          "o({:observa/2",
          "start_link/1"
        ],
        "structs": [],
        "dependencies": [
          "(\"",
          "File",
          "GenServer",
          "Logger",
          "[",
          "d(top",
          "e(deta",
          "e(st",
          "list",
          "log_",
          "now() |>",
          "so8601()",
          "ts"
        ],
        "complexity": 10,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/tactician.ex",
      "content": "defmodule SwarmBrain.Tactician do\n  use GenServer\n  require Logger\n\n  # This module is the high-level manager for the AI Tactician (Llama.cpp).\n  # It wraps the Rust NIFs and holds the model state.\n\n  # --- CLIENT API ---\n\n  def start_link(opts) do\n    GenServer.start_link(__MODULE__, opts, name: __MODULE__)\n  end\n\n  def think(prompt) do\n    GenServer.call(__MODULE__, {:think, prompt}, 60_000) # 60s timeout for thinking\n  end\n\n  # --- SERVER CALLBACKS ---\n\n  @impl true\n  def init(_opts) do\n    # 1. Define the model path\n    model_path = Application.app_dir(:swarm_brain, \"priv/tactician.gguf\")\n\n    # 2. Check if model exists before crashing\n    if not File.exists?(model_path) do\n      Logger.error(\"\u274c Model not found at: #{model_path}\")\n      {:stop, :model_missing}\n    else\n      # 3. Load the Model (via Rust NIF)\n      # We assume the NIF loading happens here or is managed by the Native module.\n      # If your NIF load function is `SwarmBrain.Tactician.Native.load_model/3`:\n      # SwarmBrain.Tactician.Native.load_model(model_path, 2048, -1)\n\n      # 4. THE FIX IS HERE:\n      # We log the success instead of returning the string as the function result.\n      Logger.info(\"\ud83e\udde0 Tactician Core online. Memory mapped: #{model_path}\")\n\n      # 5. The State\n      # We return the tuple {:ok, state}. The state is just a map for now.\n      {:ok, %{model_path: model_path, context_size: 2048}}\n    end\n  end\n\n  @impl true\n  def handle_call({:think, prompt}, _from, state) do\n    # This forwards the prompt to the Rust NIF\n    # response = SwarmBrain.Tactician.Native.think(prompt)\n\n    # Placeholder response until NIF is fully connected in your logic:\n    response = \"Tactician hears you: #{prompt}\"\n\n    {:reply, response, state}\n  end\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Tactician"
        ],
        "functions": [
          "e_call({:th/3",
          "init/1",
          "start_link/1",
          "think/1"
        ],
        "structs": [],
        "dependencies": [
          "Application",
          "File",
          "GenServer",
          "Logger",
          "gger.i"
        ],
        "complexity": 5,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/discovery.ex",
      "content": "defmodule SwarmBrain.Discovery do\n  @moduledoc \"\"\"\n  The Civilian Link.\n  Manages WiFi/Erlang Distribution connections.\n  If this fails, the Pipeline automatically falls back to Radio.\n  \"\"\"\n  use GenServer\n  require Logger\n  alias SwarmBrain.Persistence\n\n  @interval 5_000\n\n  def start_link(opts) do\n    GenServer.start_link(__MODULE__, opts, name: __MODULE__)\n  end\n\n  @impl true\n  def init(_opts) do\n    send(self(), :connect)\n    {:ok, %{nodes: list_target_nodes()}}\n  end\n\n  @impl true\n  def handle_info(:connect, state) do\n    Enum.each(state.nodes, fn node_name ->\n      if node_name != Node.self() do\n        Node.connect(node_name)\n      end\n    end)\n\n    # Check who is actually alive for logging\n    connected = Node.list()\n    if connected != [] do\n      Logger.debug(\"\ud83c\udf10 WiFi Mesh Active: #{inspect(connected)}\")\n      # Sync databases if we have a connection\n      Enum.each(connected, &Persistence.add_node_to_cluster/1)\n    end\n\n    Process.send_after(self(), :connect, @interval)\n    {:noreply, state}\n  end\n\n  defp list_target_nodes do\n    # Symmetrical List of known IP addresses\n    [:\"brain@192.168.1.147\", :\"brain@192.168.1.243\"]\n  end\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Discovery"
        ],
        "functions": [
          "handle_info/2",
          "init/1",
          "start_link/1",
          "t_target_nodes do/0"
        ],
        "structs": [],
        "dependencies": [
          "Enum",
          "GenServer",
          "Logger",
          "Node",
          "SwarmBrain.Persistence",
          "cess.se",
          "m.ea",
          "sistence.ad"
        ],
        "complexity": 6,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/observation.ex",
      "content": "defmodule SwarmBrain.Observation do\n  @moduledoc \"\"\"\n  The Atomic Unit of Swarm Vision.\n  Carries everything: The Image, The GPS, and The AI Analysis.\n  \"\"\"\n\n  # Added :lat, :lon, :alt, :predictions to satisfy Location and ResNet\n  defstruct [\n    :id,\n    :class,\n    :confidence,\n    :bbox,\n    :timestamp,\n    :image_binary,\n    :lat, :lon, :alt,  # GPS Data\n    :predictions       # Full raw output from AI\n  ]\n\n  @doc \"\"\"\n  Factory method to create a new blank observation from an image.\n  \"\"\"\n  def new(image_binary) do\n    %__MODULE__{\n      id: UUID.uuid4(), # Requires elixr_uuid or just use system unique\n      timestamp: DateTime.utc_now(),\n      image_binary: image_binary\n    }\n  end\n\n  # --- Payload Compression ---\n\n  def prune_payload(obs, :emergency) do\n    %{c: obs.class, b: obs.bbox, l: {obs.lat, obs.lon}}\n  end\n\n  def prune_payload(obs, :full) do\n    # Strip heavy image binary before sending over network\n    %{obs | image_binary: nil}\n  end\n\n  def prune_payload(obs), do: prune_payload(obs, :full)\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Observation"
        ],
        "functions": [
          "new/1",
          "prune_payload/1",
          "prune_payload/2"
        ],
        "structs": [
          "[\n    :id,\n    :class,\n    :confidence,\n    :bbox,\n    :timestamp,\n    :image_binary,\n    :lat, :lon, :alt,  # GPS Data\n    :predictions       # Full raw output from AI\n  ]"
        ],
        "dependencies": [
          "DateTime",
          "UUID"
        ],
        "complexity": 4,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/persistence.ex",
      "content": "defmodule SwarmBrain.Persistence do\n  @moduledoc \"\"\"\n  The Black Box Recorder.\n  Saves telemetry and detections to disk or upstream.\n  \"\"\"\n  use GenServer\n  require Logger\n\n  def start_link(opts) do\n    GenServer.start_link(__MODULE__, opts, name: __MODULE__)\n  end\n\n  def log(data) do\n    # Cast asynchronously so we don't block the Pipeline\n    GenServer.cast(__MODULE__, {:log, data})\n  end\n\n  @impl true\n  def init(_opts) do\n    {:ok, %{}}\n  end\n\n  # NEW: Handle Cluster Nodes\n  def add_node_to_cluster(node_name) do\n    Logger.info(\"\ud83d\udd17 [PERSISTENCE] Registering new node: #{inspect(node_name)}\")\n    # In the future, this updates the CRDT or local database\n    :ok\n  end\n\n  @impl true\n  def handle_cast({:log, data}, state) do\n    # For now, just print to console.\n    # Later: Write to SQLite or DETS.\n    Logger.debug(\"\ud83d\udcbe [PERSISTENCE] Saved: #{inspect(data)}\")\n    {:noreply, state}\n  end\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Persistence"
        ],
        "functions": [
          "add_node_to_cluster/1",
          "dle_cast({:/2",
          "init/1",
          "log/1",
          "start_link/1"
        ],
        "structs": [],
        "dependencies": [
          "GenServer",
          "Logger",
          "ger.de"
        ],
        "complexity": 5,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/tracker.ex",
      "content": "defmodule SwarmBrain.Tracker do\n  use GenServer\n  require Logger\n  alias SwarmBrain.{Actor.Network, Sensor.Fusion, Sensor.Proprioception, Vision.Server}\n\n  @interval 33\n\n  def start_link(_opts), do: GenServer.start_link(__MODULE__, [], name: __MODULE__)\n\n  def init(_) do\n    Logger.info(\"\ud83e\udde0 Tracker: RL Pilot Engaging...\")\n    # Use the new Axon struct if possible, or suppress warning if just a map\n    params = Network.init_random_params()\n    schedule_loop()\n    {:ok, %{policy: params, tick: 0}}\n  end\n\n  def handle_info(:control_loop, state) do\n    if Server.get_resource() do\n\n      # --- A. PROPRIOCEPTION (The Fix) ---\n      # Rust returns a Tuple: {vx, vy, px, py}\n      # We MUST unpack it and wrap it in a List [] for Nx.tensor\n      {vx, vy, px, py} = Proprioception.get_kinematics()\n      physics_state = Nx.tensor([vx, vy, px, py], type: :f32)\n\n      # --- B. FUSION ---\n      _target = Fusion.get_visual_target()\n\n      # --- C. FLOW (Optical Flow Grid) ---\n      # This IS a binary from Rust, so Nx.from_binary is correct here.\n      flow_raw = Proprioception.get_optical_flow()\n\n      flow_grid = case flow_raw do\n        %Nx.Tensor{} -> flow_raw\n        bin when is_binary(bin) -> Nx.from_binary(bin, :f32)\n        _ -> Nx.broadcast(0.0, {200}) # Fallback safety\n      end\n\n      # --- D. INTENT ---\n      intent = Nx.tensor([1.0, 0.0, 0.0], type: :f32)\n\n      # --- INFERENCE ---\n      # Concatenate: Physics (4) + Flow (200) + Intent (3) = 207 Inputs\n      # We flatten flow_grid just in case shape is weird\n      input = Nx.concatenate([\n        physics_state,\n        Nx.flatten(flow_grid),\n        intent\n      ])\n      |> Nx.new_axis(0) # Batch size of 1\n\n      _action = Network.predict(state.policy, input)\n\n      # Logger.debug(\"\ud83e\udde0 Tracker: Tick #{state.tick} | Px: #{px}\")\n\n      schedule_loop()\n      {:noreply, %{state | tick: state.tick + 1}}\n    else\n      # Iron Lung not ready yet\n      schedule_loop()\n      {:noreply, state}\n    end\n  end\n\n  defp schedule_loop, do: Process.send_after(self(), :control_loop, @interval)\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Tracker"
        ],
        "functions": [
          "dle_info(:c/2",
          "init/1",
          "le_loop, do: /0",
          "start_link/1"
        ],
        "structs": [],
        "dependencies": [
          "Actor.Network",
          "GenServer",
          "Logger",
          "Sensor.Fusion",
          "Sensor.Proprioception",
          "SwarmBrain",
          "Tensor{}",
          "Vision.Server",
          "br",
          "co",
          "fl",
          "fr",
          "ion.ge",
          "ne",
          "prioception.ge",
          "s.send_",
          "te",
          "ver.ge",
          "work.in",
          "work.pr"
        ],
        "complexity": 6,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/telemetry/dispatcher.ex",
      "content": "defmodule SwarmBrain.Telemetry.Dispatcher do\n  @moduledoc \"Parallel decoding with Circuit Breaker and Sequence ordering.\"\n  require Logger\n\n  # Circuit Breaker Limit: 5000 pending messages\n  @max_queue_len 5000\n\n  def dispatch_batch(packet_list) do\n    # 1. Circuit Breaker (Strategic Mitigation)\n    if message_queue_len() > @max_queue_len do\n      Logger.warning(\"Circuit Breaker Tripped: Shedding load.\")\n      :ignore\n    else\n      process_batch(packet_list)\n    end\n  end\n\n  defp process_batch(packet_list) do\n    packet_list\n    |> Task.async_stream(fn packet ->\n      # 2. Lamport Timestamp Check (Low-Level Mitigation)\n      # Assuming first 32 bits are the sequence number\n      # NOTE: Ensure your packet format actually starts with 32-bit seq,\n      # otherwise this pattern match will crash.\n      case packet do\n        <<seq::32, _rest::binary>> ->\n          # Only process if valid (Guard handles the check)\n          case SwarmBrain.Telemetry.Guard.validate(packet, seq) do\n            {:ok, vitals} ->\n              Phoenix.PubSub.broadcast(SwarmBrain.PubSub, \"swarm:vitals\", {:update, vitals})\n            {:error, :stale} ->\n              :ignore # Drop out-of-order packet\n            {:error, _} ->\n              :ignore\n          end\n        _ ->\n          # Handle packets too short to contain a seq number\n          :ignore\n      end\n    end, max_concurrency: System.schedulers_online(), ordered: false)\n    |> Stream.run()\n  end\n\n  defp message_queue_len, do: Process.info(self(), :message_queue_len) |> elem(1)\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Telemetry.Dispatcher"
        ],
        "functions": [
          "dispatch_batch/1",
          "message_queue_len/0",
          "process_batch/1"
        ],
        "structs": [],
        "dependencies": [
          "Logger",
          "Phoenix.PubSub",
          "Process",
          "Stream",
          "SwarmBrain.PubSub",
          "SwarmBrain.Telemetry.Guard",
          "System",
          "Task"
        ],
        "complexity": 6,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/telemetry/guard.ex",
      "content": "defmodule SwarmBrain.Telemetry.Guard do\n  require Logger\n\n  @doc \"Validates packet structure and sequence order.\"\n  def validate(packet, seq) do\n    # 1. Structural Check\n    if byte_size(packet) >= 7 do\n\n      # 2. Sequence Check Simulation\n      # We introduce a synthetic condition so the compiler sees :stale as possible.\n      # In production, this would be: if seq < last_seen_seq, do: ...\n      if rem(seq, 9999) == 0 do\n        # Simulate a dropped packet for testing resilience\n        SwarmBrain.Telemetry.Monitor.log_packet(:error)\n        {:error, :stale}\n      else\n        validate_payload(packet, seq)\n      end\n\n    else\n      SwarmBrain.Telemetry.Monitor.log_packet(:error)\n      {:error, :packet_too_short}\n    end\n  end\n\n  defp validate_payload(packet, seq) do\n    # Skip the 4-byte sequence number\n    <<_seq::32, payload::binary>> = packet\n\n    # Use the Codec to parse the rest\n    case SwarmBrain.Telemetry.Codec.decode_vitals(payload) do\n      vitals when is_map(vitals) ->\n        SwarmBrain.Telemetry.Monitor.log_packet(:ok)\n        {:ok, Map.put(vitals, :seq, seq)}\n      _ ->\n        SwarmBrain.Telemetry.Monitor.log_packet(:error)\n        {:error, :malformed_payload}\n    end\n  end\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Telemetry.Guard"
        ],
        "functions": [
          "validate/2",
          "validate_payload/2"
        ],
        "structs": [],
        "dependencies": [
          "Logger",
          "Map",
          "SwarmBrain.Telemetry.Codec",
          "SwarmBrain.Telemetry.Monitor"
        ],
        "complexity": 5,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/telemetry/monitor.ex",
      "content": "defmodule SwarmBrain.Telemetry.Monitor do\n  use GenServer\n  require Logger\n\n  # Indices for atomic array\n  @clean_idx 1\n  @clipped_idx 2\n\n  def start_link(_), do: GenServer.start_link(__MODULE__, %{}, name: __MODULE__)\n\n  def init(_) do\n    # 1. Atomic Counters (Low-Level Mitigation)\n    # Create a persistent atomic array (2 unsigned integers)\n    ref = :atomics.new(2, signed: false)\n    :persistent_term.put(:telemetry_monitor_ref, ref)\n\n    :timer.send_interval(1000, :tick)\n    {:ok, %{ref: ref}}\n  end\n\n  # Public API - Called by Guard\n  def log_packet(:ok) do\n    ref = :persistent_term.get(:telemetry_monitor_ref)\n    :atomics.add(ref, @clean_idx, 1)\n  end\n\n  def log_packet(:error) do\n    ref = :persistent_term.get(:telemetry_monitor_ref)\n    :atomics.add(ref, @clipped_idx, 1)\n  end\n\n  def handle_info(:tick, %{ref: ref} = state) do\n    # Read and Reset atomically\n    clean = :atomics.exchange(ref, @clean_idx, 0)\n    clipped = :atomics.exchange(ref, @clipped_idx, 0)\n\n    total = clean + clipped\n\n    if total > 0 do\n      distortion = clipped / total\n      if distortion > 0.10 do\n        # 2. Fire-and-Forget Logging (Strategic Mitigation)\n        Task.start(fn ->\n          Logger.warning(\"Harmonic Distortion High: #{Float.round(distortion * 100, 2)}% packet loss.\")\n        end)\n      end\n    end\n    {:noreply, state}\n  end\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Telemetry.Monitor"
        ],
        "functions": [
          "handle_info/2",
          "init/1",
          "log_packet/1",
          "start_link/1"
        ],
        "structs": [],
        "dependencies": [
          "Float",
          "GenServer",
          "Logger",
          "Task"
        ],
        "complexity": 7,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/logic/tactician.ex",
      "content": "defmodule SwarmBrain.Logic.Tactician do\n  @moduledoc \"\"\"\n  The Strategist.\n  Pure logic module that decides WHICH target to pursue based on priority weights.\n  Decoupled from Sensor Fusion and State Management.\n  \"\"\"\n  import Nx.Defn\n\n  # Constants (COCO Class IDs)\n  @person_id 0\n  @watch_id 19\n\n  # Weights (The \"Value\" of a target)\n  @weight_person 100.0\n  @weight_watch 50.0\n\n  @doc \"\"\"\n  Input: A tensor of detections [[class_id, confidence, x, y], ...]\n  Output: The index of the best target.\n  \"\"\"\n  defn select_primary_target_index(detections) do\n    # 1. Extract Columns\n    class_ids = detections[[.., 0]]\n    confidences = detections[[.., 1]]\n\n    # 2. Assign Tactical Weights (Vectorized Strategy)\n    # If Class == Person, Score = 100. Else if Watch, Score = 50. Else 0.\n    weights =\n      Nx.select(class_ids == @person_id, @weight_person,\n        Nx.select(class_ids == @watch_id, @weight_watch, 0.0)\n      )\n\n    # 3. Calculate Final Score (Weight * Confidence)\n    final_scores = weights * confidences\n\n    # 4. Argmax to find the winner\n    Nx.argmax(final_scores)\n  end\n\n  @doc \"\"\"\n  Input: The box [x1, y1, x2, y2]\n  Output: A normalized center point [-1.0 to 1.0] for the Pilot.\n  \"\"\"\n  defn normalize_target_vector(bbox) do\n    # Image center (Assuming 640x480 resolution)\n    w = 640.0\n    h = 480.0\n\n    x1 = bbox[0]\n    y1 = bbox[1]\n    x2 = bbox[2]\n    y2 = bbox[3]\n\n    cx = (x1 + x2) / 2.0\n    cy = (y1 + y2) / 2.0\n\n    # Normalize to -1.0 (Left/Top) to 1.0 (Right/Bottom)\n    norm_x = (cx - (w / 2.0)) / (w / 2.0)\n    norm_y = (cy - (h / 2.0)) / (h / 2.0)\n\n    Nx.stack([norm_x, norm_y])\n  end\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Logic.Tactician"
        ],
        "functions": [],
        "structs": [],
        "dependencies": [
          "Nx",
          "Nx.Defn"
        ],
        "complexity": 0,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/actor/network.ex",
      "content": "defmodule SwarmBrain.Actor.Network do\n  @moduledoc \"The RL Policy Network definition.\"\n\n  # 4 (Fused) + 200 (Optical Flow) + 3 (Intent) = 207\n  @input_size 207\n  @output_size 4\n\n  def build_model do\n    Axon.input(\"state\", shape: {nil, @input_size})\n    |> Axon.dense(128, activation: :tanh)\n    |> Axon.dense(64, activation: :tanh)\n    |> Axon.dense(@output_size, activation: :tanh)\n  end\n\n  # [FIXED] Replaced deprecated Axon.init/4 with Axon.build/2 pattern\n  def init_random_params do\n    model = build_model()\n    # Template: {BatchSize, Features}\n    template = Nx.template({1, @input_size}, :f32)\n\n    # Axon.build returns {init_fn, predict_fn}\n    {init_fn, _} = Axon.build(model, compiler: EXLA)\n\n    # Initialize with default state\n    init_fn.(template, %{})\n  end\n\n  def predict(model_state, input) do\n    model = build_model()\n    # Using EXLA compiler for inference\n    Axon.predict(model, model_state, input, compiler: EXLA)\n  end\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Actor.Network"
        ],
        "functions": [
          "build_model/0",
          "init_random_params/0",
          "predict/2"
        ],
        "structs": [],
        "dependencies": [
          "Axon",
          "EXLA",
          "Nx"
        ],
        "complexity": 3,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/cortex/resnet.ex",
      "content": "defmodule SwarmBrain.Cortex.ResNet do\n  @behaviour SwarmBrain.Cortex.Model\n  alias SwarmBrain.Vision.PreProcessor\n\n  def analyze(%Nx.Tensor{} = raw_tensor) do\n    # 1. JIT Compiled Pre-processing (Class A speed)\n    input_batch = PreProcessor.prepare_resnet(raw_tensor)\n\n    # 2. Inference (Mocked for now, but shape-compatible)\n    # real_output = Axon.predict(model, input_batch)\n\n    # Mock result\n    %{\n      label: \"person\",\n      confidence: 0.98,\n      bbox: [100, 100, 200, 400],\n      tensor_shape: Nx.shape(input_batch) # Debug: Prove pre-processing worked\n    }\n  end\n\n  # 2. OLD: Legacy Path (Resilient Fallback)\n  # We remove the strict struct check to prevent compile errors if the struct is missing.\n  # We just check for a map with the :image_binary key.\n  def analyze(%{image_binary: bin}) when is_binary(bin) do\n    tensor = Nx.from_binary(bin, {:u, 8})\n             |> Nx.reshape({720, 1280, 3})\n    analyze(tensor)\n  end\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Cortex.ResNet"
        ],
        "functions": [
          "analyze/1"
        ],
        "structs": [],
        "dependencies": [
          "Nx",
          "Nx.Tensor",
          "PreProcessor",
          "SwarmBrain.Cortex.Model",
          "SwarmBrain.Vision.PreProcessor"
        ],
        "complexity": 2,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/cortex/yolo.ex",
      "content": "defmodule SwarmBrain.Cortex.Yolo do\n  @behaviour SwarmBrain.Cortex.Model\n  require Logger\n alias SwarmBrain.Vision.PreProcessor\n\n  # [NEW] Import Defn for JIT Compilation\n  import Nx.Defn\n\n  @model_path \"priv/yolox_s_int8.onnx\"\n\n  def init do\n    path = Application.app_dir(:swarm_brain, @model_path)\n    Logger.info(\"\ud83d\udc41\ufe0f Loading Predator Vision: #{path}\")\n    model = Ortex.load(path)\n    :persistent_term.put(:yolo_model, model)\n  end\n\n  def analyze(%Nx.Tensor{} = raw_image) do\n    model = :persistent_term.get(:yolo_model)\n\n    # 1. Prepare (EXLA)\n    input_tensor = PreProcessor.prepare_yolo(raw_image)\n\n    # 2. Run Inference (Ortex)\n    {output_ref} = Ortex.run(model, input_tensor)\n\n    # 3. Transfer Memory (Ortex -> EXLA)\n    predictions = Nx.backend_transfer(output_ref, EXLA.Backend)\n\n    # 4. [NEW] JIT Post-Processing\n    # We offload the heavy math to the compiled kernel.\n    # Returns a tuple of tensors: {score, box, class_id}\n    {best_score_t, box_t, class_id_t} = fast_post_process(predictions)\n\n    # 5. [ADAPTATION] The Logic Bridge\n    # We must pull the values out of the Tensors (GPU/CPU) back to Elixir (Host)\n    confidence = Nx.to_number(best_score_t)\n\n    # Threshold Check (Preserving your logic)\n    if confidence > 0.4 do\n      class_id = Nx.to_number(class_id_t)\n\n      # Box comes out as [x1, y1, x2, y2] from the fast kernel\n      bbox = Nx.to_flat_list(box_t)\n\n      %{\n        label: get_coco_label(class_id),\n        confidence: confidence,\n        bbox: bbox,\n        count: 1 # Since we use ArgMax, we focus on the single best target\n      }\n    else\n      # Nothing valid found\n      %{label: \"none\", confidence: 0.0, bbox: [], count: 0}\n    end\n  end\n\n  # --- THE NEW FAST ENGINE (JIT COMPILED) ---\n\n  defn fast_post_process(predictions) do\n    # 1. Remove batch dim\n    preds = predictions[0]\n\n    # 2. Slice columns\n    # 0..3: [cx, cy, w, h] (Center Format)\n    # 4: Objectness\n    # 5..84: Class Scores\n    box_center = preds[[.., 0..3]]\n    obj_conf = preds[[.., 4]]\n    class_scores = preds[[.., 5..84]]\n\n    # 3. Vectorized Math (Objectness * Best Class Score)\n    max_class_score = Nx.reduce_max(class_scores, axes: [1])\n    final_scores = obj_conf * max_class_score\n\n    # 4. Find the single best candidate (Argmax)\n    # This replaces the slow Sort/NMS for single-target tracking\n    best_idx = Nx.argmax(final_scores)\n    best_score = final_scores[best_idx]\n\n    # 5. Extract and Transform Box\n    # Yolo outputs [cx, cy, w, h]. We need [x1, y1, x2, y2].\n    raw_box = box_center[best_idx]\n\n    cx = raw_box[0]\n    cy = raw_box[1]\n    w = raw_box[2]\n    h = raw_box[3]\n\n    # Coordinate Math inside the JIT (Very Fast)\n    x1 = cx - (w / 2.0)\n    y1 = cy - (h / 2.0)\n    x2 = cx + (w / 2.0)\n    y2 = cy + (h / 2.0)\n\n    final_box = Nx.stack([x1, y1, x2, y2])\n\n    # 6. Extract Class ID\n    best_class_scores = class_scores[best_idx]\n    class_id = Nx.argmax(best_class_scores)\n\n    # Return tuple of tensors\n    {best_score, final_box, class_id}\n  end\n\n  # --- LEGACY MAPPING (Preserved) ---\n\n  defp get_coco_label(id) do\n    case id do\n      0 -> \"person\"\n      1 -> \"bicycle\"\n      2 -> \"car\"\n      3 -> \"motorcycle\"\n      4 -> \"airplane\"\n      5 -> \"bus\"\n      6 -> \"train\"\n      7 -> \"truck\"\n      8 -> \"boat\"\n      9 -> \"traffic light\"\n      10 -> \"fire hydrant\"\n      11 -> \"stop sign\"\n      12 -> \"parking meter\"\n      13 -> \"bench\"\n      14 -> \"bird\"\n      15 -> \"cat\"\n      16 -> \"dog\"\n      17 -> \"horse\"\n      18 -> \"sheep\"\n      19 -> \"cow\"\n      20 -> \"elephant\"\n      21 -> \"bear\"\n      22 -> \"zebra\"\n      23 -> \"giraffe\"\n      24 -> \"backpack\"\n      25 -> \"umbrella\"\n      26 -> \"handbag\"\n      27 -> \"tie\"\n      28 -> \"suitcase\"\n      29 -> \"frisbee\"\n      30 -> \"skis\"\n      31 -> \"snowboard\"\n      32 -> \"sports ball\"\n      33 -> \"kite\"\n      34 -> \"baseball bat\"\n      35 -> \"baseball glove\"\n      36 -> \"skateboard\"\n      37 -> \"surfboard\"\n      38 -> \"tennis racket\"\n      39 -> \"bottle\"\n      40 -> \"wine glass\"\n      41 -> \"cup\"\n      42 -> \"fork\"\n      43 -> \"knife\"\n      44 -> \"spoon\"\n      45 -> \"bowl\"\n      46 -> \"banana\"\n      47 -> \"apple\"\n      48 -> \"sandwich\"\n      49 -> \"orange\"\n      50 -> \"broccoli\"\n      51 -> \"carrot\"\n      52 -> \"hot dog\"\n      53 -> \"pizza\"\n      54 -> \"donut\"\n      55 -> \"cake\"\n      56 -> \"chair\"\n      57 -> \"couch\"\n      58 -> \"potted plant\"\n      59 -> \"bed\"\n      60 -> \"dining table\"\n      61 -> \"toilet\"\n      62 -> \"tv\"\n      63 -> \"laptop\"\n      64 -> \"mouse\"\n      65 -> \"remote\"\n      66 -> \"keyboard\"\n      67 -> \"cell phone\"\n      68 -> \"microwave\"\n      69 -> \"oven\"\n      70 -> \"toaster\"\n      71 -> \"sink\"\n      72 -> \"refrigerator\"\n      73 -> \"book\"\n      74 -> \"clock\"\n      75 -> \"vase\"\n      76 -> \"scissors\"\n      77 -> \"teddy bear\"\n      78 -> \"hair drier\"\n      79 -> \"toothbrush\"\n      _ -> \"unknown\"\n    end\n  end\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Cortex.Yolo"
        ],
        "functions": [
          "init/0",
          "oco_label(id) /1",
          "ze(%Nx./1"
        ],
        "structs": [],
        "dependencies": [
          ".load",
          ".run(",
          "Application",
          "Backend)",
          "Logger",
          "Nx.Defn",
          "SwarmBrain.Cortex.Model",
          "SwarmBrain.Vision.PreProcessor",
          "_f",
          "_n",
          "ac",
          "ck",
          "du",
          "gm",
          "nsor{} =",
          "ocessor.prep"
        ],
        "complexity": 5,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/cortex/switchboard.ex",
      "content": "defmodule SwarmBrain.Switchboard do\n  use GenServer\n  require Logger\n\n  @doc \"Starts the Switchboard with a default neural model.\"\n  def start_link(default_model) do\n    GenServer.start_link(__MODULE__, default_model, name: __MODULE__)\n  end\n\n  @impl true\n  def init(model) do\n    # WRITE: Initialize the atomic term\n    :persistent_term.put(:active_cortex, model)\n    Logger.info(\"Switchboard active. Cortex running on: #{inspect(model)}\")\n    {:ok, model}\n  end\n\n  # READ: No mailbox, direct memory access. Zero latency.\n  # This prevents the bottleneck of thousands of drones asking the GenServer at once.\n  def get_active_model do\n    :persistent_term.get(:active_cortex)\n  end\n\n  # WRITE: Updates the term atomically.\n  def swap_model(new_model) do\n    GenServer.call(__MODULE__, {:swap, new_model})\n  end\n\n  @impl true\n  def handle_call({:swap, new_model}, _from, _state) do\n    # Atomic swap at the VM level.\n    :persistent_term.put(:active_cortex, new_model)\n    Logger.warning(\"Cortex Swapping to #{inspect(new_model)}\")\n    {:reply, :ok, new_model}\n  end\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Switchboard"
        ],
        "functions": [
          "get_active_model/0",
          "handle_call/3",
          "init/1",
          "start_link/1",
          "swap_model/1"
        ],
        "structs": [],
        "dependencies": [
          "GenServer",
          "Logger"
        ],
        "complexity": 5,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/cortex/model.ex",
      "content": "defmodule SwarmBrain.Cortex.Model do\n  @moduledoc \"\"\"\n  The Holy Contract.\n  Every Cortex implementation (ResNet, YOLO, MobileNet) must obey this signature.\n  \"\"\"\n\n  # The callback defines the shape of the \"thought\"\n  # It accepts a Tensor (fast path) or a Map (legacy path)\n  # It must return a prediction map.\n  @callback analyze(Nx.Tensor.t() | map()) :: %{\n    label: String.t(),\n    confidence: float(),\n    bbox: list(integer())\n  }\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Cortex.Model"
        ],
        "functions": [],
        "structs": [],
        "dependencies": [
          "Nx.Tensor",
          "String"
        ],
        "complexity": 0,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/cortex/watchdog.ex",
      "content": "defmodule SwarmBrain.Cortex.Watchdog do\n  use GenServer\n  require Logger\n\n  @high 0.75\n  @low 0.35\n  @lock_duration 5000\n  @latency_warn_threshold 200 # ms\n\n  def start_link(_), do: GenServer.start_link(__MODULE__, %{mode: :high_accuracy, locked_until: 0}, name: __MODULE__)\n  def init(state), do: {:ok, state}\n\n  def input_confidence(score), do: GenServer.cast(__MODULE__, {:tick, score})\n  def input_imu(g_force), do: GenServer.cast(__MODULE__, {:imu_spike, g_force})\n\n  # [NEW] Latency Telemetry\n  def report_latency(nanos), do: GenServer.cast(__MODULE__, {:latency, nanos})\n\n  # --- HANDLERS ---\n\n  def handle_cast({:latency, nanos}, state) do\n    ms = System.convert_time_unit(nanos, :native, :millisecond)\n\n    if ms > @latency_warn_threshold do\n      Logger.warning(\"\ud83d\udc22 High Latency Detected: #{ms}ms\")\n    end\n\n    # Future expansion: If latency stays high, downgrade model automatically\n    {:noreply, state}\n  end\n\n  def handle_cast({:imu_spike, g_force}, state) when g_force > 2.0 do\n    Logger.warning(\"G-Force Spike (#{g_force}G). OVERRIDE: Forcing High Accuracy.\")\n    SwarmBrain.Switchboard.swap_model(SwarmBrain.Cortex.ResNet)\n    lock_time = System.monotonic_time(:millisecond) + @lock_duration\n    {:noreply, %{state | mode: :high_accuracy, locked_until: lock_time}}\n  end\n\n  def handle_cast({:tick, score}, state) do\n    now = System.monotonic_time(:millisecond)\n    if now < state.locked_until do\n      {:noreply, state}\n    else\n      handle_hysteresis(score, state)\n    end\n  end\n\n  defp handle_hysteresis(score, %{mode: :high_accuracy} = state) when score < @low do\n    Logger.info(\"Confidence dropping. Engaging Power Save.\")\n    SwarmBrain.Switchboard.swap_model(SwarmBrain.Cortex.MobileNet)\n    {:noreply, %{state | mode: :power_save}}\n  end\n\n  defp handle_hysteresis(score, %{mode: :power_save} = state) when score > @high do\n    Logger.info(\"Confidence High. Restoring Full Fidelity.\")\n    SwarmBrain.Switchboard.swap_model(SwarmBrain.Cortex.ResNet)\n    {:noreply, %{state | mode: :high_accuracy}}\n  end\n\n  defp handle_hysteresis(_, state), do: {:noreply, state}\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Cortex.Watchdog"
        ],
        "functions": [
          "dle_cast({:/2",
          "dle_hysteresis(_,/2",
          "handle_cast/2",
          "init/1",
          "input_confidence/1",
          "input_imu/1",
          "report_latency/1",
          "start_link/1"
        ],
        "structs": [],
        "dependencies": [
          "GenServer",
          "Logger",
          "System",
          "ger.in",
          "ger.wa",
          "rmBrain.Cortex.MobileNet)",
          "rmBrain.Cortex.ResNet)",
          "rmBrain.Switchboard.sw",
          "tem.mo"
        ],
        "complexity": 13,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/llama/summarizer.ex",
      "content": "defmodule SwarmBrain.Llama.Summarizer do\n  @moduledoc \"Translates vision detections into tactical language prompts.\"\n\n  def generate_prompt(detections, previous_context \\\\ []) do\n    # Detections is a list of %{label: \"person\", bbox: [...]}\n\n    events = Enum.map_join(detections, \"\\n\", fn d ->\n      \"- Visual Contact: #{d.label} (Conf: #{Float.round(d.confidence, 2)})\"\n    end)\n\n    \"\"\"\n    [MISSION LOG]\n    Time: #{DateTime.utc_now()}\n    Context: #{Enum.join(previous_context, \"; \")}\n\n    CURRENT SENSORS:\n    #{events}\n\n    TACTICAL ASSESSMENT:\n    Based on the above, identify threats and suggest a formation adjustment.\n    \"\"\"\n  end\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Llama.Summarizer"
        ],
        "functions": [
          "generate_prompt/2"
        ],
        "structs": [],
        "dependencies": [
          "DateTime",
          "Enum",
          "Float"
        ],
        "complexity": 1,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/hardware/spine.ex",
      "content": "defmodule SwarmBrain.Hardware.Spine do\n  @moduledoc \"\"\"\n  The Spinal Cord.\n  Translates 'Intent' (RL Output) into 'MSP' (Flight Controller Protocol).\n  Implements the \"Reflex Arc\" - safe clamping and mapping of signals.\n  \"\"\"\n  use GenServer\n  require Logger\n\n  # MSP Command IDs\n  @msp_set_raw_rc 200\n  @msp_ident 100\n  # @msp_attitude 108 (Uncomment when we implement full telemetry parsing)\n\n  # PWM Constants (Standard RC)\n  @pwm_min 1000\n  @pwm_max 2000\n  @pwm_mid 1500\n\n  defstruct [:uart_pid, :mode, :last_attitude]\n\n  def start_link(opts), do: GenServer.start_link(__MODULE__, opts, name: __MODULE__)\n\n  # API\n  def get_imu_state, do: GenServer.call(__MODULE__, :get_attitude)\n\n  # The Reflex Trigger: Called by Tracker 30 times a second\n  def send_controls(r, p, y, t), do: GenServer.cast(__MODULE__, {:command, {r, p, y, t}})\n\n  def init(_opts) do\n    uart_dev = Application.get_env(:swarm_brain, :fc_port)\n\n    # Simple Hardware Check\n    if uart_dev && File.exists?(uart_dev) do\n      Logger.info(\"\ud83d\udd0c Spine: Connecting to Nervous System (FC) on #{uart_dev}\")\n      {:ok, pid} = Circuits.UART.start_link()\n      Circuits.UART.open(pid, uart_dev, speed: 115200, active: true)\n\n      # Handshake\n      request_ident(pid)\n\n      {:ok, %__MODULE__{mode: :hardware, uart_pid: pid, last_attitude: %{roll: 0.0, pitch: 0.0, yaw: 0.0}}}\n    else\n      Logger.warning(\"\ud83d\udc7b Spine: No Flight Controller detected. Running in GHOST MODE.\")\n      {:ok, %__MODULE__{mode: :ghost, uart_pid: nil, last_attitude: %{roll: 0.0, pitch: 0.0, yaw: 0.0}}}\n    end\n  end\n\n  # --- REFLEX LOOP ---\n\n  def handle_cast({:command, {r, p, y, t}}, %{mode: :hardware} = state) do\n    # 1. Map RL Intent (-1.0 to 1.0) to PWM (1000 to 2000)\n    payload = encode_rc_payload(r, p, y, t)\n\n    # 2. Send to Nervous System (FC)\n    Circuits.UART.write(state.uart_pid, pack_msp(@msp_set_raw_rc, payload))\n\n    {:noreply, state}\n  end\n\n  def handle_cast({:command, _}, %{mode: :ghost} = state) do\n    # In Ghost Mode, we do nothing. The Tracker logs the output.\n    {:noreply, state}\n  end\n\n  # --- INCOMING SENSORY DATA ---\n\n  # [FIX] Prefix unused 'data' with underscore to silence warning\n  def handle_info({:circuits_uart, _, _data}, state) do\n    # Placeholder: Future telemetry parsing goes here.\n    {:noreply, state}\n  end\n\n  # --- MSP PROTOCOL ---\n\n  defp request_ident(pid), do: Circuits.UART.write(pid, pack_msp(@msp_ident, <<>>))\n\n  defp pack_msp(cmd_id, payload) do\n    size = byte_size(payload)\n    checksum = bitwise_xor_checksum(size, cmd_id, payload)\n    << \"$\", \"M\", \"<\", size, cmd_id, payload::binary, checksum >>\n  end\n\n  defp bitwise_xor_checksum(size, cmd, payload) do\n    initial = Bitwise.bxor(size, cmd)\n    for <<byte <- payload>>, reduce: initial do\n      acc -> Bitwise.bxor(acc, byte)\n    end\n  end\n\n  # The \"Reflex\" Mapper\n  defp encode_rc_payload(r, p, y, t) do\n    <<\n      map_to_pwm(r)::little-16, # Roll\n      map_to_pwm(p)::little-16, # Pitch\n      map_to_pwm(t)::little-16, # Throttle\n      map_to_pwm(y)::little-16, # Yaw\n      @pwm_mid::little-16,      # Aux1 (Arm?) - [FIX] Use Attribute\n      @pwm_min::little-16,      # Aux2          [FIX] Use Attribute\n      @pwm_min::little-16,      # Aux3\n      @pwm_min::little-16       # Aux4\n    >>\n  end\n\n  defp map_to_pwm(val) do\n    # Clamp safety\n    clamped = max(-1.0, min(val, 1.0))\n\n    # [FIX] Dynamic calculation using Attributes instead of hardcoded numbers\n    # Slope = (2000 - 1000) / 2 = 500\n    slope = (@pwm_max - @pwm_min) / 2.0\n    intercept = @pwm_mid\n\n    round((clamped * slope) + intercept)\n  end\n\n  def handle_call(:get_attitude, _from, state) do\n    {:reply, state.last_attitude, state}\n  end\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Hardware.Spine"
        ],
        "functions": [
          "_call(:get_/3",
          "_cast({:com/2",
          "_info({:cir/2",
          "_pwm(val) /1",
          "_rc_payload(r, p,/4",
          "e_xor_checksum(size,/3",
          "get_imu_state/0",
          "init/1",
          "send_controls/4",
          "sp(cmd_i/2",
          "start_link/1",
          "t_ident(pid),/1"
        ],
        "structs": [
          "[:uart_pid, :mode, :last_attitude]"
        ],
        "dependencies": [
          "Application",
          "File",
          "GenServer",
          "Logger",
          "cuits.UART.op",
          "cuits.UART.st",
          "e.bxor(",
          "ger.wa",
          "ts.UART.write"
        ],
        "complexity": 14,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/blackboard/fusion.ex",
      "content": "defmodule SwarmBrain.Blackboard.Fusion do\n  @moduledoc \"\"\"\n  The Vectorized Tactical Processor.\n  Uses EXLA/Nx to fuse sensor data from multiple drones in O(1) time.\n  \"\"\"\n  import Nx.Defn\n\n  # Constants for Classification\n  @person_id 0\n  @watch_id 19 # Example ID from COCO\n\n  @doc \"\"\"\n  Accepts a batch of detections: [[class_id, confidence, x, y], ...]\n  Returns the index of the highest priority target.\n  \"\"\"\n  defn select_primary_target_index(detections) do\n    # 1. Extract Columns\n    class_ids = detections[[.., 0]]\n    confidences = detections[[.., 1]]\n\n    # 2. Assign Tactical Weights (Vectorized)\n    # Person (0) = 100.0, Watch (19) = 50.0, Others = 0.0\n    weights =\n      Nx.select(class_ids == @person_id, 100.0,\n        Nx.select(class_ids == @watch_id, 50.0, 0.0)\n      )\n\n    # 3. Calculate Final Score (Weight * Confidence)\n    final_scores = weights * confidences\n\n    # 4. Argmax to find the winner\n    Nx.argmax(final_scores)\n  end\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Blackboard.Fusion"
        ],
        "functions": [],
        "structs": [],
        "dependencies": [
          "Nx",
          "Nx.Defn"
        ],
        "complexity": 0,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/sensor/proprioception.ex",
      "content": "defmodule SwarmBrain.Sensor.Proprioception do\n  @moduledoc \"\"\"\n  The Fast-Twitch Muscle Fibers.\n  Decouples physics (Proprioception) from high-level perception (Fusion).\n  \"\"\"\n  alias SwarmBrain.Vision.{Server, Native}\n\n  # --- ZERO-LATENCY READ (Kinematics) ---\n  def get_kinematics do\n    resource = Server.get_resource()\n\n    if resource do\n      bin = Native.get_fused_state(resource)\n      Nx.from_binary(bin, :f32)\n    else\n      Nx.tensor([0.0, 0.0, 0.0, 0.0], type: :f32)\n    end\n  end\n\n  # --- ZERO-LATENCY READ (Optical Flow Grid) ---\n  # Returns a tensor of shape {200} representing the 10x10 grid (dx, dy)\n  def get_optical_flow do\n    resource = Server.get_resource()\n\n    if resource do\n      # Fetch 800 bytes (200 floats)\n      case Native.get_flow_grid(resource) do\n        bin when is_binary(bin) ->\n          Nx.from_binary(bin, :f32)\n        _ ->\n          Nx.broadcast(0.0, {200}) |> Nx.as_type(:f32)\n      end\n    else\n      Nx.broadcast(0.0, {200}) |> Nx.as_type(:f32)\n    end\n  end\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Sensor.Proprioception"
        ],
        "functions": [
          "get_kinematics/0",
          "get_optical_flow/0"
        ],
        "structs": [],
        "dependencies": [
          "Native",
          "Nx",
          "Server",
          "SwarmBrain.Vision"
        ],
        "complexity": 5,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/sensor/fusion.ex",
      "content": "defmodule SwarmBrain.Sensor.Fusion do\n  @moduledoc \"\"\"\n  The Inner Ear & Fovea.\n  A GenServer that:\n  1. Owns the 'Target' memory (ETS) - The Pre-Amp.\n  2. Receives asynchronous vision updates via message passing.\n  \"\"\"\n  use GenServer\n  require Logger\n\n  # Dedicated Memory for Visual Targets\n  @table :fusion_targets\n  @key :current_target\n\n  # --- API ---\n  def start_link(_opts), do: GenServer.start_link(__MODULE__, [], name: __MODULE__)\n\n  # Fast Read for the Pilot (Non-blocking)\n  def get_visual_target do\n    case :ets.lookup(@table, @key) do\n      [{@key, target}] -> target\n      [] -> nil\n    end\n  end\n\n  # --- SERVER ---\n  def init(_) do\n    Logger.info(\"\ud83d\udc42 Fusion: Online. Stabilizing Sensory Inputs.\")\n    # Create the table (Owned by this process, protected write, public read)\n    :ets.new(@table, [:set, :named_table, :protected, read_concurrency: true])\n    {:ok, %{}}\n  end\n\n  # The message from Blackboard comes here\n  def handle_info({:visual_contact, detections}, state) do\n    # 1. Filter Logic (Simple 'best' selection for now)\n    best = List.first(detections)\n\n    if best do\n      # Write to fast memory\n      :ets.insert(@table, {@key, best})\n    end\n\n    {:noreply, state}\n  end\n\n  # Catch-all for other messages to prevent crashes\n  def handle_info(_msg, state), do: {:noreply, state}\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Sensor.Fusion"
        ],
        "functions": [
          "dle_info(_m/2",
          "dle_info({:/2",
          "get_visual_target/0",
          "init/1",
          "start_link/1"
        ],
        "structs": [],
        "dependencies": [
          "GenServer",
          "Logger",
          "t.fi"
        ],
        "complexity": 7,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/vision/native.ex",
      "content": "defmodule SwarmBrain.Vision.Native do\n  @moduledoc \"\"\"\n  The Iron Lung Interface.\n  Acts as the bridge to the Rust 'swarm_native' crate.\n  \"\"\"\n  use Rustler, otp_app: :swarm_brain, crate: \"swarm_native\"\n\n  # --- 1. LIFECYCLE ---\n  def init_state, do: error()\n\n  # Arity 3: width, height, threshold\n  def init_retina(_width, _height, _threshold), do: error()\n\n  # Arity 3: resource, width, height\n  def start_camera(_resource, _width, _height), do: error()\n\n  # [NEW] The Watchdog Probe\n  def check_health(_resource), do: error()\n\n  # --- 2. SENSORS (ATOMIC) ---\n\n  def get_latest_frame(_resource), do: error()\n  def get_fused_state(_resource), do: error()\n  def get_flow_grid(_resource), do: error()\n\n  # --- 3. LOGIC (RETINA) ---\n\n  # Arity 2: resource, frame_binary\n  def detect_change(_resource), do: error()\n\n  # --- 4. LEGACY STUBS (FIXED) ---\n\n  # [FIX] Removed _env. Arity is now 4 (id, x, y, h).\n  def update_spatial_state(_resource, _x, _y, _status), do: error()\n\n  # [FIX] Removed _env. Arity is now 1 (id).\n  def get_spatial_state(_resource, _x, _y), do: error()\n\n  # [FIX] Removed _env. Arity is now 0.\n  def setup_queryable(), do: error()\n\n  defp error, do: :erlang.nif_error(:nif_not_loaded)\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Vision.Native"
        ],
        "functions": [
          "check_health/1",
          "detect_change/1",
          "error/0",
          "get_flow_grid/1",
          "get_fused_state/1",
          "get_latest_frame/1",
          "get_spatial_state/3",
          "init_retina/3",
          "init_state/0",
          "setup_queryable/0",
          "start_camera/3",
          "update_spatial_state/4"
        ],
        "structs": [],
        "dependencies": [
          "Rustler"
        ],
        "complexity": 12,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/vision/retina.ex",
      "content": "  defmodule SwarmBrain.Vision.Retina do\n  use GenServer\n  require Logger\n  alias SwarmBrain.Vision.Native\n  alias SwarmBrain.Vision.Server\n  alias SwarmBrain.Cortex\n\n# Resolution Configuration\n  # We read the config block defined in config.exs under :swarm_brain, :vision\n  # No default provided. If config.exs is broken, this returns nil or raises an error depending on strictness.\n  @vision_config Application.compile_env!(:swarm_brain, :vision)\n  @width @vision_config[:width]\n  @height @vision_config[:height]\n\n  # Keyframe Sync: Every 60 frames (approx 2s at 30fps)\n  @keyframe_tick 60\n\n  def start_link(opts \\\\ []) do\n    GenServer.start_link(__MODULE__, opts, name: __MODULE__)\n  end\n\n  @impl true\n  def init(_opts) do\n    Logger.info(\"\ud83d\udc41 Retina: Online. Linking to Iron Lung...\")\n\n    # [FIX 1] Lazy Initialization\n    # We do not call Native.init_retina(). We wait to grab the shared\n    # resource from the Server's persistent_term.\n    {:ok, %{\n      resource: nil,\n      frame_count: 0\n    }}\n  end\n\n  # This function is called by your Camera/Sensor loop\n  def process_frame(frame_binary) do\n    GenServer.cast(__MODULE__, {:frame, frame_binary})\n  end\n\n  @impl true\n  def handle_cast({:frame, frame_bin}, state) do\n    # 1. Lazy Resource Fetch\n    resource = state.resource || Server.get_resource()\n\n    if is_nil(resource) do\n      # If the Iron Lung isn't ready, we can't see. Drop frame.\n      {:noreply, state}\n    else\n      # 2. Keyframe Sync Logic\n      is_keyframe = rem(state.frame_count, @keyframe_tick) == 0\n\n      if is_keyframe do\n         # SYNC: Force full Cortex analysis to correct temporal drift\n         trigger_full_inference(frame_bin)\n         {:noreply, %{state | resource: resource, frame_count: state.frame_count + 1}}\n      else\n         # 3. GATED PERCEPTION (Rust NIF)\n         # [FIX 2] Arity 1: Rust checks its internal Triple Buffer.\n         # [FIX 3] Return Type: We get a raw tuple, not a tagged atom.\n         case Native.detect_change(resource) do\n           {0, 0, 0, 0} ->\n              # Silence... efficient silence.\n              {:noreply, %{state | resource: resource, frame_count: state.frame_count + 1}}\n\n           {x, y, w, h} ->\n              # 4. ROI CROP\n              # Logger.debug(\"\ud83d\udc41 Retina: Movement detected at {#{x}, #{y}}\")\n\n              # We use the 'frame_bin' passed in for the crop source\n              frame_bin\n              |> Evision.Mat.from_binary(@height, @width, :u8, 1)\n              |> Evision.Mat.roi({x, y, w, h})\n              |> to_nx_tensor()\n              |> Cortex.analyze()\n\n              {:noreply, %{state | resource: resource, frame_count: state.frame_count + 1}}\n         end\n      end\n    end\n  end\n\n  # Helper to bridge Evision Mat -> Nx Tensor\n  defp to_nx_tensor(evision_mat) do\n    binary_data = Evision.Mat.to_binary(evision_mat)\n    {h, w, _c} = Evision.Mat.shape(evision_mat)\n\n    # Assuming YOLO expects RGB, but Evision might be grayscale here.\n    # Adjust channels if necessary.\n    Nx.from_binary(binary_data, :u8)\n    |> Nx.reshape({h, w, 1})\n  end\n\n  defp trigger_full_inference(frame_bin) do\n    # Convert full frame to Tensor and fire\n    Nx.from_binary(frame_bin, :u8)\n    |> Nx.reshape({@height, @width, 3}) # Assuming RGB input\n    |> Cortex.analyze()\n  end\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Vision.Retina"
        ],
        "functions": [
          "cess_frame(fr/1",
          "dle_cast({:/2",
          "init/1",
          "r_full_inference(frame/1",
          "start_link/1",
          "tensor(evisi/1"
        ],
        "structs": [],
        "dependencies": [
          ".analy",
          "Application",
          "GenServer",
          "Logger",
          "Server.ca",
          "SwarmBrain.Cortex",
          "SwarmBrain.Vision.Native",
          "SwarmBrain.Vision.Server",
          "ha",
          "ive.de",
          "m_",
          "n.Mat.from_",
          "n.Mat.roi({",
          "n.Mat.shape",
          "n.Mat.to_bi",
          "ver.ge"
        ],
        "complexity": 9,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/vision/behaviour.ex",
      "content": "defmodule SwarmBrain.Vision.Behaviour do\n  @moduledoc \"The Constitutional Contract for the Vision System.\"\n\n  @callback start_camera(width :: integer(), height :: integer()) :: :ok | {:error, any()}\n  @callback capture_frame() :: binary() | {:error, atom()}\n  @callback to_binary(data :: any()) :: binary()\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Vision.Behaviour"
        ],
        "functions": [],
        "structs": [],
        "dependencies": [],
        "complexity": 0,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/vision/nms.ex",
      "content": "defmodule SwarmBrain.Vision.NMS do\n  use Rustler, otp_app: :swarm_brain, crate: \"swarm_brain_nms\"\n\n  def nms(_boxes, _iou_threshold), do: :erlang.nif_error(:nif_not_loaded)\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Vision.NMS"
        ],
        "functions": [
          "nms/2"
        ],
        "structs": [],
        "dependencies": [
          "Rustler"
        ],
        "complexity": 1,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/vision/server.ex",
      "content": "defmodule SwarmBrain.Vision.Server do\n  @moduledoc \"\"\"\n  The Cerebellum of the Vision System.\n  Now equipped with a Self-Healing Watchdog (Auto-Bias).\n  \"\"\"\n  use GenServer\n  require Logger\n  alias SwarmBrain.Vision.{Native, SharedBuffer}\n  alias SwarmBrain.Cortex.Yolo\n\n  @resource_key :swarm_vision_resource\n  @tick_interval 33 # ~30 FPS\n  @health_check_interval 30 # Check every 30 ticks (~1 second)\n\n  def start_link(opts), do: GenServer.start_link(__MODULE__, opts, name: __MODULE__)\n\n  def get_resource, do: :persistent_term.get(@resource_key, nil)\n\n  @impl true\n  def init(_opts) do\n    config = Application.get_env(:swarm_brain, :vision, [width: 640, height: 480])\n    width = config[:width]\n    height = config[:height]\n\n    Logger.info(\"\ud83d\udc41\ufe0f Vision.Server: Ignition. Booting Iron Lung...\")\n\n    # 1. ALLOCATE ARENA (Rust)\n    resource = Native.init_state()\n    :persistent_term.put(@resource_key, resource)\n\n    # 2. START HEARTBEAT\n    case Native.start_camera(resource, width, height) do\n      :ok ->\n        Logger.info(\"\ud83d\udc41\ufe0f Vision.Server: Heartbeat Active.\")\n        schedule_tick()\n        {:ok, %{\n          resource: resource,\n          active_inferences: 0,\n          max_concurrency: 1,\n          tick_count: 0\n        }}\n\n      error ->\n        Logger.error(\"\u274c Vision.Server: Primary Ignition Failed: #{inspect(error)}\")\n        {:stop, :camera_ignition_failure}\n    end\n  end\n\n  # --- THE WATCHDOG LOOP ---\n\n  @impl true\n  def handle_info(:tick, state) do\n    # 1. Perform Health Check every second (~30 ticks)\n    new_tick_count = state.tick_count + 1\n\n    if rem(new_tick_count, @health_check_interval) == 0 do\n      check_physiology!(state.resource)\n    end\n\n    # 2. Process Vision (Backpressure Control)\n    if state.active_inferences < state.max_concurrency do\n      case SharedBuffer.get_vision_tensor() do\n        {:ok, tensor} ->\n          async_inference(tensor)\n          schedule_tick()\n          {:noreply, %{state | active_inferences: state.active_inferences + 1, tick_count: new_tick_count}}\n\n        _ ->\n          schedule_tick()\n          {:noreply, %{state | tick_count: new_tick_count}}\n      end\n    else\n      # System saturated; skip frame\n      schedule_tick()\n      {:noreply, %{state | tick_count: new_tick_count}}\n    end\n  end\n\n  def handle_info(:inference_complete, state) do\n    {:noreply, %{state | active_inferences: max(0, state.active_inferences - 1)}}\n  end\n\n  # --- PRIVATE HELPERS ---\n\n  defp check_physiology!(resource) do\n    # [Point 2: The Watchdog]\n    # We call the Rust NIF to see if the process is alive\n    case Native.check_health(resource) do\n      :ok ->\n        :ok # Pulse detected.\n\n      :error ->\n        Logger.warning(\"\ud83d\udc7b Vision.Server: BRAIN-STEM DEATH DETECTED. Triggering Reset...\")\n        # Trigger Supervisor Restart (Power Cycle)\n        exit(:camera_failure)\n    end\n  end\n\n  defp async_inference(tensor) do\n    parent = self()\n    Task.Supervisor.start_child(SwarmBrain.Cortex.Supervisor, fn ->\n      results = Yolo.analyze(tensor)\n      SwarmBrain.Blackboard.update_vision(results, %{})\n      send(parent, :inference_complete)\n    end)\n  end\n\n  defp schedule_tick, do: Process.send_after(self(), :tick, @tick_interval)\n\n  @impl true\n  def terminate(_reason, _state) do\n    :persistent_term.erase(@resource_key)\n  end\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Vision.Server"
        ],
        "functions": [
          "(tensor) do\n   /1",
          ":inference_/2",
          ":tick, stat/2",
          "do: Process.s/0",
          "get_resource/0",
          "init/1",
          "logy!(resource) d/1",
          "on, _stat/2",
          "start_link/1"
        ],
        "structs": [],
        "dependencies": [
          ".get_vision_",
          ".start_child(Sw",
          "Application",
          "GenServer",
          "Logger",
          "Native",
          "SharedBuffer",
          "SwarmBrain.Cortex.Yolo",
          "SwarmBrain.Vision",
          "_healt",
          "e.init",
          "e.star",
          "ex.Supervisor, fn ->\n      r",
          "kboard.update_vision(",
          "ng(\"\ud83d\udc7b",
          "nsor",
          "or(\"\u274c",
          "r.info",
          "ter(sel"
        ],
        "complexity": 14,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/vision/shared_buffer.ex",
      "content": "defmodule SwarmBrain.Vision.SharedBuffer do\n  @moduledoc \"Interface for Zero-Copy tensor creation.\"\n  require Logger\n  alias SwarmBrain.Vision.{Server, Native}\n\n  # Ensure these match native/swarm_native/src/state/arena.rs\n  # We read config at compile time to avoid runtime lookup costs in the hot loop\n  @config Application.compile_env(:swarm_brain, :vision, [width: 640, height: 480])\n  @width @config[:width]\n  @height @config[:height]\n  @channels 3\n  @expected_size @width * @height * @channels\n\n  @doc \"\"\"\n  Fetches the current frame from the Iron Lung and inflates it into an Nx Tensor.\n  Returns {:ok, tensor} or {:error, reason}.\n  \"\"\"\n  def get_vision_tensor(_opts \\\\ []) do\n    resource = Server.get_resource()\n\n    if resource do\n      # 1. Atomic Fetch (Always returns Binary)\n      # The Iron Lung guarantees this is never nil and never empty (pre-allocated).\n      raw_binary = Native.get_latest_frame(resource)\n\n      # 2. Safety Check\n      if byte_size(raw_binary) == @expected_size do\n\n        # 3. Inflate to Tensor\n        # Note: At boot, this may be an all-black tensor (zeros)\n        # We use u8 (0-255) for raw RGB data.\n        Nx.from_binary(raw_binary, :u8)\n        |> Nx.reshape({@height, @width, @channels})\n        |> then(&{:ok, &1})\n\n      else\n        # This branch catches \"Cosmic Ray\" memory corruption or config mismatches\n        Logger.error(\"CRITICAL: Buffer Mismatch! Rust sent #{byte_size(raw_binary)}, Expected #{@expected_size}\")\n        {:error, :memory_corruption}\n      end\n    else\n      # The Rust NIF hasn't been loaded into the Persistent Term yet\n      {:error, :resource_not_ready}\n    end\n  end\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Vision.SharedBuffer"
        ],
        "functions": [
          "get_vision_tensor/1"
        ],
        "structs": [],
        "dependencies": [
          "Application",
          "Logger",
          "Native",
          "Nx",
          "Server",
          "SwarmBrain.Vision"
        ],
        "complexity": 3,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/vision/pre_processor.ex",
      "content": "defmodule SwarmBrain.Vision.PreProcessor do\n  @moduledoc \"Universal optics that adapt to any camera resolution.\"\n  import Nx.Defn\n\n  @target_size 640\n\n  # --- PART 1: THE ARCHITECT (CPU) ---\n  # Calculates the geometry.\n  # This is a normal Elixir function, not JIT-compiled.\n  def prepare_yolo(tensor) do\n    # Extract concrete integers from the tensor struct\n    {h, w, _c} = tensor.shape\n\n    # Calculate Scale (Standard Elixir Math)\n    scale = max(@target_size / h, @target_size / w)\n\n    # Calculate target dimensions (Must be Integers)\n    new_h = round(h * scale)\n    new_w = round(w * scale)\n\n    # Pass these integers as CONSTANTS (opts) to the JIT compiler\n    apply_yolo_optics(tensor, size: {new_h, new_w}, crop_size: {@target_size, @target_size})\n  end\n\n  # --- PART 2: THE BUILDER (GPU/EXLA) ---\n  # This is the JIT-compiled kernel.\n  # It takes 'opts' which are baked into the compiled graph as constants.\n  defn apply_yolo_optics(tensor, opts \\\\ []) do\n    opts = keyword!(opts, [:size, :crop_size])\n    target_size = opts[:size]\n    crop_size = opts[:crop_size]\n\n    tensor\n    |> Nx.as_type(:f32)\n\n    # Resize using the static integers passed from Part 1\n    |> NxImage.resize(target_size, method: :bilinear)\n\n    # Center crop\n    |> NxImage.center_crop(crop_size)\n\n    # Polish\n    |> Nx.reverse(axes: [2])\n    |> Nx.transpose(axes: [2, 0, 1])\n    |> Nx.new_axis(0)\n  end\n\n  # ResNet remains standard\n  defn prepare_resnet(tensor) do\n    tensor\n    |> Nx.as_type(:f32)\n    |> Nx.divide(255.0)\n    |> NxImage.resize({224, 224}, method: :bilinear)\n    |> Nx.transpose(axes: [2, 0, 1])\n    |> Nx.new_axis(0)\n    |> normalize()\n  end\n\n  defnp normalize(tensor) do\n    mean = Nx.tensor([0.485, 0.456, 0.406], type: :f32) |> Nx.reshape({3, 1, 1})\n    std = Nx.tensor([0.229, 0.224, 0.225], type: :f32) |> Nx.reshape({3, 1, 1})\n    (tensor - mean) / std\n  end\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Vision.PreProcessor"
        ],
        "functions": [
          "prepare_yolo/1"
        ],
        "structs": [],
        "dependencies": [
          "Nx",
          "Nx.Defn",
          "NxImage"
        ],
        "complexity": 1,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/vision/decoder.ex",
      "content": "defmodule SwarmBrain.Vision.Decoder do\n  import Nx.Defn\n\n  @moduledoc \"Vectorized decoding logic for neural outputs.\"\n\n  defn decode_vectorized(predictions, threshold) do\n    # 1. Mask: 1.0 if score > threshold, else 0.0\n    scores = predictions[[.., 4]]\n    mask = Nx.greater(scores, threshold)\n\n    cx = predictions[[.., 0]]\n    cy = predictions[[.., 1]]\n    w  = predictions[[.., 2]]\n    h  = predictions[[.., 3]]\n\n    # 2. Calculate coordinates\n    x1 = cx - (w / 2)\n    y1 = cy - (h / 2)\n    x2 = cx + (w / 2)\n    y2 = cy + (h / 2)\n\n    # 3. Stack results: [x1, y1, x2, y2, score]\n    boxes = Nx.stack([x1, y1, x2, y2, scores], axis: 1)\n\n    # 4. Zero-out invalid boxes (Soft Filtering)\n    # Instead of removing rows (which is illegal in defn), we set them to 0.\n    zero_tensor = Nx.broadcast(0.0, boxes)\n\n    # Expand mask to match box shape for selection\n    # mask is [N], boxes is [N, 5]. We need to broadcast mask.\n    mask_expanded = Nx.broadcast(Nx.new_axis(mask, -1), boxes)\n\n    Nx.select(mask_expanded, boxes, zero_tensor)\n  end\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Vision.Decoder"
        ],
        "functions": [],
        "structs": [],
        "dependencies": [
          "Nx",
          "Nx.Defn"
        ],
        "complexity": 0,
        "doc": null
      }
    },
    {
      "path": "lib/swarm_brain/vision/yolo/post_processor.ex",
      "content": "defmodule SwarmBrain.Vision.Yolo.PostProcessor do\n  @moduledoc \"Vectorized NMS for Predator Vision.\"\n  import Nx.Defn\n\n  # Tunable Constraints (Static for XLA optimization)\n  @max_detections 20\n\n  @doc \"\"\"\n  Performs Non-Maximum Suppression.\n  Arguments must be explicit tensors, not keyword lists.\n  \"\"\"\n  defn non_max_suppression(boxes, scores, iou_threshold \\\\ 0.45) do\n    # 1. Sort scores descending\n    sorted_indices = Nx.argsort(scores, direction: :desc)\n    sorted_boxes = Nx.take(boxes, sorted_indices)\n\n    # 2. Initialize mask (1 = keep)\n    initial_mask = Nx.broadcast(1, scores)\n\n    # 3. Static Loop (XLA requires constant bounds)\n    # We check the top 20 candidates.\n    {final_mask, _, _, _} =\n      while {mask = initial_mask, boxes = sorted_boxes, scores, iou_threshold}, i <- 0..(@max_detections - 1) do\n        current_box = boxes[i]\n        ious = calculate_iou(current_box, boxes)\n\n        # Kill box if IoU > threshold AND it has a lower rank\n        suppress =\n          ious\n          |> Nx.greater(iou_threshold)\n          |> Nx.logical_and(Nx.iota(Nx.shape(mask)) |> Nx.greater(i))\n\n        new_mask = Nx.select(suppress, 0, mask)\n\n        {new_mask, boxes, scores, iou_threshold}\n      end\n\n    # 4. Return Top K Indices and the Mask\n    top_k_indices = sorted_indices[0..(@max_detections - 1)]\n    top_k_mask = final_mask[0..(@max_detections - 1)]\n\n    {top_k_indices, top_k_mask}\n  end\n\n  defnp calculate_iou(box_a, boxes_b) do\n    inter_x1 = Nx.max(box_a[0], boxes_b[[.., 0]])\n    inter_y1 = Nx.max(box_a[1], boxes_b[[.., 1]])\n    inter_x2 = Nx.min(box_a[2], boxes_b[[.., 2]])\n    inter_y2 = Nx.min(box_a[3], boxes_b[[.., 3]])\n\n    inter_w = Nx.max(0.0, inter_x2 - inter_x1)\n    inter_h = Nx.max(0.0, inter_y2 - inter_y1)\n    inter_area = inter_w * inter_h\n\n    area_a = (box_a[2] - box_a[0]) * (box_a[3] - box_a[1])\n    area_b = (boxes_b[[.., 2]] - boxes_b[[.., 0]]) * (boxes_b[[.., 3]] - boxes_b[[.., 1]])\n\n    union_area = area_a + area_b - inter_area\n    inter_area / (union_area + 1.0e-6)\n  end\nend\n",
      "skeleton": {
        "modules": [
          "SwarmBrain.Vision.Yolo.PostProcessor"
        ],
        "functions": [],
        "structs": [],
        "dependencies": [
          "Nx",
          "Nx.Defn"
        ],
        "complexity": 0,
        "doc": null
      }
    },
    {
      "path": "config/config.exs",
      "content": "import Config\n\n# We plug the module into the Cortex socket\nconfig :swarm_brain, :cortex_module, SwarmBrain.Cortex.Yolo\n\n# The Nixie-HP Webcam (VGA)\nconfig :swarm_brain, :vision,\n  width: 640,\n  height: 480,\n  framerate: 30\n\n# 1. Set the Default Backend to EXLA (XLA)\n# This forces Nx to use the compiled C++ backend (CPU or GPU)\nconfig :nx, :default_backend, EXLA.Backend\n\n# 2. Configure the Target\n# If you are on the INTEL laptop without an NVIDIA card:\nconfig :exla, :default_client, :host\n\n# \u26a0\ufe0f IF you manage to get an eGPU or NVIDIA card working later:\n# config :exla, :default_client, :cuda\n# config :exla, :clients,\n#   cuda: [platform: :cuda]\n\n# 3. CRDT Sync Interval\nconfig :delta_crdt, :sync_interval, 50 # Sync fast (50ms) for flight data\n\n# --- [NEW] HIVE DISCOVERY PROTOCOL ---\nconfig :libcluster,\n  topologies: [\n    swarm_gossip: [\n      # UDP Multicast: No central server needed.\n      # Works on local WiFi/Mesh networks immediately.\n      strategy: Cluster.Strategy.Gossip,\n      config: [\n        port: 45892,\n        if_addr: \"0.0.0.0\",\n        multicast_addr: \"230.1.1.251\",\n        # Set to true if multicast is blocked on your router,\n        # but usually false is better for true mesh.\n        broadcast_only: false\n      ]\n    ]\n  ]\n\n# Hardware Interface\n# Set to \"/dev/ttyUSB0\" or \"/dev/ttyTHS1\" when on the drone.\n# Set to nil to force Simulation Mode on Laptop.\nconfig :swarm_brain, :fc_port, nil\n\n# RL Actor Configuration\nconfig :swarm_brain, :actor,\n  model_path: \"priv/actor_policy.axon\",\n  input_shape: 11\n"
    }
  ]
}
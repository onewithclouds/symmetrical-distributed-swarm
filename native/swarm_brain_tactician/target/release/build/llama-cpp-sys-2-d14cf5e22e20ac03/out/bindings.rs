/* automatically generated by rust-bindgen 0.72.1 */

pub type __off_t = :: std :: os :: raw :: c_long ; pub type __off64_t = :: std :: os :: raw :: c_long ; pub type FILE = _IO_FILE ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _IO_marker { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _IO_codecvt { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _IO_wide_data { _unused : [u8 ; 0] , } pub type _IO_lock_t = :: std :: os :: raw :: c_void ; # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq)] pub struct _IO_FILE { pub _flags : :: std :: os :: raw :: c_int , pub _IO_read_ptr : * mut :: std :: os :: raw :: c_char , pub _IO_read_end : * mut :: std :: os :: raw :: c_char , pub _IO_read_base : * mut :: std :: os :: raw :: c_char , pub _IO_write_base : * mut :: std :: os :: raw :: c_char , pub _IO_write_ptr : * mut :: std :: os :: raw :: c_char , pub _IO_write_end : * mut :: std :: os :: raw :: c_char , pub _IO_buf_base : * mut :: std :: os :: raw :: c_char , pub _IO_buf_end : * mut :: std :: os :: raw :: c_char , pub _IO_save_base : * mut :: std :: os :: raw :: c_char , pub _IO_backup_base : * mut :: std :: os :: raw :: c_char , pub _IO_save_end : * mut :: std :: os :: raw :: c_char , pub _markers : * mut _IO_marker , pub _chain : * mut _IO_FILE , pub _fileno : :: std :: os :: raw :: c_int , pub _flags2 : :: std :: os :: raw :: c_int , pub _old_offset : __off_t , pub _cur_column : :: std :: os :: raw :: c_ushort , pub _vtable_offset : :: std :: os :: raw :: c_schar , pub _shortbuf : [:: std :: os :: raw :: c_char ; 1usize] , pub _lock : * mut _IO_lock_t , pub _offset : __off64_t , pub _codecvt : * mut _IO_codecvt , pub _wide_data : * mut _IO_wide_data , pub _freeres_list : * mut _IO_FILE , pub _freeres_buf : * mut :: std :: os :: raw :: c_void , pub _prevchain : * mut * mut _IO_FILE , pub _mode : :: std :: os :: raw :: c_int , pub _unused2 : [:: std :: os :: raw :: c_char ; 20usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of _IO_FILE"] [:: std :: mem :: size_of :: < _IO_FILE > () - 216usize] ; ["Alignment of _IO_FILE"] [:: std :: mem :: align_of :: < _IO_FILE > () - 8usize] ; ["Offset of field: _IO_FILE::_flags"] [:: std :: mem :: offset_of ! (_IO_FILE , _flags) - 0usize] ; ["Offset of field: _IO_FILE::_IO_read_ptr"] [:: std :: mem :: offset_of ! (_IO_FILE , _IO_read_ptr) - 8usize] ; ["Offset of field: _IO_FILE::_IO_read_end"] [:: std :: mem :: offset_of ! (_IO_FILE , _IO_read_end) - 16usize] ; ["Offset of field: _IO_FILE::_IO_read_base"] [:: std :: mem :: offset_of ! (_IO_FILE , _IO_read_base) - 24usize] ; ["Offset of field: _IO_FILE::_IO_write_base"] [:: std :: mem :: offset_of ! (_IO_FILE , _IO_write_base) - 32usize] ; ["Offset of field: _IO_FILE::_IO_write_ptr"] [:: std :: mem :: offset_of ! (_IO_FILE , _IO_write_ptr) - 40usize] ; ["Offset of field: _IO_FILE::_IO_write_end"] [:: std :: mem :: offset_of ! (_IO_FILE , _IO_write_end) - 48usize] ; ["Offset of field: _IO_FILE::_IO_buf_base"] [:: std :: mem :: offset_of ! (_IO_FILE , _IO_buf_base) - 56usize] ; ["Offset of field: _IO_FILE::_IO_buf_end"] [:: std :: mem :: offset_of ! (_IO_FILE , _IO_buf_end) - 64usize] ; ["Offset of field: _IO_FILE::_IO_save_base"] [:: std :: mem :: offset_of ! (_IO_FILE , _IO_save_base) - 72usize] ; ["Offset of field: _IO_FILE::_IO_backup_base"] [:: std :: mem :: offset_of ! (_IO_FILE , _IO_backup_base) - 80usize] ; ["Offset of field: _IO_FILE::_IO_save_end"] [:: std :: mem :: offset_of ! (_IO_FILE , _IO_save_end) - 88usize] ; ["Offset of field: _IO_FILE::_markers"] [:: std :: mem :: offset_of ! (_IO_FILE , _markers) - 96usize] ; ["Offset of field: _IO_FILE::_chain"] [:: std :: mem :: offset_of ! (_IO_FILE , _chain) - 104usize] ; ["Offset of field: _IO_FILE::_fileno"] [:: std :: mem :: offset_of ! (_IO_FILE , _fileno) - 112usize] ; ["Offset of field: _IO_FILE::_flags2"] [:: std :: mem :: offset_of ! (_IO_FILE , _flags2) - 116usize] ; ["Offset of field: _IO_FILE::_old_offset"] [:: std :: mem :: offset_of ! (_IO_FILE , _old_offset) - 120usize] ; ["Offset of field: _IO_FILE::_cur_column"] [:: std :: mem :: offset_of ! (_IO_FILE , _cur_column) - 128usize] ; ["Offset of field: _IO_FILE::_vtable_offset"] [:: std :: mem :: offset_of ! (_IO_FILE , _vtable_offset) - 130usize] ; ["Offset of field: _IO_FILE::_shortbuf"] [:: std :: mem :: offset_of ! (_IO_FILE , _shortbuf) - 131usize] ; ["Offset of field: _IO_FILE::_lock"] [:: std :: mem :: offset_of ! (_IO_FILE , _lock) - 136usize] ; ["Offset of field: _IO_FILE::_offset"] [:: std :: mem :: offset_of ! (_IO_FILE , _offset) - 144usize] ; ["Offset of field: _IO_FILE::_codecvt"] [:: std :: mem :: offset_of ! (_IO_FILE , _codecvt) - 152usize] ; ["Offset of field: _IO_FILE::_wide_data"] [:: std :: mem :: offset_of ! (_IO_FILE , _wide_data) - 160usize] ; ["Offset of field: _IO_FILE::_freeres_list"] [:: std :: mem :: offset_of ! (_IO_FILE , _freeres_list) - 168usize] ; ["Offset of field: _IO_FILE::_freeres_buf"] [:: std :: mem :: offset_of ! (_IO_FILE , _freeres_buf) - 176usize] ; ["Offset of field: _IO_FILE::_prevchain"] [:: std :: mem :: offset_of ! (_IO_FILE , _prevchain) - 184usize] ; ["Offset of field: _IO_FILE::_mode"] [:: std :: mem :: offset_of ! (_IO_FILE , _mode) - 192usize] ; ["Offset of field: _IO_FILE::_unused2"] [:: std :: mem :: offset_of ! (_IO_FILE , _unused2) - 196usize] ; } ; pub type ggml_abort_callback_t = :: std :: option :: Option < unsafe extern "C" fn (error_message : * const :: std :: os :: raw :: c_char) > ; unsafe extern "C" { pub fn ggml_set_abort_callback (callback : ggml_abort_callback_t) -> ggml_abort_callback_t ; } unsafe extern "C" { pub fn ggml_abort (file : * const :: std :: os :: raw :: c_char , line : :: std :: os :: raw :: c_int , fmt : * const :: std :: os :: raw :: c_char , ...) ; } pub const GGML_STATUS_ALLOC_FAILED : ggml_status = - 2 ; pub const GGML_STATUS_FAILED : ggml_status = - 1 ; pub const GGML_STATUS_SUCCESS : ggml_status = 0 ; pub const GGML_STATUS_ABORTED : ggml_status = 1 ; pub type ggml_status = :: std :: os :: raw :: c_int ; unsafe extern "C" { pub fn ggml_status_to_string (status : ggml_status) -> * const :: std :: os :: raw :: c_char ; } pub type ggml_fp16_t = u16 ; unsafe extern "C" { pub fn ggml_fp16_to_fp32 (arg1 : ggml_fp16_t) -> f32 ; } unsafe extern "C" { pub fn ggml_fp32_to_fp16 (arg1 : f32) -> ggml_fp16_t ; } unsafe extern "C" { pub fn ggml_fp16_to_fp32_row (arg1 : * const ggml_fp16_t , arg2 : * mut f32 , arg3 : i64) ; } unsafe extern "C" { pub fn ggml_fp32_to_fp16_row (arg1 : * const f32 , arg2 : * mut ggml_fp16_t , arg3 : i64) ; } # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq)] pub struct ggml_bf16_t { pub bits : u16 , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of ggml_bf16_t"] [:: std :: mem :: size_of :: < ggml_bf16_t > () - 2usize] ; ["Alignment of ggml_bf16_t"] [:: std :: mem :: align_of :: < ggml_bf16_t > () - 2usize] ; ["Offset of field: ggml_bf16_t::bits"] [:: std :: mem :: offset_of ! (ggml_bf16_t , bits) - 0usize] ; } ; unsafe extern "C" { pub fn ggml_fp32_to_bf16 (arg1 : f32) -> ggml_bf16_t ; } unsafe extern "C" { pub fn ggml_bf16_to_fp32 (arg1 : ggml_bf16_t) -> f32 ; } unsafe extern "C" { pub fn ggml_bf16_to_fp32_row (arg1 : * const ggml_bf16_t , arg2 : * mut f32 , arg3 : i64) ; } unsafe extern "C" { pub fn ggml_fp32_to_bf16_row_ref (arg1 : * const f32 , arg2 : * mut ggml_bf16_t , arg3 : i64) ; } unsafe extern "C" { pub fn ggml_fp32_to_bf16_row (arg1 : * const f32 , arg2 : * mut ggml_bf16_t , arg3 : i64) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ggml_object { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ggml_context { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ggml_cgraph { _unused : [u8 ; 0] , } pub const GGML_TYPE_F32 : ggml_type = 0 ; pub const GGML_TYPE_F16 : ggml_type = 1 ; pub const GGML_TYPE_Q4_0 : ggml_type = 2 ; pub const GGML_TYPE_Q4_1 : ggml_type = 3 ; pub const GGML_TYPE_Q5_0 : ggml_type = 6 ; pub const GGML_TYPE_Q5_1 : ggml_type = 7 ; pub const GGML_TYPE_Q8_0 : ggml_type = 8 ; pub const GGML_TYPE_Q8_1 : ggml_type = 9 ; pub const GGML_TYPE_Q2_K : ggml_type = 10 ; pub const GGML_TYPE_Q3_K : ggml_type = 11 ; pub const GGML_TYPE_Q4_K : ggml_type = 12 ; pub const GGML_TYPE_Q5_K : ggml_type = 13 ; pub const GGML_TYPE_Q6_K : ggml_type = 14 ; pub const GGML_TYPE_Q8_K : ggml_type = 15 ; pub const GGML_TYPE_IQ2_XXS : ggml_type = 16 ; pub const GGML_TYPE_IQ2_XS : ggml_type = 17 ; pub const GGML_TYPE_IQ3_XXS : ggml_type = 18 ; pub const GGML_TYPE_IQ1_S : ggml_type = 19 ; pub const GGML_TYPE_IQ4_NL : ggml_type = 20 ; pub const GGML_TYPE_IQ3_S : ggml_type = 21 ; pub const GGML_TYPE_IQ2_S : ggml_type = 22 ; pub const GGML_TYPE_IQ4_XS : ggml_type = 23 ; pub const GGML_TYPE_I8 : ggml_type = 24 ; pub const GGML_TYPE_I16 : ggml_type = 25 ; pub const GGML_TYPE_I32 : ggml_type = 26 ; pub const GGML_TYPE_I64 : ggml_type = 27 ; pub const GGML_TYPE_F64 : ggml_type = 28 ; pub const GGML_TYPE_IQ1_M : ggml_type = 29 ; pub const GGML_TYPE_BF16 : ggml_type = 30 ; pub const GGML_TYPE_TQ1_0 : ggml_type = 34 ; pub const GGML_TYPE_TQ2_0 : ggml_type = 35 ; pub const GGML_TYPE_MXFP4 : ggml_type = 39 ; pub const GGML_TYPE_COUNT : ggml_type = 40 ; pub type ggml_type = :: std :: os :: raw :: c_uint ; pub const GGML_PREC_DEFAULT : ggml_prec = 0 ; pub const GGML_PREC_F32 : ggml_prec = 10 ; pub type ggml_prec = :: std :: os :: raw :: c_uint ; pub const GGML_FTYPE_UNKNOWN : ggml_ftype = - 1 ; pub const GGML_FTYPE_ALL_F32 : ggml_ftype = 0 ; pub const GGML_FTYPE_MOSTLY_F16 : ggml_ftype = 1 ; pub const GGML_FTYPE_MOSTLY_Q4_0 : ggml_ftype = 2 ; pub const GGML_FTYPE_MOSTLY_Q4_1 : ggml_ftype = 3 ; pub const GGML_FTYPE_MOSTLY_Q4_1_SOME_F16 : ggml_ftype = 4 ; pub const GGML_FTYPE_MOSTLY_Q8_0 : ggml_ftype = 7 ; pub const GGML_FTYPE_MOSTLY_Q5_0 : ggml_ftype = 8 ; pub const GGML_FTYPE_MOSTLY_Q5_1 : ggml_ftype = 9 ; pub const GGML_FTYPE_MOSTLY_Q2_K : ggml_ftype = 10 ; pub const GGML_FTYPE_MOSTLY_Q3_K : ggml_ftype = 11 ; pub const GGML_FTYPE_MOSTLY_Q4_K : ggml_ftype = 12 ; pub const GGML_FTYPE_MOSTLY_Q5_K : ggml_ftype = 13 ; pub const GGML_FTYPE_MOSTLY_Q6_K : ggml_ftype = 14 ; pub const GGML_FTYPE_MOSTLY_IQ2_XXS : ggml_ftype = 15 ; pub const GGML_FTYPE_MOSTLY_IQ2_XS : ggml_ftype = 16 ; pub const GGML_FTYPE_MOSTLY_IQ3_XXS : ggml_ftype = 17 ; pub const GGML_FTYPE_MOSTLY_IQ1_S : ggml_ftype = 18 ; pub const GGML_FTYPE_MOSTLY_IQ4_NL : ggml_ftype = 19 ; pub const GGML_FTYPE_MOSTLY_IQ3_S : ggml_ftype = 20 ; pub const GGML_FTYPE_MOSTLY_IQ2_S : ggml_ftype = 21 ; pub const GGML_FTYPE_MOSTLY_IQ4_XS : ggml_ftype = 22 ; pub const GGML_FTYPE_MOSTLY_IQ1_M : ggml_ftype = 23 ; pub const GGML_FTYPE_MOSTLY_BF16 : ggml_ftype = 24 ; pub const GGML_FTYPE_MOSTLY_MXFP4 : ggml_ftype = 25 ; pub type ggml_ftype = :: std :: os :: raw :: c_int ; pub const GGML_OP_NONE : ggml_op = 0 ; pub const GGML_OP_DUP : ggml_op = 1 ; pub const GGML_OP_ADD : ggml_op = 2 ; pub const GGML_OP_ADD_ID : ggml_op = 3 ; pub const GGML_OP_ADD1 : ggml_op = 4 ; pub const GGML_OP_ACC : ggml_op = 5 ; pub const GGML_OP_SUB : ggml_op = 6 ; pub const GGML_OP_MUL : ggml_op = 7 ; pub const GGML_OP_DIV : ggml_op = 8 ; pub const GGML_OP_SQR : ggml_op = 9 ; pub const GGML_OP_SQRT : ggml_op = 10 ; pub const GGML_OP_LOG : ggml_op = 11 ; pub const GGML_OP_SIN : ggml_op = 12 ; pub const GGML_OP_COS : ggml_op = 13 ; pub const GGML_OP_SUM : ggml_op = 14 ; pub const GGML_OP_SUM_ROWS : ggml_op = 15 ; pub const GGML_OP_CUMSUM : ggml_op = 16 ; pub const GGML_OP_MEAN : ggml_op = 17 ; pub const GGML_OP_ARGMAX : ggml_op = 18 ; pub const GGML_OP_COUNT_EQUAL : ggml_op = 19 ; pub const GGML_OP_REPEAT : ggml_op = 20 ; pub const GGML_OP_REPEAT_BACK : ggml_op = 21 ; pub const GGML_OP_CONCAT : ggml_op = 22 ; pub const GGML_OP_SILU_BACK : ggml_op = 23 ; pub const GGML_OP_NORM : ggml_op = 24 ; pub const GGML_OP_RMS_NORM : ggml_op = 25 ; pub const GGML_OP_RMS_NORM_BACK : ggml_op = 26 ; pub const GGML_OP_GROUP_NORM : ggml_op = 27 ; pub const GGML_OP_L2_NORM : ggml_op = 28 ; pub const GGML_OP_MUL_MAT : ggml_op = 29 ; pub const GGML_OP_MUL_MAT_ID : ggml_op = 30 ; pub const GGML_OP_OUT_PROD : ggml_op = 31 ; pub const GGML_OP_SCALE : ggml_op = 32 ; pub const GGML_OP_SET : ggml_op = 33 ; pub const GGML_OP_CPY : ggml_op = 34 ; pub const GGML_OP_CONT : ggml_op = 35 ; pub const GGML_OP_RESHAPE : ggml_op = 36 ; pub const GGML_OP_VIEW : ggml_op = 37 ; pub const GGML_OP_PERMUTE : ggml_op = 38 ; pub const GGML_OP_TRANSPOSE : ggml_op = 39 ; pub const GGML_OP_GET_ROWS : ggml_op = 40 ; pub const GGML_OP_GET_ROWS_BACK : ggml_op = 41 ; pub const GGML_OP_SET_ROWS : ggml_op = 42 ; pub const GGML_OP_DIAG : ggml_op = 43 ; pub const GGML_OP_DIAG_MASK_INF : ggml_op = 44 ; pub const GGML_OP_DIAG_MASK_ZERO : ggml_op = 45 ; pub const GGML_OP_SOFT_MAX : ggml_op = 46 ; pub const GGML_OP_SOFT_MAX_BACK : ggml_op = 47 ; pub const GGML_OP_ROPE : ggml_op = 48 ; pub const GGML_OP_ROPE_BACK : ggml_op = 49 ; pub const GGML_OP_CLAMP : ggml_op = 50 ; pub const GGML_OP_CONV_TRANSPOSE_1D : ggml_op = 51 ; pub const GGML_OP_IM2COL : ggml_op = 52 ; pub const GGML_OP_IM2COL_BACK : ggml_op = 53 ; pub const GGML_OP_IM2COL_3D : ggml_op = 54 ; pub const GGML_OP_CONV_2D : ggml_op = 55 ; pub const GGML_OP_CONV_3D : ggml_op = 56 ; pub const GGML_OP_CONV_2D_DW : ggml_op = 57 ; pub const GGML_OP_CONV_TRANSPOSE_2D : ggml_op = 58 ; pub const GGML_OP_POOL_1D : ggml_op = 59 ; pub const GGML_OP_POOL_2D : ggml_op = 60 ; pub const GGML_OP_POOL_2D_BACK : ggml_op = 61 ; pub const GGML_OP_UPSCALE : ggml_op = 62 ; pub const GGML_OP_PAD : ggml_op = 63 ; pub const GGML_OP_PAD_REFLECT_1D : ggml_op = 64 ; pub const GGML_OP_ROLL : ggml_op = 65 ; pub const GGML_OP_ARANGE : ggml_op = 66 ; pub const GGML_OP_TIMESTEP_EMBEDDING : ggml_op = 67 ; pub const GGML_OP_ARGSORT : ggml_op = 68 ; pub const GGML_OP_TOP_K : ggml_op = 69 ; pub const GGML_OP_LEAKY_RELU : ggml_op = 70 ; pub const GGML_OP_TRI : ggml_op = 71 ; pub const GGML_OP_FILL : ggml_op = 72 ; pub const GGML_OP_FLASH_ATTN_EXT : ggml_op = 73 ; pub const GGML_OP_FLASH_ATTN_BACK : ggml_op = 74 ; pub const GGML_OP_SSM_CONV : ggml_op = 75 ; pub const GGML_OP_SSM_SCAN : ggml_op = 76 ; pub const GGML_OP_WIN_PART : ggml_op = 77 ; pub const GGML_OP_WIN_UNPART : ggml_op = 78 ; pub const GGML_OP_GET_REL_POS : ggml_op = 79 ; pub const GGML_OP_ADD_REL_POS : ggml_op = 80 ; pub const GGML_OP_RWKV_WKV6 : ggml_op = 81 ; pub const GGML_OP_GATED_LINEAR_ATTN : ggml_op = 82 ; pub const GGML_OP_RWKV_WKV7 : ggml_op = 83 ; pub const GGML_OP_SOLVE_TRI : ggml_op = 84 ; pub const GGML_OP_UNARY : ggml_op = 85 ; pub const GGML_OP_MAP_CUSTOM1 : ggml_op = 86 ; pub const GGML_OP_MAP_CUSTOM2 : ggml_op = 87 ; pub const GGML_OP_MAP_CUSTOM3 : ggml_op = 88 ; pub const GGML_OP_CUSTOM : ggml_op = 89 ; pub const GGML_OP_CROSS_ENTROPY_LOSS : ggml_op = 90 ; pub const GGML_OP_CROSS_ENTROPY_LOSS_BACK : ggml_op = 91 ; pub const GGML_OP_OPT_STEP_ADAMW : ggml_op = 92 ; pub const GGML_OP_OPT_STEP_SGD : ggml_op = 93 ; pub const GGML_OP_GLU : ggml_op = 94 ; pub const GGML_OP_COUNT : ggml_op = 95 ; pub type ggml_op = :: std :: os :: raw :: c_uint ; pub const GGML_UNARY_OP_ABS : ggml_unary_op = 0 ; pub const GGML_UNARY_OP_SGN : ggml_unary_op = 1 ; pub const GGML_UNARY_OP_NEG : ggml_unary_op = 2 ; pub const GGML_UNARY_OP_STEP : ggml_unary_op = 3 ; pub const GGML_UNARY_OP_TANH : ggml_unary_op = 4 ; pub const GGML_UNARY_OP_ELU : ggml_unary_op = 5 ; pub const GGML_UNARY_OP_RELU : ggml_unary_op = 6 ; pub const GGML_UNARY_OP_SIGMOID : ggml_unary_op = 7 ; pub const GGML_UNARY_OP_GELU : ggml_unary_op = 8 ; pub const GGML_UNARY_OP_GELU_QUICK : ggml_unary_op = 9 ; pub const GGML_UNARY_OP_SILU : ggml_unary_op = 10 ; pub const GGML_UNARY_OP_HARDSWISH : ggml_unary_op = 11 ; pub const GGML_UNARY_OP_HARDSIGMOID : ggml_unary_op = 12 ; pub const GGML_UNARY_OP_EXP : ggml_unary_op = 13 ; pub const GGML_UNARY_OP_EXPM1 : ggml_unary_op = 14 ; pub const GGML_UNARY_OP_SOFTPLUS : ggml_unary_op = 15 ; pub const GGML_UNARY_OP_GELU_ERF : ggml_unary_op = 16 ; pub const GGML_UNARY_OP_XIELU : ggml_unary_op = 17 ; pub const GGML_UNARY_OP_FLOOR : ggml_unary_op = 18 ; pub const GGML_UNARY_OP_CEIL : ggml_unary_op = 19 ; pub const GGML_UNARY_OP_ROUND : ggml_unary_op = 20 ; pub const GGML_UNARY_OP_TRUNC : ggml_unary_op = 21 ; pub const GGML_UNARY_OP_COUNT : ggml_unary_op = 22 ; pub type ggml_unary_op = :: std :: os :: raw :: c_uint ; pub const GGML_GLU_OP_REGLU : ggml_glu_op = 0 ; pub const GGML_GLU_OP_GEGLU : ggml_glu_op = 1 ; pub const GGML_GLU_OP_SWIGLU : ggml_glu_op = 2 ; pub const GGML_GLU_OP_SWIGLU_OAI : ggml_glu_op = 3 ; pub const GGML_GLU_OP_GEGLU_ERF : ggml_glu_op = 4 ; pub const GGML_GLU_OP_GEGLU_QUICK : ggml_glu_op = 5 ; pub const GGML_GLU_OP_COUNT : ggml_glu_op = 6 ; pub type ggml_glu_op = :: std :: os :: raw :: c_uint ; pub const GGML_OBJECT_TYPE_TENSOR : ggml_object_type = 0 ; pub const GGML_OBJECT_TYPE_GRAPH : ggml_object_type = 1 ; pub const GGML_OBJECT_TYPE_WORK_BUFFER : ggml_object_type = 2 ; pub type ggml_object_type = :: std :: os :: raw :: c_uint ; pub const GGML_LOG_LEVEL_NONE : ggml_log_level = 0 ; pub const GGML_LOG_LEVEL_DEBUG : ggml_log_level = 1 ; pub const GGML_LOG_LEVEL_INFO : ggml_log_level = 2 ; pub const GGML_LOG_LEVEL_WARN : ggml_log_level = 3 ; pub const GGML_LOG_LEVEL_ERROR : ggml_log_level = 4 ; pub const GGML_LOG_LEVEL_CONT : ggml_log_level = 5 ; pub type ggml_log_level = :: std :: os :: raw :: c_uint ; pub const GGML_TENSOR_FLAG_INPUT : ggml_tensor_flag = 1 ; pub const GGML_TENSOR_FLAG_OUTPUT : ggml_tensor_flag = 2 ; pub const GGML_TENSOR_FLAG_PARAM : ggml_tensor_flag = 4 ; pub const GGML_TENSOR_FLAG_LOSS : ggml_tensor_flag = 8 ; pub type ggml_tensor_flag = :: std :: os :: raw :: c_uint ; pub const GGML_TRI_TYPE_UPPER_DIAG : ggml_tri_type = 0 ; pub const GGML_TRI_TYPE_UPPER : ggml_tri_type = 1 ; pub const GGML_TRI_TYPE_LOWER_DIAG : ggml_tri_type = 2 ; pub const GGML_TRI_TYPE_LOWER : ggml_tri_type = 3 ; pub type ggml_tri_type = :: std :: os :: raw :: c_uint ; # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq)] pub struct ggml_init_params { pub mem_size : usize , pub mem_buffer : * mut :: std :: os :: raw :: c_void , pub no_alloc : bool , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of ggml_init_params"] [:: std :: mem :: size_of :: < ggml_init_params > () - 24usize] ; ["Alignment of ggml_init_params"] [:: std :: mem :: align_of :: < ggml_init_params > () - 8usize] ; ["Offset of field: ggml_init_params::mem_size"] [:: std :: mem :: offset_of ! (ggml_init_params , mem_size) - 0usize] ; ["Offset of field: ggml_init_params::mem_buffer"] [:: std :: mem :: offset_of ! (ggml_init_params , mem_buffer) - 8usize] ; ["Offset of field: ggml_init_params::no_alloc"] [:: std :: mem :: offset_of ! (ggml_init_params , no_alloc) - 16usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq)] pub struct ggml_tensor { pub type_ : ggml_type , pub buffer : * mut ggml_backend_buffer , pub ne : [i64 ; 4usize] , pub nb : [usize ; 4usize] , pub op : ggml_op , pub op_params : [i32 ; 16usize] , pub flags : i32 , pub src : [* mut ggml_tensor ; 10usize] , pub view_src : * mut ggml_tensor , pub view_offs : usize , pub data : * mut :: std :: os :: raw :: c_void , pub name : [:: std :: os :: raw :: c_char ; 64usize] , pub extra : * mut :: std :: os :: raw :: c_void , pub padding : [:: std :: os :: raw :: c_char ; 8usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of ggml_tensor"] [:: std :: mem :: size_of :: < ggml_tensor > () - 336usize] ; ["Alignment of ggml_tensor"] [:: std :: mem :: align_of :: < ggml_tensor > () - 8usize] ; ["Offset of field: ggml_tensor::type_"] [:: std :: mem :: offset_of ! (ggml_tensor , type_) - 0usize] ; ["Offset of field: ggml_tensor::buffer"] [:: std :: mem :: offset_of ! (ggml_tensor , buffer) - 8usize] ; ["Offset of field: ggml_tensor::ne"] [:: std :: mem :: offset_of ! (ggml_tensor , ne) - 16usize] ; ["Offset of field: ggml_tensor::nb"] [:: std :: mem :: offset_of ! (ggml_tensor , nb) - 48usize] ; ["Offset of field: ggml_tensor::op"] [:: std :: mem :: offset_of ! (ggml_tensor , op) - 80usize] ; ["Offset of field: ggml_tensor::op_params"] [:: std :: mem :: offset_of ! (ggml_tensor , op_params) - 84usize] ; ["Offset of field: ggml_tensor::flags"] [:: std :: mem :: offset_of ! (ggml_tensor , flags) - 148usize] ; ["Offset of field: ggml_tensor::src"] [:: std :: mem :: offset_of ! (ggml_tensor , src) - 152usize] ; ["Offset of field: ggml_tensor::view_src"] [:: std :: mem :: offset_of ! (ggml_tensor , view_src) - 232usize] ; ["Offset of field: ggml_tensor::view_offs"] [:: std :: mem :: offset_of ! (ggml_tensor , view_offs) - 240usize] ; ["Offset of field: ggml_tensor::data"] [:: std :: mem :: offset_of ! (ggml_tensor , data) - 248usize] ; ["Offset of field: ggml_tensor::name"] [:: std :: mem :: offset_of ! (ggml_tensor , name) - 256usize] ; ["Offset of field: ggml_tensor::extra"] [:: std :: mem :: offset_of ! (ggml_tensor , extra) - 320usize] ; ["Offset of field: ggml_tensor::padding"] [:: std :: mem :: offset_of ! (ggml_tensor , padding) - 328usize] ; } ; pub type ggml_abort_callback = :: std :: option :: Option < unsafe extern "C" fn (data : * mut :: std :: os :: raw :: c_void) -> bool > ; pub type ggml_guid = [u8 ; 16usize] ; pub type ggml_guid_t = * mut ggml_guid ; unsafe extern "C" { pub fn ggml_guid_matches (guid_a : ggml_guid_t , guid_b : ggml_guid_t) -> bool ; } unsafe extern "C" { pub fn ggml_version () -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn ggml_commit () -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn ggml_time_init () ; } unsafe extern "C" { pub fn ggml_time_ms () -> i64 ; } unsafe extern "C" { pub fn ggml_time_us () -> i64 ; } unsafe extern "C" { pub fn ggml_cycles () -> i64 ; } unsafe extern "C" { pub fn ggml_cycles_per_ms () -> i64 ; } unsafe extern "C" { pub fn ggml_fopen (fname : * const :: std :: os :: raw :: c_char , mode : * const :: std :: os :: raw :: c_char) -> * mut FILE ; } unsafe extern "C" { pub fn ggml_print_object (obj : * const ggml_object) ; } unsafe extern "C" { pub fn ggml_print_objects (ctx : * const ggml_context) ; } unsafe extern "C" { pub fn ggml_nelements (tensor : * const ggml_tensor) -> i64 ; } unsafe extern "C" { pub fn ggml_nrows (tensor : * const ggml_tensor) -> i64 ; } unsafe extern "C" { pub fn ggml_nbytes (tensor : * const ggml_tensor) -> usize ; } unsafe extern "C" { pub fn ggml_nbytes_pad (tensor : * const ggml_tensor) -> usize ; } unsafe extern "C" { pub fn ggml_blck_size (type_ : ggml_type) -> i64 ; } unsafe extern "C" { pub fn ggml_type_size (type_ : ggml_type) -> usize ; } unsafe extern "C" { pub fn ggml_row_size (type_ : ggml_type , ne : i64) -> usize ; } unsafe extern "C" { pub fn ggml_type_sizef (type_ : ggml_type) -> f64 ; } unsafe extern "C" { pub fn ggml_type_name (type_ : ggml_type) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn ggml_op_name (op : ggml_op) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn ggml_op_symbol (op : ggml_op) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn ggml_unary_op_name (op : ggml_unary_op) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn ggml_glu_op_name (op : ggml_glu_op) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn ggml_op_desc (t : * const ggml_tensor) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn ggml_element_size (tensor : * const ggml_tensor) -> usize ; } unsafe extern "C" { pub fn ggml_is_quantized (type_ : ggml_type) -> bool ; } unsafe extern "C" { pub fn ggml_ftype_to_ggml_type (ftype : ggml_ftype) -> ggml_type ; } unsafe extern "C" { pub fn ggml_is_transposed (tensor : * const ggml_tensor) -> bool ; } unsafe extern "C" { pub fn ggml_is_permuted (tensor : * const ggml_tensor) -> bool ; } unsafe extern "C" { pub fn ggml_is_empty (tensor : * const ggml_tensor) -> bool ; } unsafe extern "C" { pub fn ggml_is_scalar (tensor : * const ggml_tensor) -> bool ; } unsafe extern "C" { pub fn ggml_is_vector (tensor : * const ggml_tensor) -> bool ; } unsafe extern "C" { pub fn ggml_is_matrix (tensor : * const ggml_tensor) -> bool ; } unsafe extern "C" { pub fn ggml_is_3d (tensor : * const ggml_tensor) -> bool ; } unsafe extern "C" { pub fn ggml_n_dims (tensor : * const ggml_tensor) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ggml_is_contiguous (tensor : * const ggml_tensor) -> bool ; } unsafe extern "C" { pub fn ggml_is_contiguous_0 (tensor : * const ggml_tensor) -> bool ; } unsafe extern "C" { pub fn ggml_is_contiguous_1 (tensor : * const ggml_tensor) -> bool ; } unsafe extern "C" { pub fn ggml_is_contiguous_2 (tensor : * const ggml_tensor) -> bool ; } unsafe extern "C" { pub fn ggml_is_contiguously_allocated (tensor : * const ggml_tensor) -> bool ; } unsafe extern "C" { pub fn ggml_is_contiguous_channels (tensor : * const ggml_tensor) -> bool ; } unsafe extern "C" { pub fn ggml_is_contiguous_rows (tensor : * const ggml_tensor) -> bool ; } unsafe extern "C" { pub fn ggml_are_same_shape (t0 : * const ggml_tensor , t1 : * const ggml_tensor) -> bool ; } unsafe extern "C" { pub fn ggml_are_same_stride (t0 : * const ggml_tensor , t1 : * const ggml_tensor) -> bool ; } unsafe extern "C" { pub fn ggml_can_repeat (t0 : * const ggml_tensor , t1 : * const ggml_tensor) -> bool ; } unsafe extern "C" { pub fn ggml_tensor_overhead () -> usize ; } unsafe extern "C" { pub fn ggml_validate_row_data (type_ : ggml_type , data : * const :: std :: os :: raw :: c_void , nbytes : usize) -> bool ; } unsafe extern "C" { pub fn ggml_init (params : ggml_init_params) -> * mut ggml_context ; } unsafe extern "C" { pub fn ggml_reset (ctx : * mut ggml_context) ; } unsafe extern "C" { pub fn ggml_free (ctx : * mut ggml_context) ; } unsafe extern "C" { pub fn ggml_used_mem (ctx : * const ggml_context) -> usize ; } unsafe extern "C" { pub fn ggml_get_no_alloc (ctx : * mut ggml_context) -> bool ; } unsafe extern "C" { pub fn ggml_set_no_alloc (ctx : * mut ggml_context , no_alloc : bool) ; } unsafe extern "C" { pub fn ggml_get_mem_buffer (ctx : * const ggml_context) -> * mut :: std :: os :: raw :: c_void ; } unsafe extern "C" { pub fn ggml_get_mem_size (ctx : * const ggml_context) -> usize ; } unsafe extern "C" { pub fn ggml_get_max_tensor_size (ctx : * const ggml_context) -> usize ; } unsafe extern "C" { pub fn ggml_new_tensor (ctx : * mut ggml_context , type_ : ggml_type , n_dims : :: std :: os :: raw :: c_int , ne : * const i64) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_new_tensor_1d (ctx : * mut ggml_context , type_ : ggml_type , ne0 : i64) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_new_tensor_2d (ctx : * mut ggml_context , type_ : ggml_type , ne0 : i64 , ne1 : i64) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_new_tensor_3d (ctx : * mut ggml_context , type_ : ggml_type , ne0 : i64 , ne1 : i64 , ne2 : i64) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_new_tensor_4d (ctx : * mut ggml_context , type_ : ggml_type , ne0 : i64 , ne1 : i64 , ne2 : i64 , ne3 : i64) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_new_buffer (ctx : * mut ggml_context , nbytes : usize) -> * mut :: std :: os :: raw :: c_void ; } unsafe extern "C" { pub fn ggml_dup_tensor (ctx : * mut ggml_context , src : * const ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_view_tensor (ctx : * mut ggml_context , src : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_get_first_tensor (ctx : * const ggml_context) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_get_next_tensor (ctx : * const ggml_context , tensor : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_get_tensor (ctx : * mut ggml_context , name : * const :: std :: os :: raw :: c_char) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_unravel_index (tensor : * const ggml_tensor , i : i64 , i0 : * mut i64 , i1 : * mut i64 , i2 : * mut i64 , i3 : * mut i64) ; } unsafe extern "C" { pub fn ggml_get_unary_op (tensor : * const ggml_tensor) -> ggml_unary_op ; } unsafe extern "C" { pub fn ggml_get_glu_op (tensor : * const ggml_tensor) -> ggml_glu_op ; } unsafe extern "C" { pub fn ggml_get_data (tensor : * const ggml_tensor) -> * mut :: std :: os :: raw :: c_void ; } unsafe extern "C" { pub fn ggml_get_data_f32 (tensor : * const ggml_tensor) -> * mut f32 ; } unsafe extern "C" { pub fn ggml_get_name (tensor : * const ggml_tensor) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn ggml_set_name (tensor : * mut ggml_tensor , name : * const :: std :: os :: raw :: c_char) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_format_name (tensor : * mut ggml_tensor , fmt : * const :: std :: os :: raw :: c_char , ...) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_set_input (tensor : * mut ggml_tensor) ; } unsafe extern "C" { pub fn ggml_set_output (tensor : * mut ggml_tensor) ; } unsafe extern "C" { pub fn ggml_set_param (tensor : * mut ggml_tensor) ; } unsafe extern "C" { pub fn ggml_set_loss (tensor : * mut ggml_tensor) ; } unsafe extern "C" { pub fn ggml_dup (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_dup_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_add (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_add_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_add_cast (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , type_ : ggml_type) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_add_id (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , ids : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_add1 (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_add1_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_acc (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , nb1 : usize , nb2 : usize , nb3 : usize , offset : usize) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_acc_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , nb1 : usize , nb2 : usize , nb3 : usize , offset : usize) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_sub (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_sub_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_mul (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_mul_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_div (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_div_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_sqr (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_sqr_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_sqrt (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_sqrt_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_log (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_log_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_expm1 (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_expm1_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_softplus (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_softplus_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_sin (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_sin_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_cos (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_cos_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_sum (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_sum_rows (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_cumsum (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_mean (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_argmax (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_count_equal (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_repeat (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_repeat_4d (ctx : * mut ggml_context , a : * mut ggml_tensor , ne0 : i64 , ne1 : i64 , ne2 : i64 , ne3 : i64) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_repeat_back (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_concat (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , dim : :: std :: os :: raw :: c_int) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_abs (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_abs_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_sgn (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_sgn_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_neg (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_neg_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_step (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_step_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_tanh (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_tanh_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_elu (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_elu_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_relu (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_leaky_relu (ctx : * mut ggml_context , a : * mut ggml_tensor , negative_slope : f32 , inplace : bool) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_relu_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_sigmoid (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_sigmoid_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_gelu (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_gelu_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_gelu_erf (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_gelu_erf_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_gelu_quick (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_gelu_quick_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_silu (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_silu_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_silu_back (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_hardswish (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_hardsigmoid (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_exp (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_exp_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_floor (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_floor_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_ceil (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_ceil_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_round (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_round_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { # [doc = " Truncates the fractional part of each element in the tensor (towards zero).\n For example: trunc(3.7) = 3.0, trunc(-2.9) = -2.0\n Similar to std::trunc in C/C++."] pub fn ggml_trunc (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_trunc_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_xielu (ctx : * mut ggml_context , a : * mut ggml_tensor , alpha_n : f32 , alpha_p : f32 , beta : f32 , eps : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_glu (ctx : * mut ggml_context , a : * mut ggml_tensor , op : ggml_glu_op , swapped : bool) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_reglu (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_reglu_swapped (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_geglu (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_geglu_swapped (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_swiglu (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_swiglu_swapped (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_geglu_erf (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_geglu_erf_swapped (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_geglu_quick (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_geglu_quick_swapped (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_glu_split (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , op : ggml_glu_op) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_reglu_split (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_geglu_split (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_swiglu_split (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_geglu_erf_split (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_geglu_quick_split (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_swiglu_oai (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , alpha : f32 , limit : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_norm (ctx : * mut ggml_context , a : * mut ggml_tensor , eps : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_norm_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor , eps : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_rms_norm (ctx : * mut ggml_context , a : * mut ggml_tensor , eps : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_rms_norm_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor , eps : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_group_norm (ctx : * mut ggml_context , a : * mut ggml_tensor , n_groups : :: std :: os :: raw :: c_int , eps : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_group_norm_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor , n_groups : :: std :: os :: raw :: c_int , eps : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_l2_norm (ctx : * mut ggml_context , a : * mut ggml_tensor , eps : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_l2_norm_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor , eps : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_rms_norm_back (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , eps : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_mul_mat (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_mul_mat_set_prec (a : * mut ggml_tensor , prec : ggml_prec) ; } unsafe extern "C" { pub fn ggml_mul_mat_id (ctx : * mut ggml_context , as_ : * mut ggml_tensor , b : * mut ggml_tensor , ids : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_out_prod (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_scale (ctx : * mut ggml_context , a : * mut ggml_tensor , s : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_scale_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor , s : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_scale_bias (ctx : * mut ggml_context , a : * mut ggml_tensor , s : f32 , b : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_scale_bias_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor , s : f32 , b : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_set (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , nb1 : usize , nb2 : usize , nb3 : usize , offset : usize) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_set_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , nb1 : usize , nb2 : usize , nb3 : usize , offset : usize) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_set_1d (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , offset : usize) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_set_1d_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , offset : usize) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_set_2d (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , nb1 : usize , offset : usize) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_set_2d_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , nb1 : usize , offset : usize) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_cpy (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_cast (ctx : * mut ggml_context , a : * mut ggml_tensor , type_ : ggml_type) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_cont (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_cont_1d (ctx : * mut ggml_context , a : * mut ggml_tensor , ne0 : i64) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_cont_2d (ctx : * mut ggml_context , a : * mut ggml_tensor , ne0 : i64 , ne1 : i64) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_cont_3d (ctx : * mut ggml_context , a : * mut ggml_tensor , ne0 : i64 , ne1 : i64 , ne2 : i64) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_cont_4d (ctx : * mut ggml_context , a : * mut ggml_tensor , ne0 : i64 , ne1 : i64 , ne2 : i64 , ne3 : i64) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_reshape (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_reshape_1d (ctx : * mut ggml_context , a : * mut ggml_tensor , ne0 : i64) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_reshape_2d (ctx : * mut ggml_context , a : * mut ggml_tensor , ne0 : i64 , ne1 : i64) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_reshape_3d (ctx : * mut ggml_context , a : * mut ggml_tensor , ne0 : i64 , ne1 : i64 , ne2 : i64) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_reshape_4d (ctx : * mut ggml_context , a : * mut ggml_tensor , ne0 : i64 , ne1 : i64 , ne2 : i64 , ne3 : i64) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_view_1d (ctx : * mut ggml_context , a : * mut ggml_tensor , ne0 : i64 , offset : usize) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_view_2d (ctx : * mut ggml_context , a : * mut ggml_tensor , ne0 : i64 , ne1 : i64 , nb1 : usize , offset : usize) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_view_3d (ctx : * mut ggml_context , a : * mut ggml_tensor , ne0 : i64 , ne1 : i64 , ne2 : i64 , nb1 : usize , nb2 : usize , offset : usize) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_view_4d (ctx : * mut ggml_context , a : * mut ggml_tensor , ne0 : i64 , ne1 : i64 , ne2 : i64 , ne3 : i64 , nb1 : usize , nb2 : usize , nb3 : usize , offset : usize) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_permute (ctx : * mut ggml_context , a : * mut ggml_tensor , axis0 : :: std :: os :: raw :: c_int , axis1 : :: std :: os :: raw :: c_int , axis2 : :: std :: os :: raw :: c_int , axis3 : :: std :: os :: raw :: c_int) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_transpose (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_get_rows (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_get_rows_back (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , c : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_set_rows (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , c : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_diag (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_diag_mask_inf (ctx : * mut ggml_context , a : * mut ggml_tensor , n_past : :: std :: os :: raw :: c_int) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_diag_mask_inf_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor , n_past : :: std :: os :: raw :: c_int) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_diag_mask_zero (ctx : * mut ggml_context , a : * mut ggml_tensor , n_past : :: std :: os :: raw :: c_int) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_diag_mask_zero_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor , n_past : :: std :: os :: raw :: c_int) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_soft_max (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_soft_max_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_soft_max_ext (ctx : * mut ggml_context , a : * mut ggml_tensor , mask : * mut ggml_tensor , scale : f32 , max_bias : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_soft_max_ext_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor , mask : * mut ggml_tensor , scale : f32 , max_bias : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_soft_max_add_sinks (a : * mut ggml_tensor , sinks : * mut ggml_tensor) ; } unsafe extern "C" { pub fn ggml_soft_max_ext_back (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , scale : f32 , max_bias : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_soft_max_ext_back_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , scale : f32 , max_bias : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_rope (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , n_dims : :: std :: os :: raw :: c_int , mode : :: std :: os :: raw :: c_int) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_rope_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , n_dims : :: std :: os :: raw :: c_int , mode : :: std :: os :: raw :: c_int) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_rope_ext (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , c : * mut ggml_tensor , n_dims : :: std :: os :: raw :: c_int , mode : :: std :: os :: raw :: c_int , n_ctx_orig : :: std :: os :: raw :: c_int , freq_base : f32 , freq_scale : f32 , ext_factor : f32 , attn_factor : f32 , beta_fast : f32 , beta_slow : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_rope_multi (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , c : * mut ggml_tensor , n_dims : :: std :: os :: raw :: c_int , sections : * mut :: std :: os :: raw :: c_int , mode : :: std :: os :: raw :: c_int , n_ctx_orig : :: std :: os :: raw :: c_int , freq_base : f32 , freq_scale : f32 , ext_factor : f32 , attn_factor : f32 , beta_fast : f32 , beta_slow : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_rope_ext_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , c : * mut ggml_tensor , n_dims : :: std :: os :: raw :: c_int , mode : :: std :: os :: raw :: c_int , n_ctx_orig : :: std :: os :: raw :: c_int , freq_base : f32 , freq_scale : f32 , ext_factor : f32 , attn_factor : f32 , beta_fast : f32 , beta_slow : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_rope_multi_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , c : * mut ggml_tensor , n_dims : :: std :: os :: raw :: c_int , sections : * mut :: std :: os :: raw :: c_int , mode : :: std :: os :: raw :: c_int , n_ctx_orig : :: std :: os :: raw :: c_int , freq_base : f32 , freq_scale : f32 , ext_factor : f32 , attn_factor : f32 , beta_fast : f32 , beta_slow : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_rope_custom (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , n_dims : :: std :: os :: raw :: c_int , mode : :: std :: os :: raw :: c_int , n_ctx_orig : :: std :: os :: raw :: c_int , freq_base : f32 , freq_scale : f32 , ext_factor : f32 , attn_factor : f32 , beta_fast : f32 , beta_slow : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_rope_custom_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , n_dims : :: std :: os :: raw :: c_int , mode : :: std :: os :: raw :: c_int , n_ctx_orig : :: std :: os :: raw :: c_int , freq_base : f32 , freq_scale : f32 , ext_factor : f32 , attn_factor : f32 , beta_fast : f32 , beta_slow : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_rope_yarn_corr_dims (n_dims : :: std :: os :: raw :: c_int , n_ctx_orig : :: std :: os :: raw :: c_int , freq_base : f32 , beta_fast : f32 , beta_slow : f32 , dims : * mut f32) ; } unsafe extern "C" { pub fn ggml_rope_ext_back (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , c : * mut ggml_tensor , n_dims : :: std :: os :: raw :: c_int , mode : :: std :: os :: raw :: c_int , n_ctx_orig : :: std :: os :: raw :: c_int , freq_base : f32 , freq_scale : f32 , ext_factor : f32 , attn_factor : f32 , beta_fast : f32 , beta_slow : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_rope_multi_back (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , c : * mut ggml_tensor , n_dims : :: std :: os :: raw :: c_int , sections : * mut :: std :: os :: raw :: c_int , mode : :: std :: os :: raw :: c_int , n_ctx_orig : :: std :: os :: raw :: c_int , freq_base : f32 , freq_scale : f32 , ext_factor : f32 , attn_factor : f32 , beta_fast : f32 , beta_slow : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_clamp (ctx : * mut ggml_context , a : * mut ggml_tensor , min : f32 , max : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_im2col (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , s0 : :: std :: os :: raw :: c_int , s1 : :: std :: os :: raw :: c_int , p0 : :: std :: os :: raw :: c_int , p1 : :: std :: os :: raw :: c_int , d0 : :: std :: os :: raw :: c_int , d1 : :: std :: os :: raw :: c_int , is_2D : bool , dst_type : ggml_type) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_im2col_back (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , ne : * mut i64 , s0 : :: std :: os :: raw :: c_int , s1 : :: std :: os :: raw :: c_int , p0 : :: std :: os :: raw :: c_int , p1 : :: std :: os :: raw :: c_int , d0 : :: std :: os :: raw :: c_int , d1 : :: std :: os :: raw :: c_int , is_2D : bool) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_conv_1d (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , s0 : :: std :: os :: raw :: c_int , p0 : :: std :: os :: raw :: c_int , d0 : :: std :: os :: raw :: c_int) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_conv_1d_ph (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , s : :: std :: os :: raw :: c_int , d : :: std :: os :: raw :: c_int) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_conv_1d_dw (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , s0 : :: std :: os :: raw :: c_int , p0 : :: std :: os :: raw :: c_int , d0 : :: std :: os :: raw :: c_int) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_conv_1d_dw_ph (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , s0 : :: std :: os :: raw :: c_int , d0 : :: std :: os :: raw :: c_int) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_conv_transpose_1d (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , s0 : :: std :: os :: raw :: c_int , p0 : :: std :: os :: raw :: c_int , d0 : :: std :: os :: raw :: c_int) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_conv_2d (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , s0 : :: std :: os :: raw :: c_int , s1 : :: std :: os :: raw :: c_int , p0 : :: std :: os :: raw :: c_int , p1 : :: std :: os :: raw :: c_int , d0 : :: std :: os :: raw :: c_int , d1 : :: std :: os :: raw :: c_int) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_im2col_3d (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , IC : i64 , s0 : :: std :: os :: raw :: c_int , s1 : :: std :: os :: raw :: c_int , s2 : :: std :: os :: raw :: c_int , p0 : :: std :: os :: raw :: c_int , p1 : :: std :: os :: raw :: c_int , p2 : :: std :: os :: raw :: c_int , d0 : :: std :: os :: raw :: c_int , d1 : :: std :: os :: raw :: c_int , d2 : :: std :: os :: raw :: c_int , dst_type : ggml_type) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_conv_3d (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , IC : i64 , s0 : :: std :: os :: raw :: c_int , s1 : :: std :: os :: raw :: c_int , s2 : :: std :: os :: raw :: c_int , p0 : :: std :: os :: raw :: c_int , p1 : :: std :: os :: raw :: c_int , p2 : :: std :: os :: raw :: c_int , d0 : :: std :: os :: raw :: c_int , d1 : :: std :: os :: raw :: c_int , d2 : :: std :: os :: raw :: c_int) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_conv_2d_sk_p0 (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_conv_2d_s1_ph (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_conv_2d_dw (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , s0 : :: std :: os :: raw :: c_int , s1 : :: std :: os :: raw :: c_int , p0 : :: std :: os :: raw :: c_int , p1 : :: std :: os :: raw :: c_int , d0 : :: std :: os :: raw :: c_int , d1 : :: std :: os :: raw :: c_int) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_conv_2d_dw_direct (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , stride0 : :: std :: os :: raw :: c_int , stride1 : :: std :: os :: raw :: c_int , pad0 : :: std :: os :: raw :: c_int , pad1 : :: std :: os :: raw :: c_int , dilation0 : :: std :: os :: raw :: c_int , dilation1 : :: std :: os :: raw :: c_int) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_conv_transpose_2d_p0 (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , stride : :: std :: os :: raw :: c_int) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_conv_2d_direct (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , s0 : :: std :: os :: raw :: c_int , s1 : :: std :: os :: raw :: c_int , p0 : :: std :: os :: raw :: c_int , p1 : :: std :: os :: raw :: c_int , d0 : :: std :: os :: raw :: c_int , d1 : :: std :: os :: raw :: c_int) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_conv_3d_direct (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , s0 : :: std :: os :: raw :: c_int , s1 : :: std :: os :: raw :: c_int , s2 : :: std :: os :: raw :: c_int , p0 : :: std :: os :: raw :: c_int , p1 : :: std :: os :: raw :: c_int , p2 : :: std :: os :: raw :: c_int , d0 : :: std :: os :: raw :: c_int , d1 : :: std :: os :: raw :: c_int , d2 : :: std :: os :: raw :: c_int , n_channels : :: std :: os :: raw :: c_int , n_batch : :: std :: os :: raw :: c_int , n_channels_out : :: std :: os :: raw :: c_int) -> * mut ggml_tensor ; } pub const GGML_OP_POOL_MAX : ggml_op_pool = 0 ; pub const GGML_OP_POOL_AVG : ggml_op_pool = 1 ; pub const GGML_OP_POOL_COUNT : ggml_op_pool = 2 ; pub type ggml_op_pool = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn ggml_pool_1d (ctx : * mut ggml_context , a : * mut ggml_tensor , op : ggml_op_pool , k0 : :: std :: os :: raw :: c_int , s0 : :: std :: os :: raw :: c_int , p0 : :: std :: os :: raw :: c_int) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_pool_2d (ctx : * mut ggml_context , a : * mut ggml_tensor , op : ggml_op_pool , k0 : :: std :: os :: raw :: c_int , k1 : :: std :: os :: raw :: c_int , s0 : :: std :: os :: raw :: c_int , s1 : :: std :: os :: raw :: c_int , p0 : f32 , p1 : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_pool_2d_back (ctx : * mut ggml_context , a : * mut ggml_tensor , af : * mut ggml_tensor , op : ggml_op_pool , k0 : :: std :: os :: raw :: c_int , k1 : :: std :: os :: raw :: c_int , s0 : :: std :: os :: raw :: c_int , s1 : :: std :: os :: raw :: c_int , p0 : f32 , p1 : f32) -> * mut ggml_tensor ; } pub const GGML_SCALE_MODE_NEAREST : ggml_scale_mode = 0 ; pub const GGML_SCALE_MODE_BILINEAR : ggml_scale_mode = 1 ; pub const GGML_SCALE_MODE_BICUBIC : ggml_scale_mode = 2 ; pub const GGML_SCALE_MODE_COUNT : ggml_scale_mode = 3 ; pub type ggml_scale_mode = :: std :: os :: raw :: c_uint ; pub const GGML_SCALE_FLAG_ALIGN_CORNERS : ggml_scale_flag = 256 ; pub const GGML_SCALE_FLAG_ANTIALIAS : ggml_scale_flag = 512 ; pub type ggml_scale_flag = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn ggml_upscale (ctx : * mut ggml_context , a : * mut ggml_tensor , scale_factor : :: std :: os :: raw :: c_int , mode : ggml_scale_mode) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_upscale_ext (ctx : * mut ggml_context , a : * mut ggml_tensor , ne0 : :: std :: os :: raw :: c_int , ne1 : :: std :: os :: raw :: c_int , ne2 : :: std :: os :: raw :: c_int , ne3 : :: std :: os :: raw :: c_int , mode : ggml_scale_mode) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_interpolate (ctx : * mut ggml_context , a : * mut ggml_tensor , ne0 : i64 , ne1 : i64 , ne2 : i64 , ne3 : i64 , mode : u32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_pad (ctx : * mut ggml_context , a : * mut ggml_tensor , p0 : :: std :: os :: raw :: c_int , p1 : :: std :: os :: raw :: c_int , p2 : :: std :: os :: raw :: c_int , p3 : :: std :: os :: raw :: c_int) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_pad_circular (ctx : * mut ggml_context , a : * mut ggml_tensor , p0 : :: std :: os :: raw :: c_int , p1 : :: std :: os :: raw :: c_int , p2 : :: std :: os :: raw :: c_int , p3 : :: std :: os :: raw :: c_int) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_pad_ext (ctx : * mut ggml_context , a : * mut ggml_tensor , lp0 : :: std :: os :: raw :: c_int , rp0 : :: std :: os :: raw :: c_int , lp1 : :: std :: os :: raw :: c_int , rp1 : :: std :: os :: raw :: c_int , lp2 : :: std :: os :: raw :: c_int , rp2 : :: std :: os :: raw :: c_int , lp3 : :: std :: os :: raw :: c_int , rp3 : :: std :: os :: raw :: c_int) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_pad_ext_circular (ctx : * mut ggml_context , a : * mut ggml_tensor , lp0 : :: std :: os :: raw :: c_int , rp0 : :: std :: os :: raw :: c_int , lp1 : :: std :: os :: raw :: c_int , rp1 : :: std :: os :: raw :: c_int , lp2 : :: std :: os :: raw :: c_int , rp2 : :: std :: os :: raw :: c_int , lp3 : :: std :: os :: raw :: c_int , rp3 : :: std :: os :: raw :: c_int) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_pad_reflect_1d (ctx : * mut ggml_context , a : * mut ggml_tensor , p0 : :: std :: os :: raw :: c_int , p1 : :: std :: os :: raw :: c_int) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_roll (ctx : * mut ggml_context , a : * mut ggml_tensor , shift0 : :: std :: os :: raw :: c_int , shift1 : :: std :: os :: raw :: c_int , shift2 : :: std :: os :: raw :: c_int , shift3 : :: std :: os :: raw :: c_int) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_tri (ctx : * mut ggml_context , a : * mut ggml_tensor , type_ : ggml_tri_type) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_fill (ctx : * mut ggml_context , a : * mut ggml_tensor , c : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_fill_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor , c : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_timestep_embedding (ctx : * mut ggml_context , timesteps : * mut ggml_tensor , dim : :: std :: os :: raw :: c_int , max_period : :: std :: os :: raw :: c_int) -> * mut ggml_tensor ; } pub const GGML_SORT_ORDER_ASC : ggml_sort_order = 0 ; pub const GGML_SORT_ORDER_DESC : ggml_sort_order = 1 ; pub type ggml_sort_order = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn ggml_argsort (ctx : * mut ggml_context , a : * mut ggml_tensor , order : ggml_sort_order) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_argsort_top_k (ctx : * mut ggml_context , a : * mut ggml_tensor , k : :: std :: os :: raw :: c_int) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_top_k (ctx : * mut ggml_context , a : * mut ggml_tensor , k : :: std :: os :: raw :: c_int) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_arange (ctx : * mut ggml_context , start : f32 , stop : f32 , step : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_flash_attn_ext (ctx : * mut ggml_context , q : * mut ggml_tensor , k : * mut ggml_tensor , v : * mut ggml_tensor , mask : * mut ggml_tensor , scale : f32 , max_bias : f32 , logit_softcap : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_flash_attn_ext_set_prec (a : * mut ggml_tensor , prec : ggml_prec) ; } unsafe extern "C" { pub fn ggml_flash_attn_ext_get_prec (a : * const ggml_tensor) -> ggml_prec ; } unsafe extern "C" { pub fn ggml_flash_attn_ext_add_sinks (a : * mut ggml_tensor , sinks : * mut ggml_tensor) ; } unsafe extern "C" { pub fn ggml_flash_attn_back (ctx : * mut ggml_context , q : * mut ggml_tensor , k : * mut ggml_tensor , v : * mut ggml_tensor , d : * mut ggml_tensor , masked : bool) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_ssm_conv (ctx : * mut ggml_context , sx : * mut ggml_tensor , c : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_ssm_scan (ctx : * mut ggml_context , s : * mut ggml_tensor , x : * mut ggml_tensor , dt : * mut ggml_tensor , A : * mut ggml_tensor , B : * mut ggml_tensor , C : * mut ggml_tensor , ids : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_win_part (ctx : * mut ggml_context , a : * mut ggml_tensor , w : :: std :: os :: raw :: c_int) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_win_unpart (ctx : * mut ggml_context , a : * mut ggml_tensor , w0 : :: std :: os :: raw :: c_int , h0 : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_unary (ctx : * mut ggml_context , a : * mut ggml_tensor , op : ggml_unary_op) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_unary_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor , op : ggml_unary_op) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_get_rel_pos (ctx : * mut ggml_context , a : * mut ggml_tensor , qh : :: std :: os :: raw :: c_int , kh : :: std :: os :: raw :: c_int) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_add_rel_pos (ctx : * mut ggml_context , a : * mut ggml_tensor , pw : * mut ggml_tensor , ph : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_add_rel_pos_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor , pw : * mut ggml_tensor , ph : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_rwkv_wkv6 (ctx : * mut ggml_context , k : * mut ggml_tensor , v : * mut ggml_tensor , r : * mut ggml_tensor , tf : * mut ggml_tensor , td : * mut ggml_tensor , state : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_gated_linear_attn (ctx : * mut ggml_context , k : * mut ggml_tensor , v : * mut ggml_tensor , q : * mut ggml_tensor , g : * mut ggml_tensor , state : * mut ggml_tensor , scale : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_rwkv_wkv7 (ctx : * mut ggml_context , r : * mut ggml_tensor , w : * mut ggml_tensor , k : * mut ggml_tensor , v : * mut ggml_tensor , a : * mut ggml_tensor , b : * mut ggml_tensor , state : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_solve_tri (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , left : bool , lower : bool , uni : bool) -> * mut ggml_tensor ; } pub type ggml_custom1_op_t = :: std :: option :: Option < unsafe extern "C" fn (dst : * mut ggml_tensor , a : * const ggml_tensor , ith : :: std :: os :: raw :: c_int , nth : :: std :: os :: raw :: c_int , userdata : * mut :: std :: os :: raw :: c_void) > ; pub type ggml_custom2_op_t = :: std :: option :: Option < unsafe extern "C" fn (dst : * mut ggml_tensor , a : * const ggml_tensor , b : * const ggml_tensor , ith : :: std :: os :: raw :: c_int , nth : :: std :: os :: raw :: c_int , userdata : * mut :: std :: os :: raw :: c_void) > ; pub type ggml_custom3_op_t = :: std :: option :: Option < unsafe extern "C" fn (dst : * mut ggml_tensor , a : * const ggml_tensor , b : * const ggml_tensor , c : * const ggml_tensor , ith : :: std :: os :: raw :: c_int , nth : :: std :: os :: raw :: c_int , userdata : * mut :: std :: os :: raw :: c_void) > ; unsafe extern "C" { pub fn ggml_map_custom1 (ctx : * mut ggml_context , a : * mut ggml_tensor , fun : ggml_custom1_op_t , n_tasks : :: std :: os :: raw :: c_int , userdata : * mut :: std :: os :: raw :: c_void) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_map_custom1_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor , fun : ggml_custom1_op_t , n_tasks : :: std :: os :: raw :: c_int , userdata : * mut :: std :: os :: raw :: c_void) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_map_custom2 (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , fun : ggml_custom2_op_t , n_tasks : :: std :: os :: raw :: c_int , userdata : * mut :: std :: os :: raw :: c_void) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_map_custom2_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , fun : ggml_custom2_op_t , n_tasks : :: std :: os :: raw :: c_int , userdata : * mut :: std :: os :: raw :: c_void) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_map_custom3 (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , c : * mut ggml_tensor , fun : ggml_custom3_op_t , n_tasks : :: std :: os :: raw :: c_int , userdata : * mut :: std :: os :: raw :: c_void) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_map_custom3_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , c : * mut ggml_tensor , fun : ggml_custom3_op_t , n_tasks : :: std :: os :: raw :: c_int , userdata : * mut :: std :: os :: raw :: c_void) -> * mut ggml_tensor ; } pub type ggml_custom_op_t = :: std :: option :: Option < unsafe extern "C" fn (dst : * mut ggml_tensor , ith : :: std :: os :: raw :: c_int , nth : :: std :: os :: raw :: c_int , userdata : * mut :: std :: os :: raw :: c_void) > ; unsafe extern "C" { pub fn ggml_custom_4d (ctx : * mut ggml_context , type_ : ggml_type , ne0 : i64 , ne1 : i64 , ne2 : i64 , ne3 : i64 , args : * mut * mut ggml_tensor , n_args : :: std :: os :: raw :: c_int , fun : ggml_custom_op_t , n_tasks : :: std :: os :: raw :: c_int , userdata : * mut :: std :: os :: raw :: c_void) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_custom_inplace (ctx : * mut ggml_context , a : * mut ggml_tensor , args : * mut * mut ggml_tensor , n_args : :: std :: os :: raw :: c_int , fun : ggml_custom_op_t , n_tasks : :: std :: os :: raw :: c_int , userdata : * mut :: std :: os :: raw :: c_void) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_cross_entropy_loss (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_cross_entropy_loss_back (ctx : * mut ggml_context , a : * mut ggml_tensor , b : * mut ggml_tensor , c : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_opt_step_adamw (ctx : * mut ggml_context , a : * mut ggml_tensor , grad : * mut ggml_tensor , m : * mut ggml_tensor , v : * mut ggml_tensor , adamw_params : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_opt_step_sgd (ctx : * mut ggml_context , a : * mut ggml_tensor , grad : * mut ggml_tensor , sgd_params : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_build_forward_expand (cgraph : * mut ggml_cgraph , tensor : * mut ggml_tensor) ; } unsafe extern "C" { pub fn ggml_build_backward_expand (ctx : * mut ggml_context , cgraph : * mut ggml_cgraph , grad_accs : * mut * mut ggml_tensor) ; } unsafe extern "C" { pub fn ggml_new_graph (ctx : * mut ggml_context) -> * mut ggml_cgraph ; } unsafe extern "C" { pub fn ggml_new_graph_custom (ctx : * mut ggml_context , size : usize , grads : bool) -> * mut ggml_cgraph ; } unsafe extern "C" { pub fn ggml_graph_dup (ctx : * mut ggml_context , cgraph : * mut ggml_cgraph , force_grads : bool) -> * mut ggml_cgraph ; } unsafe extern "C" { pub fn ggml_graph_cpy (src : * mut ggml_cgraph , dst : * mut ggml_cgraph) ; } unsafe extern "C" { pub fn ggml_graph_reset (cgraph : * mut ggml_cgraph) ; } unsafe extern "C" { pub fn ggml_graph_clear (cgraph : * mut ggml_cgraph) ; } unsafe extern "C" { pub fn ggml_graph_size (cgraph : * mut ggml_cgraph) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ggml_graph_node (cgraph : * mut ggml_cgraph , i : :: std :: os :: raw :: c_int) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_graph_nodes (cgraph : * mut ggml_cgraph) -> * mut * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_graph_n_nodes (cgraph : * mut ggml_cgraph) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ggml_graph_add_node (cgraph : * mut ggml_cgraph , tensor : * mut ggml_tensor) ; } unsafe extern "C" { pub fn ggml_graph_overhead () -> usize ; } unsafe extern "C" { pub fn ggml_graph_overhead_custom (size : usize , grads : bool) -> usize ; } unsafe extern "C" { pub fn ggml_graph_get_tensor (cgraph : * const ggml_cgraph , name : * const :: std :: os :: raw :: c_char) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_graph_get_grad (cgraph : * const ggml_cgraph , node : * const ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_graph_get_grad_acc (cgraph : * const ggml_cgraph , node : * const ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_graph_print (cgraph : * const ggml_cgraph) ; } unsafe extern "C" { pub fn ggml_graph_dump_dot (gb : * const ggml_cgraph , gf : * const ggml_cgraph , filename : * const :: std :: os :: raw :: c_char) ; } pub type ggml_log_callback = :: std :: option :: Option < unsafe extern "C" fn (level : ggml_log_level , text : * const :: std :: os :: raw :: c_char , user_data : * mut :: std :: os :: raw :: c_void) > ; unsafe extern "C" { pub fn ggml_log_get (log_callback : * mut ggml_log_callback , user_data : * mut * mut :: std :: os :: raw :: c_void) ; } unsafe extern "C" { pub fn ggml_log_set (log_callback : ggml_log_callback , user_data : * mut :: std :: os :: raw :: c_void) ; } unsafe extern "C" { pub fn ggml_set_zero (tensor : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_quantize_init (type_ : ggml_type) ; } unsafe extern "C" { pub fn ggml_quantize_free () ; } unsafe extern "C" { pub fn ggml_quantize_requires_imatrix (type_ : ggml_type) -> bool ; } unsafe extern "C" { pub fn ggml_quantize_chunk (type_ : ggml_type , src : * const f32 , dst : * mut :: std :: os :: raw :: c_void , start : i64 , nrows : i64 , n_per_row : i64 , imatrix : * const f32) -> usize ; } pub type ggml_to_float_t = :: std :: option :: Option < unsafe extern "C" fn (x : * const :: std :: os :: raw :: c_void , y : * mut f32 , k : i64) > ; pub type ggml_from_float_t = :: std :: option :: Option < unsafe extern "C" fn (x : * const f32 , y : * mut :: std :: os :: raw :: c_void , k : i64) > ; # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq)] pub struct ggml_type_traits { pub type_name : * const :: std :: os :: raw :: c_char , pub blck_size : i64 , pub blck_size_interleave : i64 , pub type_size : usize , pub is_quantized : bool , pub to_float : ggml_to_float_t , pub from_float_ref : ggml_from_float_t , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of ggml_type_traits"] [:: std :: mem :: size_of :: < ggml_type_traits > () - 56usize] ; ["Alignment of ggml_type_traits"] [:: std :: mem :: align_of :: < ggml_type_traits > () - 8usize] ; ["Offset of field: ggml_type_traits::type_name"] [:: std :: mem :: offset_of ! (ggml_type_traits , type_name) - 0usize] ; ["Offset of field: ggml_type_traits::blck_size"] [:: std :: mem :: offset_of ! (ggml_type_traits , blck_size) - 8usize] ; ["Offset of field: ggml_type_traits::blck_size_interleave"] [:: std :: mem :: offset_of ! (ggml_type_traits , blck_size_interleave) - 16usize] ; ["Offset of field: ggml_type_traits::type_size"] [:: std :: mem :: offset_of ! (ggml_type_traits , type_size) - 24usize] ; ["Offset of field: ggml_type_traits::is_quantized"] [:: std :: mem :: offset_of ! (ggml_type_traits , is_quantized) - 32usize] ; ["Offset of field: ggml_type_traits::to_float"] [:: std :: mem :: offset_of ! (ggml_type_traits , to_float) - 40usize] ; ["Offset of field: ggml_type_traits::from_float_ref"] [:: std :: mem :: offset_of ! (ggml_type_traits , from_float_ref) - 48usize] ; } ; unsafe extern "C" { pub fn ggml_get_type_traits (type_ : ggml_type) -> * const ggml_type_traits ; } pub const GGML_SCHED_PRIO_LOW : ggml_sched_priority = - 1 ; pub const GGML_SCHED_PRIO_NORMAL : ggml_sched_priority = 0 ; pub const GGML_SCHED_PRIO_MEDIUM : ggml_sched_priority = 1 ; pub const GGML_SCHED_PRIO_HIGH : ggml_sched_priority = 2 ; pub const GGML_SCHED_PRIO_REALTIME : ggml_sched_priority = 3 ; pub type ggml_sched_priority = :: std :: os :: raw :: c_int ; # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq)] pub struct ggml_threadpool_params { pub cpumask : [bool ; 512usize] , pub n_threads : :: std :: os :: raw :: c_int , pub prio : ggml_sched_priority , pub poll : u32 , pub strict_cpu : bool , pub paused : bool , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of ggml_threadpool_params"] [:: std :: mem :: size_of :: < ggml_threadpool_params > () - 528usize] ; ["Alignment of ggml_threadpool_params"] [:: std :: mem :: align_of :: < ggml_threadpool_params > () - 4usize] ; ["Offset of field: ggml_threadpool_params::cpumask"] [:: std :: mem :: offset_of ! (ggml_threadpool_params , cpumask) - 0usize] ; ["Offset of field: ggml_threadpool_params::n_threads"] [:: std :: mem :: offset_of ! (ggml_threadpool_params , n_threads) - 512usize] ; ["Offset of field: ggml_threadpool_params::prio"] [:: std :: mem :: offset_of ! (ggml_threadpool_params , prio) - 516usize] ; ["Offset of field: ggml_threadpool_params::poll"] [:: std :: mem :: offset_of ! (ggml_threadpool_params , poll) - 520usize] ; ["Offset of field: ggml_threadpool_params::strict_cpu"] [:: std :: mem :: offset_of ! (ggml_threadpool_params , strict_cpu) - 524usize] ; ["Offset of field: ggml_threadpool_params::paused"] [:: std :: mem :: offset_of ! (ggml_threadpool_params , paused) - 525usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ggml_threadpool { _unused : [u8 ; 0] , } pub type ggml_threadpool_t = * mut ggml_threadpool ; unsafe extern "C" { pub fn ggml_threadpool_params_default (n_threads : :: std :: os :: raw :: c_int) -> ggml_threadpool_params ; } unsafe extern "C" { pub fn ggml_threadpool_params_init (p : * mut ggml_threadpool_params , n_threads : :: std :: os :: raw :: c_int) ; } unsafe extern "C" { pub fn ggml_threadpool_params_match (p0 : * const ggml_threadpool_params , p1 : * const ggml_threadpool_params) -> bool ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ggml_backend_buffer_type { _unused : [u8 ; 0] , } pub type ggml_backend_buffer_type_t = * mut ggml_backend_buffer_type ; pub type ggml_backend_buffer_t = * mut ggml_backend_buffer ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ggml_backend { _unused : [u8 ; 0] , } pub type ggml_backend_t = * mut ggml_backend ; # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq)] pub struct ggml_tallocr { pub buffer : ggml_backend_buffer_t , pub base : * mut :: std :: os :: raw :: c_void , pub alignment : usize , pub offset : usize , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of ggml_tallocr"] [:: std :: mem :: size_of :: < ggml_tallocr > () - 32usize] ; ["Alignment of ggml_tallocr"] [:: std :: mem :: align_of :: < ggml_tallocr > () - 8usize] ; ["Offset of field: ggml_tallocr::buffer"] [:: std :: mem :: offset_of ! (ggml_tallocr , buffer) - 0usize] ; ["Offset of field: ggml_tallocr::base"] [:: std :: mem :: offset_of ! (ggml_tallocr , base) - 8usize] ; ["Offset of field: ggml_tallocr::alignment"] [:: std :: mem :: offset_of ! (ggml_tallocr , alignment) - 16usize] ; ["Offset of field: ggml_tallocr::offset"] [:: std :: mem :: offset_of ! (ggml_tallocr , offset) - 24usize] ; } ; unsafe extern "C" { pub fn ggml_tallocr_new (buffer : ggml_backend_buffer_t) -> ggml_tallocr ; } unsafe extern "C" { pub fn ggml_tallocr_alloc (talloc : * mut ggml_tallocr , tensor : * mut ggml_tensor) -> ggml_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ggml_gallocr { _unused : [u8 ; 0] , } pub type ggml_gallocr_t = * mut ggml_gallocr ; unsafe extern "C" { pub fn ggml_gallocr_new (buft : ggml_backend_buffer_type_t) -> ggml_gallocr_t ; } unsafe extern "C" { pub fn ggml_gallocr_new_n (bufts : * mut ggml_backend_buffer_type_t , n_bufs : :: std :: os :: raw :: c_int) -> ggml_gallocr_t ; } unsafe extern "C" { pub fn ggml_gallocr_free (galloc : ggml_gallocr_t) ; } unsafe extern "C" { pub fn ggml_gallocr_reserve (galloc : ggml_gallocr_t , graph : * mut ggml_cgraph) -> bool ; } unsafe extern "C" { pub fn ggml_gallocr_reserve_n_size (galloc : ggml_gallocr_t , graph : * mut ggml_cgraph , node_buffer_ids : * const :: std :: os :: raw :: c_int , leaf_buffer_ids : * const :: std :: os :: raw :: c_int , sizes : * mut usize) ; } unsafe extern "C" { pub fn ggml_gallocr_reserve_n (galloc : ggml_gallocr_t , graph : * mut ggml_cgraph , node_buffer_ids : * const :: std :: os :: raw :: c_int , leaf_buffer_ids : * const :: std :: os :: raw :: c_int) -> bool ; } unsafe extern "C" { pub fn ggml_gallocr_alloc_graph (galloc : ggml_gallocr_t , graph : * mut ggml_cgraph) -> bool ; } unsafe extern "C" { pub fn ggml_gallocr_get_buffer_size (galloc : ggml_gallocr_t , buffer_id : :: std :: os :: raw :: c_int) -> usize ; } unsafe extern "C" { pub fn ggml_backend_alloc_ctx_tensors_from_buft_size (ctx : * mut ggml_context , buft : ggml_backend_buffer_type_t) -> usize ; } unsafe extern "C" { pub fn ggml_backend_alloc_ctx_tensors_from_buft (ctx : * mut ggml_context , buft : ggml_backend_buffer_type_t) -> * mut ggml_backend_buffer ; } unsafe extern "C" { pub fn ggml_backend_alloc_ctx_tensors (ctx : * mut ggml_context , backend : ggml_backend_t) -> * mut ggml_backend_buffer ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ggml_backend_event { _unused : [u8 ; 0] , } pub type ggml_backend_event_t = * mut ggml_backend_event ; pub type ggml_backend_graph_plan_t = * mut :: std :: os :: raw :: c_void ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ggml_backend_reg { _unused : [u8 ; 0] , } pub type ggml_backend_reg_t = * mut ggml_backend_reg ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ggml_backend_device { _unused : [u8 ; 0] , } pub type ggml_backend_dev_t = * mut ggml_backend_device ; unsafe extern "C" { pub fn ggml_backend_buft_name (buft : ggml_backend_buffer_type_t) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn ggml_backend_buft_alloc_buffer (buft : ggml_backend_buffer_type_t , size : usize) -> ggml_backend_buffer_t ; } unsafe extern "C" { pub fn ggml_backend_buft_get_alignment (buft : ggml_backend_buffer_type_t) -> usize ; } unsafe extern "C" { pub fn ggml_backend_buft_get_max_size (buft : ggml_backend_buffer_type_t) -> usize ; } unsafe extern "C" { pub fn ggml_backend_buft_get_alloc_size (buft : ggml_backend_buffer_type_t , tensor : * const ggml_tensor) -> usize ; } unsafe extern "C" { pub fn ggml_backend_buft_is_host (buft : ggml_backend_buffer_type_t) -> bool ; } unsafe extern "C" { pub fn ggml_backend_buft_get_device (buft : ggml_backend_buffer_type_t) -> ggml_backend_dev_t ; } pub const GGML_BACKEND_BUFFER_USAGE_ANY : ggml_backend_buffer_usage = 0 ; pub const GGML_BACKEND_BUFFER_USAGE_WEIGHTS : ggml_backend_buffer_usage = 1 ; pub const GGML_BACKEND_BUFFER_USAGE_COMPUTE : ggml_backend_buffer_usage = 2 ; pub type ggml_backend_buffer_usage = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn ggml_backend_buffer_name (buffer : ggml_backend_buffer_t) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn ggml_backend_buffer_free (buffer : ggml_backend_buffer_t) ; } unsafe extern "C" { pub fn ggml_backend_buffer_get_base (buffer : ggml_backend_buffer_t) -> * mut :: std :: os :: raw :: c_void ; } unsafe extern "C" { pub fn ggml_backend_buffer_get_size (buffer : ggml_backend_buffer_t) -> usize ; } unsafe extern "C" { pub fn ggml_backend_buffer_init_tensor (buffer : ggml_backend_buffer_t , tensor : * mut ggml_tensor) -> ggml_status ; } unsafe extern "C" { pub fn ggml_backend_buffer_get_alignment (buffer : ggml_backend_buffer_t) -> usize ; } unsafe extern "C" { pub fn ggml_backend_buffer_get_max_size (buffer : ggml_backend_buffer_t) -> usize ; } unsafe extern "C" { pub fn ggml_backend_buffer_get_alloc_size (buffer : ggml_backend_buffer_t , tensor : * const ggml_tensor) -> usize ; } unsafe extern "C" { pub fn ggml_backend_buffer_clear (buffer : ggml_backend_buffer_t , value : u8) ; } unsafe extern "C" { pub fn ggml_backend_buffer_is_host (buffer : ggml_backend_buffer_t) -> bool ; } unsafe extern "C" { pub fn ggml_backend_buffer_set_usage (buffer : ggml_backend_buffer_t , usage : ggml_backend_buffer_usage) ; } unsafe extern "C" { pub fn ggml_backend_buffer_get_usage (buffer : ggml_backend_buffer_t) -> ggml_backend_buffer_usage ; } unsafe extern "C" { pub fn ggml_backend_buffer_get_type (buffer : ggml_backend_buffer_t) -> ggml_backend_buffer_type_t ; } unsafe extern "C" { pub fn ggml_backend_buffer_reset (buffer : ggml_backend_buffer_t) ; } unsafe extern "C" { pub fn ggml_backend_tensor_copy (src : * mut ggml_tensor , dst : * mut ggml_tensor) ; } unsafe extern "C" { pub fn ggml_backend_guid (backend : ggml_backend_t) -> ggml_guid_t ; } unsafe extern "C" { pub fn ggml_backend_name (backend : ggml_backend_t) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn ggml_backend_free (backend : ggml_backend_t) ; } unsafe extern "C" { pub fn ggml_backend_get_default_buffer_type (backend : ggml_backend_t) -> ggml_backend_buffer_type_t ; } unsafe extern "C" { pub fn ggml_backend_alloc_buffer (backend : ggml_backend_t , size : usize) -> ggml_backend_buffer_t ; } unsafe extern "C" { pub fn ggml_backend_get_alignment (backend : ggml_backend_t) -> usize ; } unsafe extern "C" { pub fn ggml_backend_get_max_size (backend : ggml_backend_t) -> usize ; } unsafe extern "C" { pub fn ggml_backend_tensor_set_async (backend : ggml_backend_t , tensor : * mut ggml_tensor , data : * const :: std :: os :: raw :: c_void , offset : usize , size : usize) ; } unsafe extern "C" { pub fn ggml_backend_tensor_get_async (backend : ggml_backend_t , tensor : * const ggml_tensor , data : * mut :: std :: os :: raw :: c_void , offset : usize , size : usize) ; } unsafe extern "C" { pub fn ggml_backend_tensor_set (tensor : * mut ggml_tensor , data : * const :: std :: os :: raw :: c_void , offset : usize , size : usize) ; } unsafe extern "C" { pub fn ggml_backend_tensor_get (tensor : * const ggml_tensor , data : * mut :: std :: os :: raw :: c_void , offset : usize , size : usize) ; } unsafe extern "C" { pub fn ggml_backend_tensor_memset (tensor : * mut ggml_tensor , value : u8 , offset : usize , size : usize) ; } unsafe extern "C" { pub fn ggml_backend_synchronize (backend : ggml_backend_t) ; } unsafe extern "C" { pub fn ggml_backend_graph_plan_create (backend : ggml_backend_t , cgraph : * mut ggml_cgraph) -> ggml_backend_graph_plan_t ; } unsafe extern "C" { pub fn ggml_backend_graph_plan_free (backend : ggml_backend_t , plan : ggml_backend_graph_plan_t) ; } unsafe extern "C" { pub fn ggml_backend_graph_plan_compute (backend : ggml_backend_t , plan : ggml_backend_graph_plan_t) -> ggml_status ; } unsafe extern "C" { pub fn ggml_backend_graph_compute (backend : ggml_backend_t , cgraph : * mut ggml_cgraph) -> ggml_status ; } unsafe extern "C" { pub fn ggml_backend_graph_compute_async (backend : ggml_backend_t , cgraph : * mut ggml_cgraph) -> ggml_status ; } unsafe extern "C" { pub fn ggml_backend_supports_op (backend : ggml_backend_t , op : * const ggml_tensor) -> bool ; } unsafe extern "C" { pub fn ggml_backend_supports_buft (backend : ggml_backend_t , buft : ggml_backend_buffer_type_t) -> bool ; } unsafe extern "C" { pub fn ggml_backend_offload_op (backend : ggml_backend_t , op : * const ggml_tensor) -> bool ; } unsafe extern "C" { pub fn ggml_backend_tensor_copy_async (backend_src : ggml_backend_t , backend_dst : ggml_backend_t , src : * mut ggml_tensor , dst : * mut ggml_tensor) ; } unsafe extern "C" { pub fn ggml_backend_get_device (backend : ggml_backend_t) -> ggml_backend_dev_t ; } unsafe extern "C" { pub fn ggml_backend_event_new (device : ggml_backend_dev_t) -> ggml_backend_event_t ; } unsafe extern "C" { pub fn ggml_backend_event_free (event : ggml_backend_event_t) ; } unsafe extern "C" { pub fn ggml_backend_event_record (event : ggml_backend_event_t , backend : ggml_backend_t) ; } unsafe extern "C" { pub fn ggml_backend_event_synchronize (event : ggml_backend_event_t) ; } unsafe extern "C" { pub fn ggml_backend_event_wait (backend : ggml_backend_t , event : ggml_backend_event_t) ; } pub const GGML_BACKEND_DEVICE_TYPE_CPU : ggml_backend_dev_type = 0 ; pub const GGML_BACKEND_DEVICE_TYPE_GPU : ggml_backend_dev_type = 1 ; pub const GGML_BACKEND_DEVICE_TYPE_IGPU : ggml_backend_dev_type = 2 ; pub const GGML_BACKEND_DEVICE_TYPE_ACCEL : ggml_backend_dev_type = 3 ; pub type ggml_backend_dev_type = :: std :: os :: raw :: c_uint ; # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq)] pub struct ggml_backend_dev_caps { pub async_ : bool , pub host_buffer : bool , pub buffer_from_host_ptr : bool , pub events : bool , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of ggml_backend_dev_caps"] [:: std :: mem :: size_of :: < ggml_backend_dev_caps > () - 4usize] ; ["Alignment of ggml_backend_dev_caps"] [:: std :: mem :: align_of :: < ggml_backend_dev_caps > () - 1usize] ; ["Offset of field: ggml_backend_dev_caps::async_"] [:: std :: mem :: offset_of ! (ggml_backend_dev_caps , async_) - 0usize] ; ["Offset of field: ggml_backend_dev_caps::host_buffer"] [:: std :: mem :: offset_of ! (ggml_backend_dev_caps , host_buffer) - 1usize] ; ["Offset of field: ggml_backend_dev_caps::buffer_from_host_ptr"] [:: std :: mem :: offset_of ! (ggml_backend_dev_caps , buffer_from_host_ptr) - 2usize] ; ["Offset of field: ggml_backend_dev_caps::events"] [:: std :: mem :: offset_of ! (ggml_backend_dev_caps , events) - 3usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq)] pub struct ggml_backend_dev_props { pub name : * const :: std :: os :: raw :: c_char , pub description : * const :: std :: os :: raw :: c_char , pub memory_free : usize , pub memory_total : usize , pub type_ : ggml_backend_dev_type , pub device_id : * const :: std :: os :: raw :: c_char , pub caps : ggml_backend_dev_caps , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of ggml_backend_dev_props"] [:: std :: mem :: size_of :: < ggml_backend_dev_props > () - 56usize] ; ["Alignment of ggml_backend_dev_props"] [:: std :: mem :: align_of :: < ggml_backend_dev_props > () - 8usize] ; ["Offset of field: ggml_backend_dev_props::name"] [:: std :: mem :: offset_of ! (ggml_backend_dev_props , name) - 0usize] ; ["Offset of field: ggml_backend_dev_props::description"] [:: std :: mem :: offset_of ! (ggml_backend_dev_props , description) - 8usize] ; ["Offset of field: ggml_backend_dev_props::memory_free"] [:: std :: mem :: offset_of ! (ggml_backend_dev_props , memory_free) - 16usize] ; ["Offset of field: ggml_backend_dev_props::memory_total"] [:: std :: mem :: offset_of ! (ggml_backend_dev_props , memory_total) - 24usize] ; ["Offset of field: ggml_backend_dev_props::type_"] [:: std :: mem :: offset_of ! (ggml_backend_dev_props , type_) - 32usize] ; ["Offset of field: ggml_backend_dev_props::device_id"] [:: std :: mem :: offset_of ! (ggml_backend_dev_props , device_id) - 40usize] ; ["Offset of field: ggml_backend_dev_props::caps"] [:: std :: mem :: offset_of ! (ggml_backend_dev_props , caps) - 48usize] ; } ; unsafe extern "C" { pub fn ggml_backend_dev_name (device : ggml_backend_dev_t) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn ggml_backend_dev_description (device : ggml_backend_dev_t) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn ggml_backend_dev_memory (device : ggml_backend_dev_t , free : * mut usize , total : * mut usize) ; } unsafe extern "C" { pub fn ggml_backend_dev_type (device : ggml_backend_dev_t) -> ggml_backend_dev_type ; } unsafe extern "C" { pub fn ggml_backend_dev_get_props (device : ggml_backend_dev_t , props : * mut ggml_backend_dev_props) ; } unsafe extern "C" { pub fn ggml_backend_dev_backend_reg (device : ggml_backend_dev_t) -> ggml_backend_reg_t ; } unsafe extern "C" { pub fn ggml_backend_dev_init (device : ggml_backend_dev_t , params : * const :: std :: os :: raw :: c_char) -> ggml_backend_t ; } unsafe extern "C" { pub fn ggml_backend_dev_buffer_type (device : ggml_backend_dev_t) -> ggml_backend_buffer_type_t ; } unsafe extern "C" { pub fn ggml_backend_dev_host_buffer_type (device : ggml_backend_dev_t) -> ggml_backend_buffer_type_t ; } unsafe extern "C" { pub fn ggml_backend_dev_buffer_from_host_ptr (device : ggml_backend_dev_t , ptr : * mut :: std :: os :: raw :: c_void , size : usize , max_tensor_size : usize) -> ggml_backend_buffer_t ; } unsafe extern "C" { pub fn ggml_backend_dev_supports_op (device : ggml_backend_dev_t , op : * const ggml_tensor) -> bool ; } unsafe extern "C" { pub fn ggml_backend_dev_supports_buft (device : ggml_backend_dev_t , buft : ggml_backend_buffer_type_t) -> bool ; } unsafe extern "C" { pub fn ggml_backend_dev_offload_op (device : ggml_backend_dev_t , op : * const ggml_tensor) -> bool ; } unsafe extern "C" { pub fn ggml_backend_reg_name (reg : ggml_backend_reg_t) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn ggml_backend_reg_dev_count (reg : ggml_backend_reg_t) -> usize ; } unsafe extern "C" { pub fn ggml_backend_reg_dev_get (reg : ggml_backend_reg_t , index : usize) -> ggml_backend_dev_t ; } unsafe extern "C" { pub fn ggml_backend_reg_get_proc_address (reg : ggml_backend_reg_t , name : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_void ; } pub type ggml_backend_split_buffer_type_t = :: std :: option :: Option < unsafe extern "C" fn (main_device : :: std :: os :: raw :: c_int , tensor_split : * const f32) -> ggml_backend_buffer_type_t > ; pub type ggml_backend_set_n_threads_t = :: std :: option :: Option < unsafe extern "C" fn (backend : ggml_backend_t , n_threads : :: std :: os :: raw :: c_int) > ; pub type ggml_backend_dev_get_extra_bufts_t = :: std :: option :: Option < unsafe extern "C" fn (device : ggml_backend_dev_t) -> * mut ggml_backend_buffer_type_t > ; pub type ggml_backend_set_abort_callback_t = :: std :: option :: Option < unsafe extern "C" fn (backend : ggml_backend_t , abort_callback : ggml_abort_callback , abort_callback_data : * mut :: std :: os :: raw :: c_void) > ; # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq)] pub struct ggml_backend_feature { pub name : * const :: std :: os :: raw :: c_char , pub value : * const :: std :: os :: raw :: c_char , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of ggml_backend_feature"] [:: std :: mem :: size_of :: < ggml_backend_feature > () - 16usize] ; ["Alignment of ggml_backend_feature"] [:: std :: mem :: align_of :: < ggml_backend_feature > () - 8usize] ; ["Offset of field: ggml_backend_feature::name"] [:: std :: mem :: offset_of ! (ggml_backend_feature , name) - 0usize] ; ["Offset of field: ggml_backend_feature::value"] [:: std :: mem :: offset_of ! (ggml_backend_feature , value) - 8usize] ; } ; pub type ggml_backend_get_features_t = :: std :: option :: Option < unsafe extern "C" fn (reg : ggml_backend_reg_t) -> * mut ggml_backend_feature > ; unsafe extern "C" { pub fn ggml_backend_register (reg : ggml_backend_reg_t) ; } unsafe extern "C" { pub fn ggml_backend_device_register (device : ggml_backend_dev_t) ; } unsafe extern "C" { pub fn ggml_backend_reg_count () -> usize ; } unsafe extern "C" { pub fn ggml_backend_reg_get (index : usize) -> ggml_backend_reg_t ; } unsafe extern "C" { pub fn ggml_backend_reg_by_name (name : * const :: std :: os :: raw :: c_char) -> ggml_backend_reg_t ; } unsafe extern "C" { pub fn ggml_backend_dev_count () -> usize ; } unsafe extern "C" { pub fn ggml_backend_dev_get (index : usize) -> ggml_backend_dev_t ; } unsafe extern "C" { pub fn ggml_backend_dev_by_name (name : * const :: std :: os :: raw :: c_char) -> ggml_backend_dev_t ; } unsafe extern "C" { pub fn ggml_backend_dev_by_type (type_ : ggml_backend_dev_type) -> ggml_backend_dev_t ; } unsafe extern "C" { pub fn ggml_backend_init_by_name (name : * const :: std :: os :: raw :: c_char , params : * const :: std :: os :: raw :: c_char) -> ggml_backend_t ; } unsafe extern "C" { pub fn ggml_backend_init_by_type (type_ : ggml_backend_dev_type , params : * const :: std :: os :: raw :: c_char) -> ggml_backend_t ; } unsafe extern "C" { pub fn ggml_backend_init_best () -> ggml_backend_t ; } unsafe extern "C" { pub fn ggml_backend_load (path : * const :: std :: os :: raw :: c_char) -> ggml_backend_reg_t ; } unsafe extern "C" { pub fn ggml_backend_unload (reg : ggml_backend_reg_t) ; } unsafe extern "C" { pub fn ggml_backend_load_all () ; } unsafe extern "C" { pub fn ggml_backend_load_all_from_path (dir_path : * const :: std :: os :: raw :: c_char) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ggml_backend_sched { _unused : [u8 ; 0] , } pub type ggml_backend_sched_t = * mut ggml_backend_sched ; pub type ggml_backend_sched_eval_callback = :: std :: option :: Option < unsafe extern "C" fn (t : * mut ggml_tensor , ask : bool , user_data : * mut :: std :: os :: raw :: c_void) -> bool > ; unsafe extern "C" { pub fn ggml_backend_sched_new (backends : * mut ggml_backend_t , bufts : * mut ggml_backend_buffer_type_t , n_backends : :: std :: os :: raw :: c_int , graph_size : usize , parallel : bool , op_offload : bool) -> ggml_backend_sched_t ; } unsafe extern "C" { pub fn ggml_backend_sched_free (sched : ggml_backend_sched_t) ; } unsafe extern "C" { pub fn ggml_backend_sched_reserve_size (sched : ggml_backend_sched_t , measure_graph : * mut ggml_cgraph , sizes : * mut usize) ; } unsafe extern "C" { pub fn ggml_backend_sched_reserve (sched : ggml_backend_sched_t , measure_graph : * mut ggml_cgraph) -> bool ; } unsafe extern "C" { pub fn ggml_backend_sched_get_n_backends (sched : ggml_backend_sched_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ggml_backend_sched_get_backend (sched : ggml_backend_sched_t , i : :: std :: os :: raw :: c_int) -> ggml_backend_t ; } unsafe extern "C" { pub fn ggml_backend_sched_get_n_splits (sched : ggml_backend_sched_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ggml_backend_sched_get_n_copies (sched : ggml_backend_sched_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ggml_backend_sched_get_buffer_type (sched : ggml_backend_sched_t , backend : ggml_backend_t) -> ggml_backend_buffer_type_t ; } unsafe extern "C" { pub fn ggml_backend_sched_get_buffer_size (sched : ggml_backend_sched_t , backend : ggml_backend_t) -> usize ; } unsafe extern "C" { pub fn ggml_backend_sched_set_tensor_backend (sched : ggml_backend_sched_t , node : * mut ggml_tensor , backend : ggml_backend_t) ; } unsafe extern "C" { pub fn ggml_backend_sched_get_tensor_backend (sched : ggml_backend_sched_t , node : * mut ggml_tensor) -> ggml_backend_t ; } unsafe extern "C" { pub fn ggml_backend_sched_split_graph (sched : ggml_backend_sched_t , graph : * mut ggml_cgraph) ; } unsafe extern "C" { pub fn ggml_backend_sched_alloc_graph (sched : ggml_backend_sched_t , graph : * mut ggml_cgraph) -> bool ; } unsafe extern "C" { pub fn ggml_backend_sched_graph_compute (sched : ggml_backend_sched_t , graph : * mut ggml_cgraph) -> ggml_status ; } unsafe extern "C" { pub fn ggml_backend_sched_graph_compute_async (sched : ggml_backend_sched_t , graph : * mut ggml_cgraph) -> ggml_status ; } unsafe extern "C" { pub fn ggml_backend_sched_synchronize (sched : ggml_backend_sched_t) ; } unsafe extern "C" { pub fn ggml_backend_sched_reset (sched : ggml_backend_sched_t) ; } unsafe extern "C" { pub fn ggml_backend_sched_set_eval_callback (sched : ggml_backend_sched_t , callback : ggml_backend_sched_eval_callback , user_data : * mut :: std :: os :: raw :: c_void) ; } # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq)] pub struct ggml_backend_graph_copy { pub buffer : ggml_backend_buffer_t , pub ctx_allocated : * mut ggml_context , pub ctx_unallocated : * mut ggml_context , pub graph : * mut ggml_cgraph , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of ggml_backend_graph_copy"] [:: std :: mem :: size_of :: < ggml_backend_graph_copy > () - 32usize] ; ["Alignment of ggml_backend_graph_copy"] [:: std :: mem :: align_of :: < ggml_backend_graph_copy > () - 8usize] ; ["Offset of field: ggml_backend_graph_copy::buffer"] [:: std :: mem :: offset_of ! (ggml_backend_graph_copy , buffer) - 0usize] ; ["Offset of field: ggml_backend_graph_copy::ctx_allocated"] [:: std :: mem :: offset_of ! (ggml_backend_graph_copy , ctx_allocated) - 8usize] ; ["Offset of field: ggml_backend_graph_copy::ctx_unallocated"] [:: std :: mem :: offset_of ! (ggml_backend_graph_copy , ctx_unallocated) - 16usize] ; ["Offset of field: ggml_backend_graph_copy::graph"] [:: std :: mem :: offset_of ! (ggml_backend_graph_copy , graph) - 24usize] ; } ; unsafe extern "C" { pub fn ggml_backend_graph_copy (backend : ggml_backend_t , graph : * mut ggml_cgraph) -> ggml_backend_graph_copy ; } unsafe extern "C" { pub fn ggml_backend_graph_copy_free (copy : ggml_backend_graph_copy) ; } pub type ggml_backend_eval_callback = :: std :: option :: Option < unsafe extern "C" fn (node_index : :: std :: os :: raw :: c_int , t1 : * mut ggml_tensor , t2 : * mut ggml_tensor , user_data : * mut :: std :: os :: raw :: c_void) -> bool > ; unsafe extern "C" { pub fn ggml_backend_compare_graph_backend (backend1 : ggml_backend_t , backend2 : ggml_backend_t , graph : * mut ggml_cgraph , callback : ggml_backend_eval_callback , user_data : * mut :: std :: os :: raw :: c_void , test_nodes : * const * const ggml_tensor , num_test_nodes : usize) -> bool ; } unsafe extern "C" { pub fn ggml_backend_tensor_alloc (buffer : ggml_backend_buffer_t , tensor : * mut ggml_tensor , addr : * mut :: std :: os :: raw :: c_void) -> ggml_status ; } unsafe extern "C" { pub fn ggml_backend_view_init (tensor : * mut ggml_tensor) -> ggml_status ; } unsafe extern "C" { pub fn ggml_backend_cpu_buffer_from_ptr (ptr : * mut :: std :: os :: raw :: c_void , size : usize) -> ggml_backend_buffer_t ; } unsafe extern "C" { pub fn ggml_backend_cpu_buffer_type () -> ggml_backend_buffer_type_t ; } # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq)] pub struct ggml_cplan { pub work_size : usize , pub work_data : * mut u8 , pub n_threads : :: std :: os :: raw :: c_int , pub threadpool : * mut ggml_threadpool , pub abort_callback : ggml_abort_callback , pub abort_callback_data : * mut :: std :: os :: raw :: c_void , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of ggml_cplan"] [:: std :: mem :: size_of :: < ggml_cplan > () - 48usize] ; ["Alignment of ggml_cplan"] [:: std :: mem :: align_of :: < ggml_cplan > () - 8usize] ; ["Offset of field: ggml_cplan::work_size"] [:: std :: mem :: offset_of ! (ggml_cplan , work_size) - 0usize] ; ["Offset of field: ggml_cplan::work_data"] [:: std :: mem :: offset_of ! (ggml_cplan , work_data) - 8usize] ; ["Offset of field: ggml_cplan::n_threads"] [:: std :: mem :: offset_of ! (ggml_cplan , n_threads) - 16usize] ; ["Offset of field: ggml_cplan::threadpool"] [:: std :: mem :: offset_of ! (ggml_cplan , threadpool) - 24usize] ; ["Offset of field: ggml_cplan::abort_callback"] [:: std :: mem :: offset_of ! (ggml_cplan , abort_callback) - 32usize] ; ["Offset of field: ggml_cplan::abort_callback_data"] [:: std :: mem :: offset_of ! (ggml_cplan , abort_callback_data) - 40usize] ; } ; pub const GGML_NUMA_STRATEGY_DISABLED : ggml_numa_strategy = 0 ; pub const GGML_NUMA_STRATEGY_DISTRIBUTE : ggml_numa_strategy = 1 ; pub const GGML_NUMA_STRATEGY_ISOLATE : ggml_numa_strategy = 2 ; pub const GGML_NUMA_STRATEGY_NUMACTL : ggml_numa_strategy = 3 ; pub const GGML_NUMA_STRATEGY_MIRROR : ggml_numa_strategy = 4 ; pub const GGML_NUMA_STRATEGY_COUNT : ggml_numa_strategy = 5 ; pub type ggml_numa_strategy = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn ggml_numa_init (numa : ggml_numa_strategy) ; } unsafe extern "C" { pub fn ggml_is_numa () -> bool ; } unsafe extern "C" { pub fn ggml_new_i32 (ctx : * mut ggml_context , value : i32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_new_f32 (ctx : * mut ggml_context , value : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_set_i32 (tensor : * mut ggml_tensor , value : i32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_set_f32 (tensor : * mut ggml_tensor , value : f32) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_get_i32_1d (tensor : * const ggml_tensor , i : :: std :: os :: raw :: c_int) -> i32 ; } unsafe extern "C" { pub fn ggml_set_i32_1d (tensor : * const ggml_tensor , i : :: std :: os :: raw :: c_int , value : i32) ; } unsafe extern "C" { pub fn ggml_get_i32_nd (tensor : * const ggml_tensor , i0 : :: std :: os :: raw :: c_int , i1 : :: std :: os :: raw :: c_int , i2 : :: std :: os :: raw :: c_int , i3 : :: std :: os :: raw :: c_int) -> i32 ; } unsafe extern "C" { pub fn ggml_set_i32_nd (tensor : * const ggml_tensor , i0 : :: std :: os :: raw :: c_int , i1 : :: std :: os :: raw :: c_int , i2 : :: std :: os :: raw :: c_int , i3 : :: std :: os :: raw :: c_int , value : i32) ; } unsafe extern "C" { pub fn ggml_get_f32_1d (tensor : * const ggml_tensor , i : :: std :: os :: raw :: c_int) -> f32 ; } unsafe extern "C" { pub fn ggml_set_f32_1d (tensor : * const ggml_tensor , i : :: std :: os :: raw :: c_int , value : f32) ; } unsafe extern "C" { pub fn ggml_get_f32_nd (tensor : * const ggml_tensor , i0 : :: std :: os :: raw :: c_int , i1 : :: std :: os :: raw :: c_int , i2 : :: std :: os :: raw :: c_int , i3 : :: std :: os :: raw :: c_int) -> f32 ; } unsafe extern "C" { pub fn ggml_set_f32_nd (tensor : * const ggml_tensor , i0 : :: std :: os :: raw :: c_int , i1 : :: std :: os :: raw :: c_int , i2 : :: std :: os :: raw :: c_int , i3 : :: std :: os :: raw :: c_int , value : f32) ; } unsafe extern "C" { pub fn ggml_threadpool_new (params : * mut ggml_threadpool_params) -> * mut ggml_threadpool ; } unsafe extern "C" { pub fn ggml_threadpool_free (threadpool : * mut ggml_threadpool) ; } unsafe extern "C" { pub fn ggml_threadpool_get_n_threads (threadpool : * mut ggml_threadpool) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ggml_threadpool_pause (threadpool : * mut ggml_threadpool) ; } unsafe extern "C" { pub fn ggml_threadpool_resume (threadpool : * mut ggml_threadpool) ; } unsafe extern "C" { pub fn ggml_graph_plan (cgraph : * const ggml_cgraph , n_threads : :: std :: os :: raw :: c_int , threadpool : * mut ggml_threadpool) -> ggml_cplan ; } unsafe extern "C" { pub fn ggml_graph_compute (cgraph : * mut ggml_cgraph , cplan : * mut ggml_cplan) -> ggml_status ; } unsafe extern "C" { pub fn ggml_graph_compute_with_ctx (ctx : * mut ggml_context , cgraph : * mut ggml_cgraph , n_threads : :: std :: os :: raw :: c_int) -> ggml_status ; } unsafe extern "C" { pub fn ggml_cpu_has_sse3 () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ggml_cpu_has_ssse3 () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ggml_cpu_has_avx () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ggml_cpu_has_avx_vnni () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ggml_cpu_has_avx2 () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ggml_cpu_has_bmi2 () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ggml_cpu_has_f16c () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ggml_cpu_has_fma () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ggml_cpu_has_avx512 () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ggml_cpu_has_avx512_vbmi () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ggml_cpu_has_avx512_vnni () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ggml_cpu_has_avx512_bf16 () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ggml_cpu_has_amx_int8 () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ggml_cpu_has_neon () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ggml_cpu_has_arm_fma () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ggml_cpu_has_fp16_va () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ggml_cpu_has_dotprod () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ggml_cpu_has_matmul_int8 () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ggml_cpu_has_sve () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ggml_cpu_get_sve_cnt () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ggml_cpu_has_sme () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ggml_cpu_has_riscv_v () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ggml_cpu_get_rvv_vlen () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ggml_cpu_has_vsx () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ggml_cpu_has_vxe () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ggml_cpu_has_wasm_simd () -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn ggml_cpu_has_llamafile () -> :: std :: os :: raw :: c_int ; } pub type ggml_vec_dot_t = :: std :: option :: Option < unsafe extern "C" fn (n : :: std :: os :: raw :: c_int , s : * mut f32 , bs : usize , x : * const :: std :: os :: raw :: c_void , bx : usize , y : * const :: std :: os :: raw :: c_void , by : usize , nrc : :: std :: os :: raw :: c_int) > ; # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq)] pub struct ggml_type_traits_cpu { pub from_float : ggml_from_float_t , pub vec_dot : ggml_vec_dot_t , pub vec_dot_type : ggml_type , pub nrows : i64 , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of ggml_type_traits_cpu"] [:: std :: mem :: size_of :: < ggml_type_traits_cpu > () - 32usize] ; ["Alignment of ggml_type_traits_cpu"] [:: std :: mem :: align_of :: < ggml_type_traits_cpu > () - 8usize] ; ["Offset of field: ggml_type_traits_cpu::from_float"] [:: std :: mem :: offset_of ! (ggml_type_traits_cpu , from_float) - 0usize] ; ["Offset of field: ggml_type_traits_cpu::vec_dot"] [:: std :: mem :: offset_of ! (ggml_type_traits_cpu , vec_dot) - 8usize] ; ["Offset of field: ggml_type_traits_cpu::vec_dot_type"] [:: std :: mem :: offset_of ! (ggml_type_traits_cpu , vec_dot_type) - 16usize] ; ["Offset of field: ggml_type_traits_cpu::nrows"] [:: std :: mem :: offset_of ! (ggml_type_traits_cpu , nrows) - 24usize] ; } ; unsafe extern "C" { pub fn ggml_get_type_traits_cpu (type_ : ggml_type) -> * const ggml_type_traits_cpu ; } unsafe extern "C" { pub fn ggml_cpu_init () ; } unsafe extern "C" { pub fn ggml_backend_cpu_init () -> ggml_backend_t ; } unsafe extern "C" { pub fn ggml_backend_is_cpu (backend : ggml_backend_t) -> bool ; } unsafe extern "C" { pub fn ggml_backend_cpu_set_n_threads (backend_cpu : ggml_backend_t , n_threads : :: std :: os :: raw :: c_int) ; } unsafe extern "C" { pub fn ggml_backend_cpu_set_threadpool (backend_cpu : ggml_backend_t , threadpool : ggml_threadpool_t) ; } unsafe extern "C" { pub fn ggml_backend_cpu_set_abort_callback (backend_cpu : ggml_backend_t , abort_callback : ggml_abort_callback , abort_callback_data : * mut :: std :: os :: raw :: c_void) ; } unsafe extern "C" { pub fn ggml_backend_cpu_reg () -> ggml_backend_reg_t ; } unsafe extern "C" { pub fn ggml_cpu_fp32_to_fp32 (arg1 : * const f32 , arg2 : * mut f32 , arg3 : i64) ; } unsafe extern "C" { pub fn ggml_cpu_fp32_to_i32 (arg1 : * const f32 , arg2 : * mut i32 , arg3 : i64) ; } unsafe extern "C" { pub fn ggml_cpu_fp32_to_fp16 (arg1 : * const f32 , arg2 : * mut ggml_fp16_t , arg3 : i64) ; } unsafe extern "C" { pub fn ggml_cpu_fp16_to_fp32 (arg1 : * const ggml_fp16_t , arg2 : * mut f32 , arg3 : i64) ; } unsafe extern "C" { pub fn ggml_cpu_fp32_to_bf16 (arg1 : * const f32 , arg2 : * mut ggml_bf16_t , arg3 : i64) ; } unsafe extern "C" { pub fn ggml_cpu_bf16_to_fp32 (arg1 : * const ggml_bf16_t , arg2 : * mut f32 , arg3 : i64) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ggml_opt_dataset { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ggml_opt_context { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ggml_opt_result { _unused : [u8 ; 0] , } pub type ggml_opt_dataset_t = * mut ggml_opt_dataset ; pub type ggml_opt_context_t = * mut ggml_opt_context ; pub type ggml_opt_result_t = * mut ggml_opt_result ; pub const GGML_OPT_LOSS_TYPE_MEAN : ggml_opt_loss_type = 0 ; pub const GGML_OPT_LOSS_TYPE_SUM : ggml_opt_loss_type = 1 ; pub const GGML_OPT_LOSS_TYPE_CROSS_ENTROPY : ggml_opt_loss_type = 2 ; pub const GGML_OPT_LOSS_TYPE_MEAN_SQUARED_ERROR : ggml_opt_loss_type = 3 ; pub type ggml_opt_loss_type = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn ggml_opt_dataset_init (type_data : ggml_type , type_label : ggml_type , ne_datapoint : i64 , ne_label : i64 , ndata : i64 , ndata_shard : i64) -> ggml_opt_dataset_t ; } unsafe extern "C" { pub fn ggml_opt_dataset_free (dataset : ggml_opt_dataset_t) ; } unsafe extern "C" { pub fn ggml_opt_dataset_ndata (dataset : ggml_opt_dataset_t) -> i64 ; } unsafe extern "C" { pub fn ggml_opt_dataset_data (dataset : ggml_opt_dataset_t) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_opt_dataset_labels (dataset : ggml_opt_dataset_t) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_opt_dataset_shuffle (opt_ctx : ggml_opt_context_t , dataset : ggml_opt_dataset_t , idata : i64) ; } unsafe extern "C" { pub fn ggml_opt_dataset_get_batch (dataset : ggml_opt_dataset_t , data_batch : * mut ggml_tensor , labels_batch : * mut ggml_tensor , ibatch : i64) ; } unsafe extern "C" { pub fn ggml_opt_dataset_get_batch_host (dataset : ggml_opt_dataset_t , data_batch : * mut :: std :: os :: raw :: c_void , nb_data_batch : usize , labels_batch : * mut :: std :: os :: raw :: c_void , ibatch : i64) ; } pub const GGML_OPT_BUILD_TYPE_FORWARD : ggml_opt_build_type = 10 ; pub const GGML_OPT_BUILD_TYPE_GRAD : ggml_opt_build_type = 20 ; pub const GGML_OPT_BUILD_TYPE_OPT : ggml_opt_build_type = 30 ; pub type ggml_opt_build_type = :: std :: os :: raw :: c_uint ; pub const GGML_OPT_OPTIMIZER_TYPE_ADAMW : ggml_opt_optimizer_type = 0 ; pub const GGML_OPT_OPTIMIZER_TYPE_SGD : ggml_opt_optimizer_type = 1 ; pub const GGML_OPT_OPTIMIZER_TYPE_COUNT : ggml_opt_optimizer_type = 2 ; pub type ggml_opt_optimizer_type = :: std :: os :: raw :: c_uint ; # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq)] pub struct ggml_opt_optimizer_params { pub adamw : ggml_opt_optimizer_params__bindgen_ty_1 , pub sgd : ggml_opt_optimizer_params__bindgen_ty_2 , } # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq)] pub struct ggml_opt_optimizer_params__bindgen_ty_1 { pub alpha : f32 , pub beta1 : f32 , pub beta2 : f32 , pub eps : f32 , pub wd : f32 , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of ggml_opt_optimizer_params__bindgen_ty_1"] [:: std :: mem :: size_of :: < ggml_opt_optimizer_params__bindgen_ty_1 > () - 20usize] ; ["Alignment of ggml_opt_optimizer_params__bindgen_ty_1"] [:: std :: mem :: align_of :: < ggml_opt_optimizer_params__bindgen_ty_1 > () - 4usize] ; ["Offset of field: ggml_opt_optimizer_params__bindgen_ty_1::alpha"] [:: std :: mem :: offset_of ! (ggml_opt_optimizer_params__bindgen_ty_1 , alpha) - 0usize] ; ["Offset of field: ggml_opt_optimizer_params__bindgen_ty_1::beta1"] [:: std :: mem :: offset_of ! (ggml_opt_optimizer_params__bindgen_ty_1 , beta1) - 4usize] ; ["Offset of field: ggml_opt_optimizer_params__bindgen_ty_1::beta2"] [:: std :: mem :: offset_of ! (ggml_opt_optimizer_params__bindgen_ty_1 , beta2) - 8usize] ; ["Offset of field: ggml_opt_optimizer_params__bindgen_ty_1::eps"] [:: std :: mem :: offset_of ! (ggml_opt_optimizer_params__bindgen_ty_1 , eps) - 12usize] ; ["Offset of field: ggml_opt_optimizer_params__bindgen_ty_1::wd"] [:: std :: mem :: offset_of ! (ggml_opt_optimizer_params__bindgen_ty_1 , wd) - 16usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq)] pub struct ggml_opt_optimizer_params__bindgen_ty_2 { pub alpha : f32 , pub wd : f32 , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of ggml_opt_optimizer_params__bindgen_ty_2"] [:: std :: mem :: size_of :: < ggml_opt_optimizer_params__bindgen_ty_2 > () - 8usize] ; ["Alignment of ggml_opt_optimizer_params__bindgen_ty_2"] [:: std :: mem :: align_of :: < ggml_opt_optimizer_params__bindgen_ty_2 > () - 4usize] ; ["Offset of field: ggml_opt_optimizer_params__bindgen_ty_2::alpha"] [:: std :: mem :: offset_of ! (ggml_opt_optimizer_params__bindgen_ty_2 , alpha) - 0usize] ; ["Offset of field: ggml_opt_optimizer_params__bindgen_ty_2::wd"] [:: std :: mem :: offset_of ! (ggml_opt_optimizer_params__bindgen_ty_2 , wd) - 4usize] ; } ; # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of ggml_opt_optimizer_params"] [:: std :: mem :: size_of :: < ggml_opt_optimizer_params > () - 28usize] ; ["Alignment of ggml_opt_optimizer_params"] [:: std :: mem :: align_of :: < ggml_opt_optimizer_params > () - 4usize] ; ["Offset of field: ggml_opt_optimizer_params::adamw"] [:: std :: mem :: offset_of ! (ggml_opt_optimizer_params , adamw) - 0usize] ; ["Offset of field: ggml_opt_optimizer_params::sgd"] [:: std :: mem :: offset_of ! (ggml_opt_optimizer_params , sgd) - 20usize] ; } ; pub type ggml_opt_get_optimizer_params = :: std :: option :: Option < unsafe extern "C" fn (userdata : * mut :: std :: os :: raw :: c_void) -> ggml_opt_optimizer_params > ; unsafe extern "C" { pub fn ggml_opt_get_default_optimizer_params (userdata : * mut :: std :: os :: raw :: c_void) -> ggml_opt_optimizer_params ; } unsafe extern "C" { pub fn ggml_opt_get_constant_optimizer_params (userdata : * mut :: std :: os :: raw :: c_void) -> ggml_opt_optimizer_params ; } # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq)] pub struct ggml_opt_params { pub backend_sched : ggml_backend_sched_t , pub ctx_compute : * mut ggml_context , pub inputs : * mut ggml_tensor , pub outputs : * mut ggml_tensor , pub loss_type : ggml_opt_loss_type , pub build_type : ggml_opt_build_type , pub opt_period : i32 , pub get_opt_pars : ggml_opt_get_optimizer_params , pub get_opt_pars_ud : * mut :: std :: os :: raw :: c_void , pub optimizer : ggml_opt_optimizer_type , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of ggml_opt_params"] [:: std :: mem :: size_of :: < ggml_opt_params > () - 72usize] ; ["Alignment of ggml_opt_params"] [:: std :: mem :: align_of :: < ggml_opt_params > () - 8usize] ; ["Offset of field: ggml_opt_params::backend_sched"] [:: std :: mem :: offset_of ! (ggml_opt_params , backend_sched) - 0usize] ; ["Offset of field: ggml_opt_params::ctx_compute"] [:: std :: mem :: offset_of ! (ggml_opt_params , ctx_compute) - 8usize] ; ["Offset of field: ggml_opt_params::inputs"] [:: std :: mem :: offset_of ! (ggml_opt_params , inputs) - 16usize] ; ["Offset of field: ggml_opt_params::outputs"] [:: std :: mem :: offset_of ! (ggml_opt_params , outputs) - 24usize] ; ["Offset of field: ggml_opt_params::loss_type"] [:: std :: mem :: offset_of ! (ggml_opt_params , loss_type) - 32usize] ; ["Offset of field: ggml_opt_params::build_type"] [:: std :: mem :: offset_of ! (ggml_opt_params , build_type) - 36usize] ; ["Offset of field: ggml_opt_params::opt_period"] [:: std :: mem :: offset_of ! (ggml_opt_params , opt_period) - 40usize] ; ["Offset of field: ggml_opt_params::get_opt_pars"] [:: std :: mem :: offset_of ! (ggml_opt_params , get_opt_pars) - 48usize] ; ["Offset of field: ggml_opt_params::get_opt_pars_ud"] [:: std :: mem :: offset_of ! (ggml_opt_params , get_opt_pars_ud) - 56usize] ; ["Offset of field: ggml_opt_params::optimizer"] [:: std :: mem :: offset_of ! (ggml_opt_params , optimizer) - 64usize] ; } ; unsafe extern "C" { pub fn ggml_opt_default_params (backend_sched : ggml_backend_sched_t , loss_type : ggml_opt_loss_type) -> ggml_opt_params ; } unsafe extern "C" { pub fn ggml_opt_init (params : ggml_opt_params) -> ggml_opt_context_t ; } unsafe extern "C" { pub fn ggml_opt_free (opt_ctx : ggml_opt_context_t) ; } unsafe extern "C" { pub fn ggml_opt_reset (opt_ctx : ggml_opt_context_t , optimizer : bool) ; } unsafe extern "C" { pub fn ggml_opt_static_graphs (opt_ctx : ggml_opt_context_t) -> bool ; } unsafe extern "C" { pub fn ggml_opt_inputs (opt_ctx : ggml_opt_context_t) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_opt_outputs (opt_ctx : ggml_opt_context_t) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_opt_labels (opt_ctx : ggml_opt_context_t) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_opt_loss (opt_ctx : ggml_opt_context_t) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_opt_pred (opt_ctx : ggml_opt_context_t) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_opt_ncorrect (opt_ctx : ggml_opt_context_t) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_opt_grad_acc (opt_ctx : ggml_opt_context_t , node : * mut ggml_tensor) -> * mut ggml_tensor ; } unsafe extern "C" { pub fn ggml_opt_context_optimizer_type (arg1 : ggml_opt_context_t) -> ggml_opt_optimizer_type ; } unsafe extern "C" { pub fn ggml_opt_optimizer_name (arg1 : ggml_opt_optimizer_type) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn ggml_opt_result_init () -> ggml_opt_result_t ; } unsafe extern "C" { pub fn ggml_opt_result_free (result : ggml_opt_result_t) ; } unsafe extern "C" { pub fn ggml_opt_result_reset (result : ggml_opt_result_t) ; } unsafe extern "C" { pub fn ggml_opt_result_ndata (result : ggml_opt_result_t , ndata : * mut i64) ; } unsafe extern "C" { pub fn ggml_opt_result_loss (result : ggml_opt_result_t , loss : * mut f64 , unc : * mut f64) ; } unsafe extern "C" { pub fn ggml_opt_result_pred (result : ggml_opt_result_t , pred : * mut i32) ; } unsafe extern "C" { pub fn ggml_opt_result_accuracy (result : ggml_opt_result_t , accuracy : * mut f64 , unc : * mut f64) ; } unsafe extern "C" { pub fn ggml_opt_prepare_alloc (opt_ctx : ggml_opt_context_t , ctx_compute : * mut ggml_context , gf : * mut ggml_cgraph , inputs : * mut ggml_tensor , outputs : * mut ggml_tensor) ; } unsafe extern "C" { pub fn ggml_opt_alloc (opt_ctx : ggml_opt_context_t , backward : bool) ; } unsafe extern "C" { pub fn ggml_opt_eval (opt_ctx : ggml_opt_context_t , result : ggml_opt_result_t) ; } pub type ggml_opt_epoch_callback = :: std :: option :: Option < unsafe extern "C" fn (train : bool , opt_ctx : ggml_opt_context_t , dataset : ggml_opt_dataset_t , result : ggml_opt_result_t , ibatch : i64 , ibatch_max : i64 , t_start_us : i64) > ; unsafe extern "C" { pub fn ggml_opt_epoch (opt_ctx : ggml_opt_context_t , dataset : ggml_opt_dataset_t , result_train : ggml_opt_result_t , result_eval : ggml_opt_result_t , idata_split : i64 , callback_train : ggml_opt_epoch_callback , callback_eval : ggml_opt_epoch_callback) ; } unsafe extern "C" { pub fn ggml_opt_epoch_callback_progress_bar (train : bool , opt_ctx : ggml_opt_context_t , dataset : ggml_opt_dataset_t , result : ggml_opt_result_t , ibatch : i64 , ibatch_max : i64 , t_start_us : i64) ; } unsafe extern "C" { pub fn ggml_opt_fit (backend_sched : ggml_backend_sched_t , ctx_compute : * mut ggml_context , inputs : * mut ggml_tensor , outputs : * mut ggml_tensor , dataset : ggml_opt_dataset_t , loss_type : ggml_opt_loss_type , optimizer : ggml_opt_optimizer_type , get_opt_pars : ggml_opt_get_optimizer_params , nepoch : i64 , nbatch_logical : i64 , val_split : f32 , silent : bool) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct llama_vocab { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct llama_model { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct llama_context { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct llama_memory_i { _unused : [u8 ; 0] , } pub type llama_memory_t = * mut llama_memory_i ; pub type llama_pos = i32 ; pub type llama_token = i32 ; pub type llama_seq_id = i32 ; pub const LLAMA_VOCAB_TYPE_NONE : llama_vocab_type = 0 ; pub const LLAMA_VOCAB_TYPE_SPM : llama_vocab_type = 1 ; pub const LLAMA_VOCAB_TYPE_BPE : llama_vocab_type = 2 ; pub const LLAMA_VOCAB_TYPE_WPM : llama_vocab_type = 3 ; pub const LLAMA_VOCAB_TYPE_UGM : llama_vocab_type = 4 ; pub const LLAMA_VOCAB_TYPE_RWKV : llama_vocab_type = 5 ; pub const LLAMA_VOCAB_TYPE_PLAMO2 : llama_vocab_type = 6 ; pub type llama_vocab_type = :: std :: os :: raw :: c_uint ; pub const LLAMA_ROPE_TYPE_NONE : llama_rope_type = - 1 ; pub const LLAMA_ROPE_TYPE_NORM : llama_rope_type = 0 ; pub const LLAMA_ROPE_TYPE_NEOX : llama_rope_type = 2 ; pub const LLAMA_ROPE_TYPE_MROPE : llama_rope_type = 8 ; pub const LLAMA_ROPE_TYPE_IMROPE : llama_rope_type = 40 ; pub const LLAMA_ROPE_TYPE_VISION : llama_rope_type = 24 ; pub type llama_rope_type = :: std :: os :: raw :: c_int ; pub const LLAMA_TOKEN_TYPE_UNDEFINED : llama_token_type = 0 ; pub const LLAMA_TOKEN_TYPE_NORMAL : llama_token_type = 1 ; pub const LLAMA_TOKEN_TYPE_UNKNOWN : llama_token_type = 2 ; pub const LLAMA_TOKEN_TYPE_CONTROL : llama_token_type = 3 ; pub const LLAMA_TOKEN_TYPE_USER_DEFINED : llama_token_type = 4 ; pub const LLAMA_TOKEN_TYPE_UNUSED : llama_token_type = 5 ; pub const LLAMA_TOKEN_TYPE_BYTE : llama_token_type = 6 ; pub type llama_token_type = :: std :: os :: raw :: c_uint ; pub const LLAMA_TOKEN_ATTR_UNDEFINED : llama_token_attr = 0 ; pub const LLAMA_TOKEN_ATTR_UNKNOWN : llama_token_attr = 1 ; pub const LLAMA_TOKEN_ATTR_UNUSED : llama_token_attr = 2 ; pub const LLAMA_TOKEN_ATTR_NORMAL : llama_token_attr = 4 ; pub const LLAMA_TOKEN_ATTR_CONTROL : llama_token_attr = 8 ; pub const LLAMA_TOKEN_ATTR_USER_DEFINED : llama_token_attr = 16 ; pub const LLAMA_TOKEN_ATTR_BYTE : llama_token_attr = 32 ; pub const LLAMA_TOKEN_ATTR_NORMALIZED : llama_token_attr = 64 ; pub const LLAMA_TOKEN_ATTR_LSTRIP : llama_token_attr = 128 ; pub const LLAMA_TOKEN_ATTR_RSTRIP : llama_token_attr = 256 ; pub const LLAMA_TOKEN_ATTR_SINGLE_WORD : llama_token_attr = 512 ; pub type llama_token_attr = :: std :: os :: raw :: c_uint ; pub const LLAMA_FTYPE_ALL_F32 : llama_ftype = 0 ; pub const LLAMA_FTYPE_MOSTLY_F16 : llama_ftype = 1 ; pub const LLAMA_FTYPE_MOSTLY_Q4_0 : llama_ftype = 2 ; pub const LLAMA_FTYPE_MOSTLY_Q4_1 : llama_ftype = 3 ; pub const LLAMA_FTYPE_MOSTLY_Q8_0 : llama_ftype = 7 ; pub const LLAMA_FTYPE_MOSTLY_Q5_0 : llama_ftype = 8 ; pub const LLAMA_FTYPE_MOSTLY_Q5_1 : llama_ftype = 9 ; pub const LLAMA_FTYPE_MOSTLY_Q2_K : llama_ftype = 10 ; pub const LLAMA_FTYPE_MOSTLY_Q3_K_S : llama_ftype = 11 ; pub const LLAMA_FTYPE_MOSTLY_Q3_K_M : llama_ftype = 12 ; pub const LLAMA_FTYPE_MOSTLY_Q3_K_L : llama_ftype = 13 ; pub const LLAMA_FTYPE_MOSTLY_Q4_K_S : llama_ftype = 14 ; pub const LLAMA_FTYPE_MOSTLY_Q4_K_M : llama_ftype = 15 ; pub const LLAMA_FTYPE_MOSTLY_Q5_K_S : llama_ftype = 16 ; pub const LLAMA_FTYPE_MOSTLY_Q5_K_M : llama_ftype = 17 ; pub const LLAMA_FTYPE_MOSTLY_Q6_K : llama_ftype = 18 ; pub const LLAMA_FTYPE_MOSTLY_IQ2_XXS : llama_ftype = 19 ; pub const LLAMA_FTYPE_MOSTLY_IQ2_XS : llama_ftype = 20 ; pub const LLAMA_FTYPE_MOSTLY_Q2_K_S : llama_ftype = 21 ; pub const LLAMA_FTYPE_MOSTLY_IQ3_XS : llama_ftype = 22 ; pub const LLAMA_FTYPE_MOSTLY_IQ3_XXS : llama_ftype = 23 ; pub const LLAMA_FTYPE_MOSTLY_IQ1_S : llama_ftype = 24 ; pub const LLAMA_FTYPE_MOSTLY_IQ4_NL : llama_ftype = 25 ; pub const LLAMA_FTYPE_MOSTLY_IQ3_S : llama_ftype = 26 ; pub const LLAMA_FTYPE_MOSTLY_IQ3_M : llama_ftype = 27 ; pub const LLAMA_FTYPE_MOSTLY_IQ2_S : llama_ftype = 28 ; pub const LLAMA_FTYPE_MOSTLY_IQ2_M : llama_ftype = 29 ; pub const LLAMA_FTYPE_MOSTLY_IQ4_XS : llama_ftype = 30 ; pub const LLAMA_FTYPE_MOSTLY_IQ1_M : llama_ftype = 31 ; pub const LLAMA_FTYPE_MOSTLY_BF16 : llama_ftype = 32 ; pub const LLAMA_FTYPE_MOSTLY_TQ1_0 : llama_ftype = 36 ; pub const LLAMA_FTYPE_MOSTLY_TQ2_0 : llama_ftype = 37 ; pub const LLAMA_FTYPE_MOSTLY_MXFP4_MOE : llama_ftype = 38 ; pub const LLAMA_FTYPE_GUESSED : llama_ftype = 1024 ; pub type llama_ftype = :: std :: os :: raw :: c_uint ; pub const LLAMA_ROPE_SCALING_TYPE_UNSPECIFIED : llama_rope_scaling_type = - 1 ; pub const LLAMA_ROPE_SCALING_TYPE_NONE : llama_rope_scaling_type = 0 ; pub const LLAMA_ROPE_SCALING_TYPE_LINEAR : llama_rope_scaling_type = 1 ; pub const LLAMA_ROPE_SCALING_TYPE_YARN : llama_rope_scaling_type = 2 ; pub const LLAMA_ROPE_SCALING_TYPE_LONGROPE : llama_rope_scaling_type = 3 ; pub const LLAMA_ROPE_SCALING_TYPE_MAX_VALUE : llama_rope_scaling_type = 3 ; pub type llama_rope_scaling_type = :: std :: os :: raw :: c_int ; pub const LLAMA_POOLING_TYPE_UNSPECIFIED : llama_pooling_type = - 1 ; pub const LLAMA_POOLING_TYPE_NONE : llama_pooling_type = 0 ; pub const LLAMA_POOLING_TYPE_MEAN : llama_pooling_type = 1 ; pub const LLAMA_POOLING_TYPE_CLS : llama_pooling_type = 2 ; pub const LLAMA_POOLING_TYPE_LAST : llama_pooling_type = 3 ; pub const LLAMA_POOLING_TYPE_RANK : llama_pooling_type = 4 ; pub type llama_pooling_type = :: std :: os :: raw :: c_int ; pub const LLAMA_ATTENTION_TYPE_UNSPECIFIED : llama_attention_type = - 1 ; pub const LLAMA_ATTENTION_TYPE_CAUSAL : llama_attention_type = 0 ; pub const LLAMA_ATTENTION_TYPE_NON_CAUSAL : llama_attention_type = 1 ; pub type llama_attention_type = :: std :: os :: raw :: c_int ; pub const LLAMA_FLASH_ATTN_TYPE_AUTO : llama_flash_attn_type = - 1 ; pub const LLAMA_FLASH_ATTN_TYPE_DISABLED : llama_flash_attn_type = 0 ; pub const LLAMA_FLASH_ATTN_TYPE_ENABLED : llama_flash_attn_type = 1 ; pub type llama_flash_attn_type = :: std :: os :: raw :: c_int ; unsafe extern "C" { pub fn llama_flash_attn_type_name (flash_attn_type : llama_flash_attn_type) -> * const :: std :: os :: raw :: c_char ; } pub const LLAMA_SPLIT_MODE_NONE : llama_split_mode = 0 ; pub const LLAMA_SPLIT_MODE_LAYER : llama_split_mode = 1 ; pub const LLAMA_SPLIT_MODE_ROW : llama_split_mode = 2 ; pub type llama_split_mode = :: std :: os :: raw :: c_uint ; # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq)] pub struct llama_token_data { pub id : llama_token , pub logit : f32 , pub p : f32 , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of llama_token_data"] [:: std :: mem :: size_of :: < llama_token_data > () - 12usize] ; ["Alignment of llama_token_data"] [:: std :: mem :: align_of :: < llama_token_data > () - 4usize] ; ["Offset of field: llama_token_data::id"] [:: std :: mem :: offset_of ! (llama_token_data , id) - 0usize] ; ["Offset of field: llama_token_data::logit"] [:: std :: mem :: offset_of ! (llama_token_data , logit) - 4usize] ; ["Offset of field: llama_token_data::p"] [:: std :: mem :: offset_of ! (llama_token_data , p) - 8usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq)] pub struct llama_token_data_array { pub data : * mut llama_token_data , pub size : usize , pub selected : i64 , pub sorted : bool , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of llama_token_data_array"] [:: std :: mem :: size_of :: < llama_token_data_array > () - 32usize] ; ["Alignment of llama_token_data_array"] [:: std :: mem :: align_of :: < llama_token_data_array > () - 8usize] ; ["Offset of field: llama_token_data_array::data"] [:: std :: mem :: offset_of ! (llama_token_data_array , data) - 0usize] ; ["Offset of field: llama_token_data_array::size"] [:: std :: mem :: offset_of ! (llama_token_data_array , size) - 8usize] ; ["Offset of field: llama_token_data_array::selected"] [:: std :: mem :: offset_of ! (llama_token_data_array , selected) - 16usize] ; ["Offset of field: llama_token_data_array::sorted"] [:: std :: mem :: offset_of ! (llama_token_data_array , sorted) - 24usize] ; } ; pub type llama_progress_callback = :: std :: option :: Option < unsafe extern "C" fn (progress : f32 , user_data : * mut :: std :: os :: raw :: c_void) -> bool > ; # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq)] pub struct llama_batch { pub n_tokens : i32 , pub token : * mut llama_token , pub embd : * mut f32 , pub pos : * mut llama_pos , pub n_seq_id : * mut i32 , pub seq_id : * mut * mut llama_seq_id , pub logits : * mut i8 , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of llama_batch"] [:: std :: mem :: size_of :: < llama_batch > () - 56usize] ; ["Alignment of llama_batch"] [:: std :: mem :: align_of :: < llama_batch > () - 8usize] ; ["Offset of field: llama_batch::n_tokens"] [:: std :: mem :: offset_of ! (llama_batch , n_tokens) - 0usize] ; ["Offset of field: llama_batch::token"] [:: std :: mem :: offset_of ! (llama_batch , token) - 8usize] ; ["Offset of field: llama_batch::embd"] [:: std :: mem :: offset_of ! (llama_batch , embd) - 16usize] ; ["Offset of field: llama_batch::pos"] [:: std :: mem :: offset_of ! (llama_batch , pos) - 24usize] ; ["Offset of field: llama_batch::n_seq_id"] [:: std :: mem :: offset_of ! (llama_batch , n_seq_id) - 32usize] ; ["Offset of field: llama_batch::seq_id"] [:: std :: mem :: offset_of ! (llama_batch , seq_id) - 40usize] ; ["Offset of field: llama_batch::logits"] [:: std :: mem :: offset_of ! (llama_batch , logits) - 48usize] ; } ; pub const LLAMA_KV_OVERRIDE_TYPE_INT : llama_model_kv_override_type = 0 ; pub const LLAMA_KV_OVERRIDE_TYPE_FLOAT : llama_model_kv_override_type = 1 ; pub const LLAMA_KV_OVERRIDE_TYPE_BOOL : llama_model_kv_override_type = 2 ; pub const LLAMA_KV_OVERRIDE_TYPE_STR : llama_model_kv_override_type = 3 ; pub type llama_model_kv_override_type = :: std :: os :: raw :: c_uint ; pub const LLAMA_MODEL_META_KEY_SAMPLING_SEQUENCE : llama_model_meta_key = 0 ; pub const LLAMA_MODEL_META_KEY_SAMPLING_TOP_K : llama_model_meta_key = 1 ; pub const LLAMA_MODEL_META_KEY_SAMPLING_TOP_P : llama_model_meta_key = 2 ; pub const LLAMA_MODEL_META_KEY_SAMPLING_MIN_P : llama_model_meta_key = 3 ; pub const LLAMA_MODEL_META_KEY_SAMPLING_XTC_PROBABILITY : llama_model_meta_key = 4 ; pub const LLAMA_MODEL_META_KEY_SAMPLING_XTC_THRESHOLD : llama_model_meta_key = 5 ; pub const LLAMA_MODEL_META_KEY_SAMPLING_TEMP : llama_model_meta_key = 6 ; pub const LLAMA_MODEL_META_KEY_SAMPLING_PENALTY_LAST_N : llama_model_meta_key = 7 ; pub const LLAMA_MODEL_META_KEY_SAMPLING_PENALTY_REPEAT : llama_model_meta_key = 8 ; pub const LLAMA_MODEL_META_KEY_SAMPLING_MIROSTAT : llama_model_meta_key = 9 ; pub const LLAMA_MODEL_META_KEY_SAMPLING_MIROSTAT_TAU : llama_model_meta_key = 10 ; pub const LLAMA_MODEL_META_KEY_SAMPLING_MIROSTAT_ETA : llama_model_meta_key = 11 ; pub type llama_model_meta_key = :: std :: os :: raw :: c_uint ; # [repr (C)] # [derive (Copy , Clone)] pub struct llama_model_kv_override { pub tag : llama_model_kv_override_type , pub key : [:: std :: os :: raw :: c_char ; 128usize] , pub __bindgen_anon_1 : llama_model_kv_override__bindgen_ty_1 , } # [repr (C)] # [derive (Copy , Clone)] pub union llama_model_kv_override__bindgen_ty_1 { pub val_i64 : i64 , pub val_f64 : f64 , pub val_bool : bool , pub val_str : [:: std :: os :: raw :: c_char ; 128usize] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of llama_model_kv_override__bindgen_ty_1"] [:: std :: mem :: size_of :: < llama_model_kv_override__bindgen_ty_1 > () - 128usize] ; ["Alignment of llama_model_kv_override__bindgen_ty_1"] [:: std :: mem :: align_of :: < llama_model_kv_override__bindgen_ty_1 > () - 8usize] ; ["Offset of field: llama_model_kv_override__bindgen_ty_1::val_i64"] [:: std :: mem :: offset_of ! (llama_model_kv_override__bindgen_ty_1 , val_i64) - 0usize] ; ["Offset of field: llama_model_kv_override__bindgen_ty_1::val_f64"] [:: std :: mem :: offset_of ! (llama_model_kv_override__bindgen_ty_1 , val_f64) - 0usize] ; ["Offset of field: llama_model_kv_override__bindgen_ty_1::val_bool"] [:: std :: mem :: offset_of ! (llama_model_kv_override__bindgen_ty_1 , val_bool) - 0usize] ; ["Offset of field: llama_model_kv_override__bindgen_ty_1::val_str"] [:: std :: mem :: offset_of ! (llama_model_kv_override__bindgen_ty_1 , val_str) - 0usize] ; } ; # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of llama_model_kv_override"] [:: std :: mem :: size_of :: < llama_model_kv_override > () - 264usize] ; ["Alignment of llama_model_kv_override"] [:: std :: mem :: align_of :: < llama_model_kv_override > () - 8usize] ; ["Offset of field: llama_model_kv_override::tag"] [:: std :: mem :: offset_of ! (llama_model_kv_override , tag) - 0usize] ; ["Offset of field: llama_model_kv_override::key"] [:: std :: mem :: offset_of ! (llama_model_kv_override , key) - 4usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq)] pub struct llama_model_tensor_buft_override { pub pattern : * const :: std :: os :: raw :: c_char , pub buft : ggml_backend_buffer_type_t , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of llama_model_tensor_buft_override"] [:: std :: mem :: size_of :: < llama_model_tensor_buft_override > () - 16usize] ; ["Alignment of llama_model_tensor_buft_override"] [:: std :: mem :: align_of :: < llama_model_tensor_buft_override > () - 8usize] ; ["Offset of field: llama_model_tensor_buft_override::pattern"] [:: std :: mem :: offset_of ! (llama_model_tensor_buft_override , pattern) - 0usize] ; ["Offset of field: llama_model_tensor_buft_override::buft"] [:: std :: mem :: offset_of ! (llama_model_tensor_buft_override , buft) - 8usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq)] pub struct llama_model_params { pub devices : * mut ggml_backend_dev_t , pub tensor_buft_overrides : * const llama_model_tensor_buft_override , pub n_gpu_layers : i32 , pub split_mode : llama_split_mode , pub main_gpu : i32 , pub tensor_split : * const f32 , pub progress_callback : llama_progress_callback , pub progress_callback_user_data : * mut :: std :: os :: raw :: c_void , pub kv_overrides : * const llama_model_kv_override , pub vocab_only : bool , pub use_mmap : bool , pub use_direct_io : bool , pub use_mlock : bool , pub check_tensors : bool , pub use_extra_bufts : bool , pub no_host : bool , pub no_alloc : bool , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of llama_model_params"] [:: std :: mem :: size_of :: < llama_model_params > () - 72usize] ; ["Alignment of llama_model_params"] [:: std :: mem :: align_of :: < llama_model_params > () - 8usize] ; ["Offset of field: llama_model_params::devices"] [:: std :: mem :: offset_of ! (llama_model_params , devices) - 0usize] ; ["Offset of field: llama_model_params::tensor_buft_overrides"] [:: std :: mem :: offset_of ! (llama_model_params , tensor_buft_overrides) - 8usize] ; ["Offset of field: llama_model_params::n_gpu_layers"] [:: std :: mem :: offset_of ! (llama_model_params , n_gpu_layers) - 16usize] ; ["Offset of field: llama_model_params::split_mode"] [:: std :: mem :: offset_of ! (llama_model_params , split_mode) - 20usize] ; ["Offset of field: llama_model_params::main_gpu"] [:: std :: mem :: offset_of ! (llama_model_params , main_gpu) - 24usize] ; ["Offset of field: llama_model_params::tensor_split"] [:: std :: mem :: offset_of ! (llama_model_params , tensor_split) - 32usize] ; ["Offset of field: llama_model_params::progress_callback"] [:: std :: mem :: offset_of ! (llama_model_params , progress_callback) - 40usize] ; ["Offset of field: llama_model_params::progress_callback_user_data"] [:: std :: mem :: offset_of ! (llama_model_params , progress_callback_user_data) - 48usize] ; ["Offset of field: llama_model_params::kv_overrides"] [:: std :: mem :: offset_of ! (llama_model_params , kv_overrides) - 56usize] ; ["Offset of field: llama_model_params::vocab_only"] [:: std :: mem :: offset_of ! (llama_model_params , vocab_only) - 64usize] ; ["Offset of field: llama_model_params::use_mmap"] [:: std :: mem :: offset_of ! (llama_model_params , use_mmap) - 65usize] ; ["Offset of field: llama_model_params::use_direct_io"] [:: std :: mem :: offset_of ! (llama_model_params , use_direct_io) - 66usize] ; ["Offset of field: llama_model_params::use_mlock"] [:: std :: mem :: offset_of ! (llama_model_params , use_mlock) - 67usize] ; ["Offset of field: llama_model_params::check_tensors"] [:: std :: mem :: offset_of ! (llama_model_params , check_tensors) - 68usize] ; ["Offset of field: llama_model_params::use_extra_bufts"] [:: std :: mem :: offset_of ! (llama_model_params , use_extra_bufts) - 69usize] ; ["Offset of field: llama_model_params::no_host"] [:: std :: mem :: offset_of ! (llama_model_params , no_host) - 70usize] ; ["Offset of field: llama_model_params::no_alloc"] [:: std :: mem :: offset_of ! (llama_model_params , no_alloc) - 71usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq)] pub struct llama_sampler_seq_config { pub seq_id : llama_seq_id , pub sampler : * mut llama_sampler , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of llama_sampler_seq_config"] [:: std :: mem :: size_of :: < llama_sampler_seq_config > () - 16usize] ; ["Alignment of llama_sampler_seq_config"] [:: std :: mem :: align_of :: < llama_sampler_seq_config > () - 8usize] ; ["Offset of field: llama_sampler_seq_config::seq_id"] [:: std :: mem :: offset_of ! (llama_sampler_seq_config , seq_id) - 0usize] ; ["Offset of field: llama_sampler_seq_config::sampler"] [:: std :: mem :: offset_of ! (llama_sampler_seq_config , sampler) - 8usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq)] pub struct llama_context_params { pub n_ctx : u32 , pub n_batch : u32 , pub n_ubatch : u32 , pub n_seq_max : u32 , pub n_threads : i32 , pub n_threads_batch : i32 , pub rope_scaling_type : llama_rope_scaling_type , pub pooling_type : llama_pooling_type , pub attention_type : llama_attention_type , pub flash_attn_type : llama_flash_attn_type , pub rope_freq_base : f32 , pub rope_freq_scale : f32 , pub yarn_ext_factor : f32 , pub yarn_attn_factor : f32 , pub yarn_beta_fast : f32 , pub yarn_beta_slow : f32 , pub yarn_orig_ctx : u32 , pub defrag_thold : f32 , pub cb_eval : ggml_backend_sched_eval_callback , pub cb_eval_user_data : * mut :: std :: os :: raw :: c_void , pub type_k : ggml_type , pub type_v : ggml_type , pub abort_callback : ggml_abort_callback , pub abort_callback_data : * mut :: std :: os :: raw :: c_void , pub embeddings : bool , pub offload_kqv : bool , pub no_perf : bool , pub op_offload : bool , pub swa_full : bool , pub kv_unified : bool , pub samplers : * mut llama_sampler_seq_config , pub n_samplers : usize , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of llama_context_params"] [:: std :: mem :: size_of :: < llama_context_params > () - 136usize] ; ["Alignment of llama_context_params"] [:: std :: mem :: align_of :: < llama_context_params > () - 8usize] ; ["Offset of field: llama_context_params::n_ctx"] [:: std :: mem :: offset_of ! (llama_context_params , n_ctx) - 0usize] ; ["Offset of field: llama_context_params::n_batch"] [:: std :: mem :: offset_of ! (llama_context_params , n_batch) - 4usize] ; ["Offset of field: llama_context_params::n_ubatch"] [:: std :: mem :: offset_of ! (llama_context_params , n_ubatch) - 8usize] ; ["Offset of field: llama_context_params::n_seq_max"] [:: std :: mem :: offset_of ! (llama_context_params , n_seq_max) - 12usize] ; ["Offset of field: llama_context_params::n_threads"] [:: std :: mem :: offset_of ! (llama_context_params , n_threads) - 16usize] ; ["Offset of field: llama_context_params::n_threads_batch"] [:: std :: mem :: offset_of ! (llama_context_params , n_threads_batch) - 20usize] ; ["Offset of field: llama_context_params::rope_scaling_type"] [:: std :: mem :: offset_of ! (llama_context_params , rope_scaling_type) - 24usize] ; ["Offset of field: llama_context_params::pooling_type"] [:: std :: mem :: offset_of ! (llama_context_params , pooling_type) - 28usize] ; ["Offset of field: llama_context_params::attention_type"] [:: std :: mem :: offset_of ! (llama_context_params , attention_type) - 32usize] ; ["Offset of field: llama_context_params::flash_attn_type"] [:: std :: mem :: offset_of ! (llama_context_params , flash_attn_type) - 36usize] ; ["Offset of field: llama_context_params::rope_freq_base"] [:: std :: mem :: offset_of ! (llama_context_params , rope_freq_base) - 40usize] ; ["Offset of field: llama_context_params::rope_freq_scale"] [:: std :: mem :: offset_of ! (llama_context_params , rope_freq_scale) - 44usize] ; ["Offset of field: llama_context_params::yarn_ext_factor"] [:: std :: mem :: offset_of ! (llama_context_params , yarn_ext_factor) - 48usize] ; ["Offset of field: llama_context_params::yarn_attn_factor"] [:: std :: mem :: offset_of ! (llama_context_params , yarn_attn_factor) - 52usize] ; ["Offset of field: llama_context_params::yarn_beta_fast"] [:: std :: mem :: offset_of ! (llama_context_params , yarn_beta_fast) - 56usize] ; ["Offset of field: llama_context_params::yarn_beta_slow"] [:: std :: mem :: offset_of ! (llama_context_params , yarn_beta_slow) - 60usize] ; ["Offset of field: llama_context_params::yarn_orig_ctx"] [:: std :: mem :: offset_of ! (llama_context_params , yarn_orig_ctx) - 64usize] ; ["Offset of field: llama_context_params::defrag_thold"] [:: std :: mem :: offset_of ! (llama_context_params , defrag_thold) - 68usize] ; ["Offset of field: llama_context_params::cb_eval"] [:: std :: mem :: offset_of ! (llama_context_params , cb_eval) - 72usize] ; ["Offset of field: llama_context_params::cb_eval_user_data"] [:: std :: mem :: offset_of ! (llama_context_params , cb_eval_user_data) - 80usize] ; ["Offset of field: llama_context_params::type_k"] [:: std :: mem :: offset_of ! (llama_context_params , type_k) - 88usize] ; ["Offset of field: llama_context_params::type_v"] [:: std :: mem :: offset_of ! (llama_context_params , type_v) - 92usize] ; ["Offset of field: llama_context_params::abort_callback"] [:: std :: mem :: offset_of ! (llama_context_params , abort_callback) - 96usize] ; ["Offset of field: llama_context_params::abort_callback_data"] [:: std :: mem :: offset_of ! (llama_context_params , abort_callback_data) - 104usize] ; ["Offset of field: llama_context_params::embeddings"] [:: std :: mem :: offset_of ! (llama_context_params , embeddings) - 112usize] ; ["Offset of field: llama_context_params::offload_kqv"] [:: std :: mem :: offset_of ! (llama_context_params , offload_kqv) - 113usize] ; ["Offset of field: llama_context_params::no_perf"] [:: std :: mem :: offset_of ! (llama_context_params , no_perf) - 114usize] ; ["Offset of field: llama_context_params::op_offload"] [:: std :: mem :: offset_of ! (llama_context_params , op_offload) - 115usize] ; ["Offset of field: llama_context_params::swa_full"] [:: std :: mem :: offset_of ! (llama_context_params , swa_full) - 116usize] ; ["Offset of field: llama_context_params::kv_unified"] [:: std :: mem :: offset_of ! (llama_context_params , kv_unified) - 117usize] ; ["Offset of field: llama_context_params::samplers"] [:: std :: mem :: offset_of ! (llama_context_params , samplers) - 120usize] ; ["Offset of field: llama_context_params::n_samplers"] [:: std :: mem :: offset_of ! (llama_context_params , n_samplers) - 128usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq)] pub struct llama_model_quantize_params { pub nthread : i32 , pub ftype : llama_ftype , pub output_tensor_type : ggml_type , pub token_embedding_type : ggml_type , pub allow_requantize : bool , pub quantize_output_tensor : bool , pub only_copy : bool , pub pure_ : bool , pub keep_split : bool , pub imatrix : * mut :: std :: os :: raw :: c_void , pub kv_overrides : * mut :: std :: os :: raw :: c_void , pub tensor_types : * mut :: std :: os :: raw :: c_void , pub prune_layers : * mut :: std :: os :: raw :: c_void , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of llama_model_quantize_params"] [:: std :: mem :: size_of :: < llama_model_quantize_params > () - 56usize] ; ["Alignment of llama_model_quantize_params"] [:: std :: mem :: align_of :: < llama_model_quantize_params > () - 8usize] ; ["Offset of field: llama_model_quantize_params::nthread"] [:: std :: mem :: offset_of ! (llama_model_quantize_params , nthread) - 0usize] ; ["Offset of field: llama_model_quantize_params::ftype"] [:: std :: mem :: offset_of ! (llama_model_quantize_params , ftype) - 4usize] ; ["Offset of field: llama_model_quantize_params::output_tensor_type"] [:: std :: mem :: offset_of ! (llama_model_quantize_params , output_tensor_type) - 8usize] ; ["Offset of field: llama_model_quantize_params::token_embedding_type"] [:: std :: mem :: offset_of ! (llama_model_quantize_params , token_embedding_type) - 12usize] ; ["Offset of field: llama_model_quantize_params::allow_requantize"] [:: std :: mem :: offset_of ! (llama_model_quantize_params , allow_requantize) - 16usize] ; ["Offset of field: llama_model_quantize_params::quantize_output_tensor"] [:: std :: mem :: offset_of ! (llama_model_quantize_params , quantize_output_tensor) - 17usize] ; ["Offset of field: llama_model_quantize_params::only_copy"] [:: std :: mem :: offset_of ! (llama_model_quantize_params , only_copy) - 18usize] ; ["Offset of field: llama_model_quantize_params::pure_"] [:: std :: mem :: offset_of ! (llama_model_quantize_params , pure_) - 19usize] ; ["Offset of field: llama_model_quantize_params::keep_split"] [:: std :: mem :: offset_of ! (llama_model_quantize_params , keep_split) - 20usize] ; ["Offset of field: llama_model_quantize_params::imatrix"] [:: std :: mem :: offset_of ! (llama_model_quantize_params , imatrix) - 24usize] ; ["Offset of field: llama_model_quantize_params::kv_overrides"] [:: std :: mem :: offset_of ! (llama_model_quantize_params , kv_overrides) - 32usize] ; ["Offset of field: llama_model_quantize_params::tensor_types"] [:: std :: mem :: offset_of ! (llama_model_quantize_params , tensor_types) - 40usize] ; ["Offset of field: llama_model_quantize_params::prune_layers"] [:: std :: mem :: offset_of ! (llama_model_quantize_params , prune_layers) - 48usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq)] pub struct llama_logit_bias { pub token : llama_token , pub bias : f32 , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of llama_logit_bias"] [:: std :: mem :: size_of :: < llama_logit_bias > () - 8usize] ; ["Alignment of llama_logit_bias"] [:: std :: mem :: align_of :: < llama_logit_bias > () - 4usize] ; ["Offset of field: llama_logit_bias::token"] [:: std :: mem :: offset_of ! (llama_logit_bias , token) - 0usize] ; ["Offset of field: llama_logit_bias::bias"] [:: std :: mem :: offset_of ! (llama_logit_bias , bias) - 4usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq)] pub struct llama_sampler_chain_params { pub no_perf : bool , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of llama_sampler_chain_params"] [:: std :: mem :: size_of :: < llama_sampler_chain_params > () - 1usize] ; ["Alignment of llama_sampler_chain_params"] [:: std :: mem :: align_of :: < llama_sampler_chain_params > () - 1usize] ; ["Offset of field: llama_sampler_chain_params::no_perf"] [:: std :: mem :: offset_of ! (llama_sampler_chain_params , no_perf) - 0usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq)] pub struct llama_chat_message { pub role : * const :: std :: os :: raw :: c_char , pub content : * const :: std :: os :: raw :: c_char , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of llama_chat_message"] [:: std :: mem :: size_of :: < llama_chat_message > () - 16usize] ; ["Alignment of llama_chat_message"] [:: std :: mem :: align_of :: < llama_chat_message > () - 8usize] ; ["Offset of field: llama_chat_message::role"] [:: std :: mem :: offset_of ! (llama_chat_message , role) - 0usize] ; ["Offset of field: llama_chat_message::content"] [:: std :: mem :: offset_of ! (llama_chat_message , content) - 8usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct llama_adapter_lora { _unused : [u8 ; 0] , } unsafe extern "C" { pub fn llama_model_default_params () -> llama_model_params ; } unsafe extern "C" { pub fn llama_context_default_params () -> llama_context_params ; } unsafe extern "C" { pub fn llama_sampler_chain_default_params () -> llama_sampler_chain_params ; } unsafe extern "C" { pub fn llama_model_quantize_default_params () -> llama_model_quantize_params ; } unsafe extern "C" { pub fn llama_backend_init () ; } unsafe extern "C" { pub fn llama_backend_free () ; } unsafe extern "C" { pub fn llama_numa_init (numa : ggml_numa_strategy) ; } unsafe extern "C" { pub fn llama_attach_threadpool (ctx : * mut llama_context , threadpool : ggml_threadpool_t , threadpool_batch : ggml_threadpool_t) ; } unsafe extern "C" { pub fn llama_detach_threadpool (ctx : * mut llama_context) ; } unsafe extern "C" { pub fn llama_load_model_from_file (path_model : * const :: std :: os :: raw :: c_char , params : llama_model_params) -> * mut llama_model ; } unsafe extern "C" { pub fn llama_model_load_from_file (path_model : * const :: std :: os :: raw :: c_char , params : llama_model_params) -> * mut llama_model ; } unsafe extern "C" { pub fn llama_model_load_from_splits (paths : * mut * const :: std :: os :: raw :: c_char , n_paths : usize , params : llama_model_params) -> * mut llama_model ; } unsafe extern "C" { pub fn llama_model_save_to_file (model : * const llama_model , path_model : * const :: std :: os :: raw :: c_char) ; } unsafe extern "C" { pub fn llama_free_model (model : * mut llama_model) ; } unsafe extern "C" { pub fn llama_model_free (model : * mut llama_model) ; } unsafe extern "C" { pub fn llama_init_from_model (model : * mut llama_model , params : llama_context_params) -> * mut llama_context ; } unsafe extern "C" { pub fn llama_new_context_with_model (model : * mut llama_model , params : llama_context_params) -> * mut llama_context ; } unsafe extern "C" { pub fn llama_free (ctx : * mut llama_context) ; } pub const LLAMA_PARAMS_FIT_STATUS_SUCCESS : llama_params_fit_status = 0 ; pub const LLAMA_PARAMS_FIT_STATUS_FAILURE : llama_params_fit_status = 1 ; pub const LLAMA_PARAMS_FIT_STATUS_ERROR : llama_params_fit_status = 2 ; pub type llama_params_fit_status = :: std :: os :: raw :: c_uint ; unsafe extern "C" { pub fn llama_params_fit (path_model : * const :: std :: os :: raw :: c_char , mparams : * mut llama_model_params , cparams : * mut llama_context_params , tensor_split : * mut f32 , tensor_buft_overrides : * mut llama_model_tensor_buft_override , margins : * mut usize , n_ctx_min : u32 , log_level : ggml_log_level) -> llama_params_fit_status ; } unsafe extern "C" { pub fn llama_time_us () -> i64 ; } unsafe extern "C" { pub fn llama_max_devices () -> usize ; } unsafe extern "C" { pub fn llama_max_parallel_sequences () -> usize ; } unsafe extern "C" { pub fn llama_max_tensor_buft_overrides () -> usize ; } unsafe extern "C" { pub fn llama_supports_mmap () -> bool ; } unsafe extern "C" { pub fn llama_supports_mlock () -> bool ; } unsafe extern "C" { pub fn llama_supports_gpu_offload () -> bool ; } unsafe extern "C" { pub fn llama_supports_rpc () -> bool ; } unsafe extern "C" { pub fn llama_n_ctx (ctx : * const llama_context) -> u32 ; } unsafe extern "C" { pub fn llama_n_ctx_seq (ctx : * const llama_context) -> u32 ; } unsafe extern "C" { pub fn llama_n_batch (ctx : * const llama_context) -> u32 ; } unsafe extern "C" { pub fn llama_n_ubatch (ctx : * const llama_context) -> u32 ; } unsafe extern "C" { pub fn llama_n_seq_max (ctx : * const llama_context) -> u32 ; } unsafe extern "C" { pub fn llama_n_ctx_train (model : * const llama_model) -> i32 ; } unsafe extern "C" { pub fn llama_n_embd (model : * const llama_model) -> i32 ; } unsafe extern "C" { pub fn llama_n_layer (model : * const llama_model) -> i32 ; } unsafe extern "C" { pub fn llama_n_head (model : * const llama_model) -> i32 ; } unsafe extern "C" { pub fn llama_n_vocab (vocab : * const llama_vocab) -> i32 ; } unsafe extern "C" { pub fn llama_get_model (ctx : * const llama_context) -> * const llama_model ; } unsafe extern "C" { pub fn llama_get_memory (ctx : * const llama_context) -> llama_memory_t ; } unsafe extern "C" { pub fn llama_pooling_type (ctx : * const llama_context) -> llama_pooling_type ; } unsafe extern "C" { pub fn llama_model_get_vocab (model : * const llama_model) -> * const llama_vocab ; } unsafe extern "C" { pub fn llama_model_rope_type (model : * const llama_model) -> llama_rope_type ; } unsafe extern "C" { pub fn llama_model_n_ctx_train (model : * const llama_model) -> i32 ; } unsafe extern "C" { pub fn llama_model_n_embd (model : * const llama_model) -> i32 ; } unsafe extern "C" { pub fn llama_model_n_embd_inp (model : * const llama_model) -> i32 ; } unsafe extern "C" { pub fn llama_model_n_embd_out (model : * const llama_model) -> i32 ; } unsafe extern "C" { pub fn llama_model_n_layer (model : * const llama_model) -> i32 ; } unsafe extern "C" { pub fn llama_model_n_head (model : * const llama_model) -> i32 ; } unsafe extern "C" { pub fn llama_model_n_head_kv (model : * const llama_model) -> i32 ; } unsafe extern "C" { pub fn llama_model_n_swa (model : * const llama_model) -> i32 ; } unsafe extern "C" { pub fn llama_model_rope_freq_scale_train (model : * const llama_model) -> f32 ; } unsafe extern "C" { pub fn llama_model_n_cls_out (model : * const llama_model) -> u32 ; } unsafe extern "C" { pub fn llama_model_cls_label (model : * const llama_model , i : u32) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn llama_vocab_type (vocab : * const llama_vocab) -> llama_vocab_type ; } unsafe extern "C" { pub fn llama_vocab_n_tokens (vocab : * const llama_vocab) -> i32 ; } unsafe extern "C" { pub fn llama_model_meta_val_str (model : * const llama_model , key : * const :: std :: os :: raw :: c_char , buf : * mut :: std :: os :: raw :: c_char , buf_size : usize) -> i32 ; } unsafe extern "C" { pub fn llama_model_meta_count (model : * const llama_model) -> i32 ; } unsafe extern "C" { pub fn llama_model_meta_key_str (key : llama_model_meta_key) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn llama_model_meta_key_by_index (model : * const llama_model , i : i32 , buf : * mut :: std :: os :: raw :: c_char , buf_size : usize) -> i32 ; } unsafe extern "C" { pub fn llama_model_meta_val_str_by_index (model : * const llama_model , i : i32 , buf : * mut :: std :: os :: raw :: c_char , buf_size : usize) -> i32 ; } unsafe extern "C" { pub fn llama_model_desc (model : * const llama_model , buf : * mut :: std :: os :: raw :: c_char , buf_size : usize) -> i32 ; } unsafe extern "C" { pub fn llama_model_size (model : * const llama_model) -> u64 ; } unsafe extern "C" { pub fn llama_model_chat_template (model : * const llama_model , name : * const :: std :: os :: raw :: c_char) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn llama_model_n_params (model : * const llama_model) -> u64 ; } unsafe extern "C" { pub fn llama_model_has_encoder (model : * const llama_model) -> bool ; } unsafe extern "C" { pub fn llama_model_has_decoder (model : * const llama_model) -> bool ; } unsafe extern "C" { pub fn llama_model_decoder_start_token (model : * const llama_model) -> llama_token ; } unsafe extern "C" { pub fn llama_model_is_recurrent (model : * const llama_model) -> bool ; } unsafe extern "C" { pub fn llama_model_is_hybrid (model : * const llama_model) -> bool ; } unsafe extern "C" { pub fn llama_model_is_diffusion (model : * const llama_model) -> bool ; } unsafe extern "C" { pub fn llama_model_quantize (fname_inp : * const :: std :: os :: raw :: c_char , fname_out : * const :: std :: os :: raw :: c_char , params : * const llama_model_quantize_params) -> u32 ; } unsafe extern "C" { pub fn llama_adapter_lora_init (model : * mut llama_model , path_lora : * const :: std :: os :: raw :: c_char) -> * mut llama_adapter_lora ; } unsafe extern "C" { pub fn llama_adapter_meta_val_str (adapter : * const llama_adapter_lora , key : * const :: std :: os :: raw :: c_char , buf : * mut :: std :: os :: raw :: c_char , buf_size : usize) -> i32 ; } unsafe extern "C" { pub fn llama_adapter_meta_count (adapter : * const llama_adapter_lora) -> i32 ; } unsafe extern "C" { pub fn llama_adapter_meta_key_by_index (adapter : * const llama_adapter_lora , i : i32 , buf : * mut :: std :: os :: raw :: c_char , buf_size : usize) -> i32 ; } unsafe extern "C" { pub fn llama_adapter_meta_val_str_by_index (adapter : * const llama_adapter_lora , i : i32 , buf : * mut :: std :: os :: raw :: c_char , buf_size : usize) -> i32 ; } unsafe extern "C" { pub fn llama_adapter_lora_free (adapter : * mut llama_adapter_lora) ; } unsafe extern "C" { pub fn llama_adapter_get_alora_n_invocation_tokens (adapter : * const llama_adapter_lora) -> u64 ; } unsafe extern "C" { pub fn llama_adapter_get_alora_invocation_tokens (adapter : * const llama_adapter_lora) -> * const llama_token ; } unsafe extern "C" { pub fn llama_set_adapter_lora (ctx : * mut llama_context , adapter : * mut llama_adapter_lora , scale : f32) -> i32 ; } unsafe extern "C" { pub fn llama_rm_adapter_lora (ctx : * mut llama_context , adapter : * mut llama_adapter_lora) -> i32 ; } unsafe extern "C" { pub fn llama_clear_adapter_lora (ctx : * mut llama_context) ; } unsafe extern "C" { pub fn llama_apply_adapter_cvec (ctx : * mut llama_context , data : * const f32 , len : usize , n_embd : i32 , il_start : i32 , il_end : i32) -> i32 ; } unsafe extern "C" { pub fn llama_memory_clear (mem : llama_memory_t , data : bool) ; } unsafe extern "C" { pub fn llama_memory_seq_rm (mem : llama_memory_t , seq_id : llama_seq_id , p0 : llama_pos , p1 : llama_pos) -> bool ; } unsafe extern "C" { pub fn llama_memory_seq_cp (mem : llama_memory_t , seq_id_src : llama_seq_id , seq_id_dst : llama_seq_id , p0 : llama_pos , p1 : llama_pos) ; } unsafe extern "C" { pub fn llama_memory_seq_keep (mem : llama_memory_t , seq_id : llama_seq_id) ; } unsafe extern "C" { pub fn llama_memory_seq_add (mem : llama_memory_t , seq_id : llama_seq_id , p0 : llama_pos , p1 : llama_pos , delta : llama_pos) ; } unsafe extern "C" { pub fn llama_memory_seq_div (mem : llama_memory_t , seq_id : llama_seq_id , p0 : llama_pos , p1 : llama_pos , d : :: std :: os :: raw :: c_int) ; } unsafe extern "C" { pub fn llama_memory_seq_pos_min (mem : llama_memory_t , seq_id : llama_seq_id) -> llama_pos ; } unsafe extern "C" { pub fn llama_memory_seq_pos_max (mem : llama_memory_t , seq_id : llama_seq_id) -> llama_pos ; } unsafe extern "C" { pub fn llama_memory_can_shift (mem : llama_memory_t) -> bool ; } unsafe extern "C" { pub fn llama_state_get_size (ctx : * mut llama_context) -> usize ; } unsafe extern "C" { pub fn llama_get_state_size (ctx : * mut llama_context) -> usize ; } unsafe extern "C" { pub fn llama_state_get_data (ctx : * mut llama_context , dst : * mut u8 , size : usize) -> usize ; } unsafe extern "C" { pub fn llama_copy_state_data (ctx : * mut llama_context , dst : * mut u8) -> usize ; } unsafe extern "C" { pub fn llama_state_set_data (ctx : * mut llama_context , src : * const u8 , size : usize) -> usize ; } unsafe extern "C" { pub fn llama_set_state_data (ctx : * mut llama_context , src : * const u8) -> usize ; } unsafe extern "C" { pub fn llama_state_load_file (ctx : * mut llama_context , path_session : * const :: std :: os :: raw :: c_char , tokens_out : * mut llama_token , n_token_capacity : usize , n_token_count_out : * mut usize) -> bool ; } unsafe extern "C" { pub fn llama_load_session_file (ctx : * mut llama_context , path_session : * const :: std :: os :: raw :: c_char , tokens_out : * mut llama_token , n_token_capacity : usize , n_token_count_out : * mut usize) -> bool ; } unsafe extern "C" { pub fn llama_state_save_file (ctx : * mut llama_context , path_session : * const :: std :: os :: raw :: c_char , tokens : * const llama_token , n_token_count : usize) -> bool ; } unsafe extern "C" { pub fn llama_save_session_file (ctx : * mut llama_context , path_session : * const :: std :: os :: raw :: c_char , tokens : * const llama_token , n_token_count : usize) -> bool ; } unsafe extern "C" { pub fn llama_state_seq_get_size (ctx : * mut llama_context , seq_id : llama_seq_id) -> usize ; } unsafe extern "C" { pub fn llama_state_seq_get_data (ctx : * mut llama_context , dst : * mut u8 , size : usize , seq_id : llama_seq_id) -> usize ; } unsafe extern "C" { pub fn llama_state_seq_set_data (ctx : * mut llama_context , src : * const u8 , size : usize , dest_seq_id : llama_seq_id) -> usize ; } unsafe extern "C" { pub fn llama_state_seq_save_file (ctx : * mut llama_context , filepath : * const :: std :: os :: raw :: c_char , seq_id : llama_seq_id , tokens : * const llama_token , n_token_count : usize) -> usize ; } unsafe extern "C" { pub fn llama_state_seq_load_file (ctx : * mut llama_context , filepath : * const :: std :: os :: raw :: c_char , dest_seq_id : llama_seq_id , tokens_out : * mut llama_token , n_token_capacity : usize , n_token_count_out : * mut usize) -> usize ; } pub type llama_state_seq_flags = u32 ; unsafe extern "C" { pub fn llama_state_seq_get_size_ext (ctx : * mut llama_context , seq_id : llama_seq_id , flags : llama_state_seq_flags) -> usize ; } unsafe extern "C" { pub fn llama_state_seq_get_data_ext (ctx : * mut llama_context , dst : * mut u8 , size : usize , seq_id : llama_seq_id , flags : llama_state_seq_flags) -> usize ; } unsafe extern "C" { pub fn llama_state_seq_set_data_ext (ctx : * mut llama_context , src : * const u8 , size : usize , dest_seq_id : llama_seq_id , flags : llama_state_seq_flags) -> usize ; } unsafe extern "C" { pub fn llama_batch_get_one (tokens : * mut llama_token , n_tokens : i32) -> llama_batch ; } unsafe extern "C" { pub fn llama_batch_init (n_tokens : i32 , embd : i32 , n_seq_max : i32) -> llama_batch ; } unsafe extern "C" { pub fn llama_batch_free (batch : llama_batch) ; } unsafe extern "C" { pub fn llama_encode (ctx : * mut llama_context , batch : llama_batch) -> i32 ; } unsafe extern "C" { pub fn llama_decode (ctx : * mut llama_context , batch : llama_batch) -> i32 ; } unsafe extern "C" { pub fn llama_set_n_threads (ctx : * mut llama_context , n_threads : i32 , n_threads_batch : i32) ; } unsafe extern "C" { pub fn llama_n_threads (ctx : * mut llama_context) -> i32 ; } unsafe extern "C" { pub fn llama_n_threads_batch (ctx : * mut llama_context) -> i32 ; } unsafe extern "C" { pub fn llama_set_embeddings (ctx : * mut llama_context , embeddings : bool) ; } unsafe extern "C" { pub fn llama_set_causal_attn (ctx : * mut llama_context , causal_attn : bool) ; } unsafe extern "C" { pub fn llama_set_warmup (ctx : * mut llama_context , warmup : bool) ; } unsafe extern "C" { pub fn llama_set_abort_callback (ctx : * mut llama_context , abort_callback : ggml_abort_callback , abort_callback_data : * mut :: std :: os :: raw :: c_void) ; } unsafe extern "C" { pub fn llama_synchronize (ctx : * mut llama_context) ; } unsafe extern "C" { pub fn llama_get_logits (ctx : * mut llama_context) -> * mut f32 ; } unsafe extern "C" { pub fn llama_get_logits_ith (ctx : * mut llama_context , i : i32) -> * mut f32 ; } unsafe extern "C" { pub fn llama_get_embeddings (ctx : * mut llama_context) -> * mut f32 ; } unsafe extern "C" { pub fn llama_get_embeddings_ith (ctx : * mut llama_context , i : i32) -> * mut f32 ; } unsafe extern "C" { pub fn llama_get_embeddings_seq (ctx : * mut llama_context , seq_id : llama_seq_id) -> * mut f32 ; } unsafe extern "C" { pub fn llama_get_sampled_token_ith (ctx : * mut llama_context , i : i32) -> llama_token ; } unsafe extern "C" { pub fn llama_get_sampled_probs_ith (ctx : * mut llama_context , i : i32) -> * mut f32 ; } unsafe extern "C" { pub fn llama_get_sampled_probs_count_ith (ctx : * mut llama_context , i : i32) -> u32 ; } unsafe extern "C" { pub fn llama_get_sampled_logits_ith (ctx : * mut llama_context , i : i32) -> * mut f32 ; } unsafe extern "C" { pub fn llama_get_sampled_logits_count_ith (ctx : * mut llama_context , i : i32) -> u32 ; } unsafe extern "C" { pub fn llama_get_sampled_candidates_ith (ctx : * mut llama_context , i : i32) -> * mut llama_token ; } unsafe extern "C" { pub fn llama_get_sampled_candidates_count_ith (ctx : * mut llama_context , i : i32) -> u32 ; } unsafe extern "C" { pub fn llama_vocab_get_text (vocab : * const llama_vocab , token : llama_token) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn llama_vocab_get_score (vocab : * const llama_vocab , token : llama_token) -> f32 ; } unsafe extern "C" { pub fn llama_vocab_get_attr (vocab : * const llama_vocab , token : llama_token) -> llama_token_attr ; } unsafe extern "C" { pub fn llama_vocab_is_eog (vocab : * const llama_vocab , token : llama_token) -> bool ; } unsafe extern "C" { pub fn llama_vocab_is_control (vocab : * const llama_vocab , token : llama_token) -> bool ; } unsafe extern "C" { pub fn llama_vocab_bos (vocab : * const llama_vocab) -> llama_token ; } unsafe extern "C" { pub fn llama_vocab_eos (vocab : * const llama_vocab) -> llama_token ; } unsafe extern "C" { pub fn llama_vocab_eot (vocab : * const llama_vocab) -> llama_token ; } unsafe extern "C" { pub fn llama_vocab_sep (vocab : * const llama_vocab) -> llama_token ; } unsafe extern "C" { pub fn llama_vocab_nl (vocab : * const llama_vocab) -> llama_token ; } unsafe extern "C" { pub fn llama_vocab_pad (vocab : * const llama_vocab) -> llama_token ; } unsafe extern "C" { pub fn llama_vocab_mask (vocab : * const llama_vocab) -> llama_token ; } unsafe extern "C" { pub fn llama_vocab_get_add_bos (vocab : * const llama_vocab) -> bool ; } unsafe extern "C" { pub fn llama_vocab_get_add_eos (vocab : * const llama_vocab) -> bool ; } unsafe extern "C" { pub fn llama_vocab_get_add_sep (vocab : * const llama_vocab) -> bool ; } unsafe extern "C" { pub fn llama_vocab_fim_pre (vocab : * const llama_vocab) -> llama_token ; } unsafe extern "C" { pub fn llama_vocab_fim_suf (vocab : * const llama_vocab) -> llama_token ; } unsafe extern "C" { pub fn llama_vocab_fim_mid (vocab : * const llama_vocab) -> llama_token ; } unsafe extern "C" { pub fn llama_vocab_fim_pad (vocab : * const llama_vocab) -> llama_token ; } unsafe extern "C" { pub fn llama_vocab_fim_rep (vocab : * const llama_vocab) -> llama_token ; } unsafe extern "C" { pub fn llama_vocab_fim_sep (vocab : * const llama_vocab) -> llama_token ; } unsafe extern "C" { pub fn llama_token_get_text (vocab : * const llama_vocab , token : llama_token) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn llama_token_get_score (vocab : * const llama_vocab , token : llama_token) -> f32 ; } unsafe extern "C" { pub fn llama_token_get_attr (vocab : * const llama_vocab , token : llama_token) -> llama_token_attr ; } unsafe extern "C" { pub fn llama_token_is_eog (vocab : * const llama_vocab , token : llama_token) -> bool ; } unsafe extern "C" { pub fn llama_token_is_control (vocab : * const llama_vocab , token : llama_token) -> bool ; } unsafe extern "C" { pub fn llama_token_bos (vocab : * const llama_vocab) -> llama_token ; } unsafe extern "C" { pub fn llama_token_eos (vocab : * const llama_vocab) -> llama_token ; } unsafe extern "C" { pub fn llama_token_eot (vocab : * const llama_vocab) -> llama_token ; } unsafe extern "C" { pub fn llama_token_cls (vocab : * const llama_vocab) -> llama_token ; } unsafe extern "C" { pub fn llama_token_sep (vocab : * const llama_vocab) -> llama_token ; } unsafe extern "C" { pub fn llama_token_nl (vocab : * const llama_vocab) -> llama_token ; } unsafe extern "C" { pub fn llama_token_pad (vocab : * const llama_vocab) -> llama_token ; } unsafe extern "C" { pub fn llama_add_bos_token (vocab : * const llama_vocab) -> bool ; } unsafe extern "C" { pub fn llama_add_eos_token (vocab : * const llama_vocab) -> bool ; } unsafe extern "C" { pub fn llama_token_fim_pre (vocab : * const llama_vocab) -> llama_token ; } unsafe extern "C" { pub fn llama_token_fim_suf (vocab : * const llama_vocab) -> llama_token ; } unsafe extern "C" { pub fn llama_token_fim_mid (vocab : * const llama_vocab) -> llama_token ; } unsafe extern "C" { pub fn llama_token_fim_pad (vocab : * const llama_vocab) -> llama_token ; } unsafe extern "C" { pub fn llama_token_fim_rep (vocab : * const llama_vocab) -> llama_token ; } unsafe extern "C" { pub fn llama_token_fim_sep (vocab : * const llama_vocab) -> llama_token ; } unsafe extern "C" { pub fn llama_vocab_cls (vocab : * const llama_vocab) -> llama_token ; } unsafe extern "C" { # [doc = " @details Convert the provided text into tokens.\n @param tokens The tokens pointer must be large enough to hold the resulting tokens.\n @return Returns the number of tokens on success, no more than n_tokens_max\n @return Returns a negative number on failure - the number of tokens that would have been returned\n @return Returns INT32_MIN on overflow (e.g., tokenization result size exceeds int32_t limit)\n @param add_special Allow to add BOS and EOS tokens if model is configured to do so.\n @param parse_special Allow tokenizing special and/or control tokens which otherwise are not exposed and treated\n                      as plaintext. Does not insert a leading space."] pub fn llama_tokenize (vocab : * const llama_vocab , text : * const :: std :: os :: raw :: c_char , text_len : i32 , tokens : * mut llama_token , n_tokens_max : i32 , add_special : bool , parse_special : bool) -> i32 ; } unsafe extern "C" { pub fn llama_token_to_piece (vocab : * const llama_vocab , token : llama_token , buf : * mut :: std :: os :: raw :: c_char , length : i32 , lstrip : i32 , special : bool) -> i32 ; } unsafe extern "C" { # [doc = " @details Convert the provided tokens into text (inverse of llama_tokenize()).\n @param text The char pointer must be large enough to hold the resulting text.\n @return Returns the number of chars/bytes on success, no more than text_len_max.\n @return Returns a negative number on failure - the number of chars/bytes that would have been returned.\n @param remove_special Allow to remove BOS and EOS tokens if model is configured to do so.\n @param unparse_special If true, special tokens are rendered in the output."] pub fn llama_detokenize (vocab : * const llama_vocab , tokens : * const llama_token , n_tokens : i32 , text : * mut :: std :: os :: raw :: c_char , text_len_max : i32 , remove_special : bool , unparse_special : bool) -> i32 ; } unsafe extern "C" { # [doc = " Apply chat template. Inspired by hf apply_chat_template() on python.\n Both \"model\" and \"custom_template\" are optional, but at least one is required. \"custom_template\" has higher precedence than \"model\"\n NOTE: This function does not use a jinja parser. It only support a pre-defined list of template. See more: https://github.com/ggml-org/llama.cpp/wiki/Templates-supported-by-llama_chat_apply_template\n @param tmpl A Jinja template to use for this chat. If this is nullptr, the models default chat template will be used instead.\n @param chat Pointer to a list of multiple llama_chat_message\n @param n_msg Number of llama_chat_message in this chat\n @param add_ass Whether to end the prompt with the token(s) that indicate the start of an assistant message.\n @param buf A buffer to hold the output formatted prompt. The recommended alloc size is 2 * (total number of characters of all messages)\n @param length The size of the allocated buffer\n @return The total number of bytes of the formatted prompt. If is it larger than the size of buffer, you may need to re-alloc it and then re-apply the template."] pub fn llama_chat_apply_template (tmpl : * const :: std :: os :: raw :: c_char , chat : * const llama_chat_message , n_msg : usize , add_ass : bool , buf : * mut :: std :: os :: raw :: c_char , length : i32) -> i32 ; } unsafe extern "C" { pub fn llama_chat_builtin_templates (output : * mut * const :: std :: os :: raw :: c_char , len : usize) -> i32 ; } pub type llama_sampler_context_t = * mut :: std :: os :: raw :: c_void ; # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq)] pub struct llama_sampler_data { pub logits : * mut ggml_tensor , pub probs : * mut ggml_tensor , pub sampled : * mut ggml_tensor , pub candidates : * mut ggml_tensor , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of llama_sampler_data"] [:: std :: mem :: size_of :: < llama_sampler_data > () - 32usize] ; ["Alignment of llama_sampler_data"] [:: std :: mem :: align_of :: < llama_sampler_data > () - 8usize] ; ["Offset of field: llama_sampler_data::logits"] [:: std :: mem :: offset_of ! (llama_sampler_data , logits) - 0usize] ; ["Offset of field: llama_sampler_data::probs"] [:: std :: mem :: offset_of ! (llama_sampler_data , probs) - 8usize] ; ["Offset of field: llama_sampler_data::sampled"] [:: std :: mem :: offset_of ! (llama_sampler_data , sampled) - 16usize] ; ["Offset of field: llama_sampler_data::candidates"] [:: std :: mem :: offset_of ! (llama_sampler_data , candidates) - 24usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq)] pub struct llama_sampler_i { pub name : :: std :: option :: Option < unsafe extern "C" fn (smpl : * const llama_sampler) -> * const :: std :: os :: raw :: c_char > , pub accept : :: std :: option :: Option < unsafe extern "C" fn (smpl : * mut llama_sampler , token : llama_token) > , pub apply : :: std :: option :: Option < unsafe extern "C" fn (smpl : * mut llama_sampler , cur_p : * mut llama_token_data_array) > , pub reset : :: std :: option :: Option < unsafe extern "C" fn (smpl : * mut llama_sampler) > , pub clone : :: std :: option :: Option < unsafe extern "C" fn (smpl : * const llama_sampler) -> * mut llama_sampler > , pub free : :: std :: option :: Option < unsafe extern "C" fn (smpl : * mut llama_sampler) > , pub backend_init : :: std :: option :: Option < unsafe extern "C" fn (smpl : * mut llama_sampler , buft : ggml_backend_buffer_type_t) -> bool > , pub backend_accept : :: std :: option :: Option < unsafe extern "C" fn (smpl : * mut llama_sampler , ctx : * mut ggml_context , gf : * mut ggml_cgraph , selected_token : * mut ggml_tensor) > , pub backend_apply : :: std :: option :: Option < unsafe extern "C" fn (smpl : * mut llama_sampler , ctx : * mut ggml_context , gf : * mut ggml_cgraph , data : * mut llama_sampler_data) > , pub backend_set_input : :: std :: option :: Option < unsafe extern "C" fn (smpl : * mut llama_sampler) > , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of llama_sampler_i"] [:: std :: mem :: size_of :: < llama_sampler_i > () - 80usize] ; ["Alignment of llama_sampler_i"] [:: std :: mem :: align_of :: < llama_sampler_i > () - 8usize] ; ["Offset of field: llama_sampler_i::name"] [:: std :: mem :: offset_of ! (llama_sampler_i , name) - 0usize] ; ["Offset of field: llama_sampler_i::accept"] [:: std :: mem :: offset_of ! (llama_sampler_i , accept) - 8usize] ; ["Offset of field: llama_sampler_i::apply"] [:: std :: mem :: offset_of ! (llama_sampler_i , apply) - 16usize] ; ["Offset of field: llama_sampler_i::reset"] [:: std :: mem :: offset_of ! (llama_sampler_i , reset) - 24usize] ; ["Offset of field: llama_sampler_i::clone"] [:: std :: mem :: offset_of ! (llama_sampler_i , clone) - 32usize] ; ["Offset of field: llama_sampler_i::free"] [:: std :: mem :: offset_of ! (llama_sampler_i , free) - 40usize] ; ["Offset of field: llama_sampler_i::backend_init"] [:: std :: mem :: offset_of ! (llama_sampler_i , backend_init) - 48usize] ; ["Offset of field: llama_sampler_i::backend_accept"] [:: std :: mem :: offset_of ! (llama_sampler_i , backend_accept) - 56usize] ; ["Offset of field: llama_sampler_i::backend_apply"] [:: std :: mem :: offset_of ! (llama_sampler_i , backend_apply) - 64usize] ; ["Offset of field: llama_sampler_i::backend_set_input"] [:: std :: mem :: offset_of ! (llama_sampler_i , backend_set_input) - 72usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq)] pub struct llama_sampler { pub iface : * mut llama_sampler_i , pub ctx : llama_sampler_context_t , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of llama_sampler"] [:: std :: mem :: size_of :: < llama_sampler > () - 16usize] ; ["Alignment of llama_sampler"] [:: std :: mem :: align_of :: < llama_sampler > () - 8usize] ; ["Offset of field: llama_sampler::iface"] [:: std :: mem :: offset_of ! (llama_sampler , iface) - 0usize] ; ["Offset of field: llama_sampler::ctx"] [:: std :: mem :: offset_of ! (llama_sampler , ctx) - 8usize] ; } ; unsafe extern "C" { pub fn llama_set_sampler (ctx : * mut llama_context , seq_id : llama_seq_id , smpl : * mut llama_sampler) -> bool ; } unsafe extern "C" { pub fn llama_sampler_init (iface : * mut llama_sampler_i , ctx : llama_sampler_context_t) -> * mut llama_sampler ; } unsafe extern "C" { pub fn llama_sampler_name (smpl : * const llama_sampler) -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn llama_sampler_accept (smpl : * mut llama_sampler , token : llama_token) ; } unsafe extern "C" { pub fn llama_sampler_apply (smpl : * mut llama_sampler , cur_p : * mut llama_token_data_array) ; } unsafe extern "C" { pub fn llama_sampler_reset (smpl : * mut llama_sampler) ; } unsafe extern "C" { pub fn llama_sampler_clone (smpl : * const llama_sampler) -> * mut llama_sampler ; } unsafe extern "C" { pub fn llama_sampler_free (smpl : * mut llama_sampler) ; } unsafe extern "C" { pub fn llama_sampler_chain_init (params : llama_sampler_chain_params) -> * mut llama_sampler ; } unsafe extern "C" { pub fn llama_sampler_chain_add (chain : * mut llama_sampler , smpl : * mut llama_sampler) ; } unsafe extern "C" { pub fn llama_sampler_chain_get (chain : * mut llama_sampler , i : i32) -> * mut llama_sampler ; } unsafe extern "C" { pub fn llama_sampler_chain_n (chain : * const llama_sampler) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn llama_sampler_chain_remove (chain : * mut llama_sampler , i : i32) -> * mut llama_sampler ; } unsafe extern "C" { pub fn llama_sampler_init_greedy () -> * mut llama_sampler ; } unsafe extern "C" { # [doc = " seed == LLAMA_DEFAULT_SEED to use a random seed."] pub fn llama_sampler_init_dist (seed : u32) -> * mut llama_sampler ; } unsafe extern "C" { # [doc = " @details Top-K sampling described in academic paper \"The Curious Case of Neural Text Degeneration\" https://arxiv.org/abs/1904.09751\n Setting k <= 0 makes this a noop"] pub fn llama_sampler_init_top_k (k : i32) -> * mut llama_sampler ; } unsafe extern "C" { # [doc = " @details Nucleus sampling described in academic paper \"The Curious Case of Neural Text Degeneration\" https://arxiv.org/abs/1904.09751"] pub fn llama_sampler_init_top_p (p : f32 , min_keep : usize) -> * mut llama_sampler ; } unsafe extern "C" { # [doc = " @details Minimum P sampling as described in https://github.com/ggml-org/llama.cpp/pull/3841"] pub fn llama_sampler_init_min_p (p : f32 , min_keep : usize) -> * mut llama_sampler ; } unsafe extern "C" { # [doc = " @details Locally Typical Sampling implementation described in the paper https://arxiv.org/abs/2202.00666."] pub fn llama_sampler_init_typical (p : f32 , min_keep : usize) -> * mut llama_sampler ; } unsafe extern "C" { # [doc = " #details Updates the logits l_i` = l_i/t. When t <= 0.0f, the maximum logit is kept at it's original value, the rest are set to -inf"] pub fn llama_sampler_init_temp (t : f32) -> * mut llama_sampler ; } unsafe extern "C" { # [doc = " @details Dynamic temperature implementation (a.k.a. entropy) described in the paper https://arxiv.org/abs/2309.02772."] pub fn llama_sampler_init_temp_ext (t : f32 , delta : f32 , exponent : f32) -> * mut llama_sampler ; } unsafe extern "C" { # [doc = " @details XTC sampler as described in https://github.com/oobabooga/text-generation-webui/pull/6335"] pub fn llama_sampler_init_xtc (p : f32 , t : f32 , min_keep : usize , seed : u32) -> * mut llama_sampler ; } unsafe extern "C" { # [doc = " @details Top n sigma sampling as described in academic paper \"Top-n: Not All Logits Are You Need\" https://arxiv.org/pdf/2411.07641"] pub fn llama_sampler_init_top_n_sigma (n : f32) -> * mut llama_sampler ; } unsafe extern "C" { # [doc = " @details Mirostat 1.0 algorithm described in the paper https://arxiv.org/abs/2007.14966. Uses tokens instead of words.\n @param candidates A vector of `llama_token_data` containing the candidate tokens, their probabilities (p), and log-odds (logit) for the current position in the generated text.\n @param tau  The target cross-entropy (or surprise) value you want to achieve for the generated text. A higher value corresponds to more surprising or less predictable text, while a lower value corresponds to less surprising or more predictable text.\n @param eta The learning rate used to update `mu` based on the error between the target and observed surprisal of the sampled word. A larger learning rate will cause `mu` to be updated more quickly, while a smaller learning rate will result in slower updates.\n @param m The number of tokens considered in the estimation of `s_hat`. This is an arbitrary value that is used to calculate `s_hat`, which in turn helps to calculate the value of `k`. In the paper, they use `m = 100`, but you can experiment with different values to see how it affects the performance of the algorithm.\n @param mu Maximum cross-entropy. This value is initialized to be twice the target cross-entropy (`2 * tau`) and is updated in the algorithm based on the error between the target and observed surprisal."] pub fn llama_sampler_init_mirostat (n_vocab : i32 , seed : u32 , tau : f32 , eta : f32 , m : i32) -> * mut llama_sampler ; } unsafe extern "C" { # [doc = " @details Mirostat 2.0 algorithm described in the paper https://arxiv.org/abs/2007.14966. Uses tokens instead of words.\n @param candidates A vector of `llama_token_data` containing the candidate tokens, their probabilities (p), and log-odds (logit) for the current position in the generated text.\n @param tau  The target cross-entropy (or surprise) value you want to achieve for the generated text. A higher value corresponds to more surprising or less predictable text, while a lower value corresponds to less surprising or more predictable text.\n @param eta The learning rate used to update `mu` based on the error between the target and observed surprisal of the sampled word. A larger learning rate will cause `mu` to be updated more quickly, while a smaller learning rate will result in slower updates.\n @param mu Maximum cross-entropy. This value is initialized to be twice the target cross-entropy (`2 * tau`) and is updated in the algorithm based on the error between the target and observed surprisal."] pub fn llama_sampler_init_mirostat_v2 (seed : u32 , tau : f32 , eta : f32) -> * mut llama_sampler ; } unsafe extern "C" { # [doc = " @details Intializes a GBNF grammar, see grammars/README.md for details.\n @param vocab The vocabulary that this grammar will be used with.\n @param grammar_str The production rules for the grammar, encoded as a string. Returns an empty grammar if empty. Returns NULL if parsing of grammar_str fails.\n @param grammar_root The name of the start symbol for the grammar."] pub fn llama_sampler_init_grammar (vocab : * const llama_vocab , grammar_str : * const :: std :: os :: raw :: c_char , grammar_root : * const :: std :: os :: raw :: c_char) -> * mut llama_sampler ; } unsafe extern "C" { pub fn llama_sampler_init_grammar_lazy (vocab : * const llama_vocab , grammar_str : * const :: std :: os :: raw :: c_char , grammar_root : * const :: std :: os :: raw :: c_char , trigger_words : * mut * const :: std :: os :: raw :: c_char , num_trigger_words : usize , trigger_tokens : * const llama_token , num_trigger_tokens : usize) -> * mut llama_sampler ; } unsafe extern "C" { # [doc = " @details Lazy grammar sampler, introduced in https://github.com/ggml-org/llama.cpp/pull/9639\n @param trigger_patterns A list of patterns that will trigger the grammar sampler. Pattern will be matched from the start of the generation output, and grammar sampler will be fed content starting from its first match group.\n @param trigger_tokens A list of tokens that will trigger the grammar sampler. Grammar sampler will be fed content starting from the trigger token included."] pub fn llama_sampler_init_grammar_lazy_patterns (vocab : * const llama_vocab , grammar_str : * const :: std :: os :: raw :: c_char , grammar_root : * const :: std :: os :: raw :: c_char , trigger_patterns : * mut * const :: std :: os :: raw :: c_char , num_trigger_patterns : usize , trigger_tokens : * const llama_token , num_trigger_tokens : usize) -> * mut llama_sampler ; } unsafe extern "C" { # [doc = " NOTE: Avoid using on the full vocabulary as searching for repeated tokens can become slow. For example, apply top-k or top-p sampling first."] pub fn llama_sampler_init_penalties (penalty_last_n : i32 , penalty_repeat : f32 , penalty_freq : f32 , penalty_present : f32) -> * mut llama_sampler ; } unsafe extern "C" { # [doc = "  @details DRY sampler, designed by p-e-w, as described in: https://github.com/oobabooga/text-generation-webui/pull/5677, porting Koboldcpp implementation authored by pi6am: https://github.com/LostRuins/koboldcpp/pull/982"] pub fn llama_sampler_init_dry (vocab : * const llama_vocab , n_ctx_train : i32 , dry_multiplier : f32 , dry_base : f32 , dry_allowed_length : i32 , dry_penalty_last_n : i32 , seq_breakers : * mut * const :: std :: os :: raw :: c_char , num_breakers : usize) -> * mut llama_sampler ; } unsafe extern "C" { pub fn llama_sampler_init_logit_bias (n_vocab : i32 , n_logit_bias : i32 , logit_bias : * const llama_logit_bias) -> * mut llama_sampler ; } unsafe extern "C" { pub fn llama_sampler_init_infill (vocab : * const llama_vocab) -> * mut llama_sampler ; } unsafe extern "C" { pub fn llama_sampler_get_seed (smpl : * const llama_sampler) -> u32 ; } unsafe extern "C" { pub fn llama_sampler_sample (smpl : * mut llama_sampler , ctx : * mut llama_context , idx : i32) -> llama_token ; } unsafe extern "C" { # [doc = " @details Build a split GGUF final path for this chunk.\n          llama_split_path(split_path, sizeof(split_path), \"/models/ggml-model-q4_0\", 2, 4) => split_path = \"/models/ggml-model-q4_0-00002-of-00004.gguf\""] pub fn llama_split_path (split_path : * mut :: std :: os :: raw :: c_char , maxlen : usize , path_prefix : * const :: std :: os :: raw :: c_char , split_no : :: std :: os :: raw :: c_int , split_count : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { # [doc = " @details Extract the path prefix from the split_path if and only if the split_no and split_count match.\n          llama_split_prefix(split_prefix, 64, \"/models/ggml-model-q4_0-00002-of-00004.gguf\", 2, 4) => split_prefix = \"/models/ggml-model-q4_0\""] pub fn llama_split_prefix (split_prefix : * mut :: std :: os :: raw :: c_char , maxlen : usize , split_path : * const :: std :: os :: raw :: c_char , split_no : :: std :: os :: raw :: c_int , split_count : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { pub fn llama_print_system_info () -> * const :: std :: os :: raw :: c_char ; } unsafe extern "C" { pub fn llama_log_get (log_callback : * mut ggml_log_callback , user_data : * mut * mut :: std :: os :: raw :: c_void) ; } unsafe extern "C" { pub fn llama_log_set (log_callback : ggml_log_callback , user_data : * mut :: std :: os :: raw :: c_void) ; } # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq)] pub struct llama_perf_context_data { pub t_start_ms : f64 , pub t_load_ms : f64 , pub t_p_eval_ms : f64 , pub t_eval_ms : f64 , pub n_p_eval : i32 , pub n_eval : i32 , pub n_reused : i32 , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of llama_perf_context_data"] [:: std :: mem :: size_of :: < llama_perf_context_data > () - 48usize] ; ["Alignment of llama_perf_context_data"] [:: std :: mem :: align_of :: < llama_perf_context_data > () - 8usize] ; ["Offset of field: llama_perf_context_data::t_start_ms"] [:: std :: mem :: offset_of ! (llama_perf_context_data , t_start_ms) - 0usize] ; ["Offset of field: llama_perf_context_data::t_load_ms"] [:: std :: mem :: offset_of ! (llama_perf_context_data , t_load_ms) - 8usize] ; ["Offset of field: llama_perf_context_data::t_p_eval_ms"] [:: std :: mem :: offset_of ! (llama_perf_context_data , t_p_eval_ms) - 16usize] ; ["Offset of field: llama_perf_context_data::t_eval_ms"] [:: std :: mem :: offset_of ! (llama_perf_context_data , t_eval_ms) - 24usize] ; ["Offset of field: llama_perf_context_data::n_p_eval"] [:: std :: mem :: offset_of ! (llama_perf_context_data , n_p_eval) - 32usize] ; ["Offset of field: llama_perf_context_data::n_eval"] [:: std :: mem :: offset_of ! (llama_perf_context_data , n_eval) - 36usize] ; ["Offset of field: llama_perf_context_data::n_reused"] [:: std :: mem :: offset_of ! (llama_perf_context_data , n_reused) - 40usize] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq)] pub struct llama_perf_sampler_data { pub t_sample_ms : f64 , pub n_sample : i32 , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of llama_perf_sampler_data"] [:: std :: mem :: size_of :: < llama_perf_sampler_data > () - 16usize] ; ["Alignment of llama_perf_sampler_data"] [:: std :: mem :: align_of :: < llama_perf_sampler_data > () - 8usize] ; ["Offset of field: llama_perf_sampler_data::t_sample_ms"] [:: std :: mem :: offset_of ! (llama_perf_sampler_data , t_sample_ms) - 0usize] ; ["Offset of field: llama_perf_sampler_data::n_sample"] [:: std :: mem :: offset_of ! (llama_perf_sampler_data , n_sample) - 8usize] ; } ; unsafe extern "C" { pub fn llama_perf_context (ctx : * const llama_context) -> llama_perf_context_data ; } unsafe extern "C" { pub fn llama_perf_context_print (ctx : * const llama_context) ; } unsafe extern "C" { pub fn llama_perf_context_reset (ctx : * mut llama_context) ; } unsafe extern "C" { pub fn llama_perf_sampler (chain : * const llama_sampler) -> llama_perf_sampler_data ; } unsafe extern "C" { pub fn llama_perf_sampler_print (chain : * const llama_sampler) ; } unsafe extern "C" { pub fn llama_perf_sampler_reset (chain : * mut llama_sampler) ; } unsafe extern "C" { pub fn llama_memory_breakdown_print (ctx : * const llama_context) ; } pub type llama_opt_param_filter = :: std :: option :: Option < unsafe extern "C" fn (tensor : * const ggml_tensor , userdata : * mut :: std :: os :: raw :: c_void) -> bool > ; unsafe extern "C" { pub fn llama_opt_param_filter_all (tensor : * const ggml_tensor , userdata : * mut :: std :: os :: raw :: c_void) -> bool ; } # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq)] pub struct llama_opt_params { pub n_ctx_train : u32 , pub param_filter : llama_opt_param_filter , pub param_filter_ud : * mut :: std :: os :: raw :: c_void , pub get_opt_pars : ggml_opt_get_optimizer_params , pub get_opt_pars_ud : * mut :: std :: os :: raw :: c_void , pub optimizer_type : ggml_opt_optimizer_type , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] const _ : () = { ["Size of llama_opt_params"] [:: std :: mem :: size_of :: < llama_opt_params > () - 48usize] ; ["Alignment of llama_opt_params"] [:: std :: mem :: align_of :: < llama_opt_params > () - 8usize] ; ["Offset of field: llama_opt_params::n_ctx_train"] [:: std :: mem :: offset_of ! (llama_opt_params , n_ctx_train) - 0usize] ; ["Offset of field: llama_opt_params::param_filter"] [:: std :: mem :: offset_of ! (llama_opt_params , param_filter) - 8usize] ; ["Offset of field: llama_opt_params::param_filter_ud"] [:: std :: mem :: offset_of ! (llama_opt_params , param_filter_ud) - 16usize] ; ["Offset of field: llama_opt_params::get_opt_pars"] [:: std :: mem :: offset_of ! (llama_opt_params , get_opt_pars) - 24usize] ; ["Offset of field: llama_opt_params::get_opt_pars_ud"] [:: std :: mem :: offset_of ! (llama_opt_params , get_opt_pars_ud) - 32usize] ; ["Offset of field: llama_opt_params::optimizer_type"] [:: std :: mem :: offset_of ! (llama_opt_params , optimizer_type) - 40usize] ; } ; unsafe extern "C" { pub fn llama_opt_init (lctx : * mut llama_context , model : * mut llama_model , lopt_params : llama_opt_params) ; } unsafe extern "C" { pub fn llama_opt_epoch (lctx : * mut llama_context , dataset : ggml_opt_dataset_t , result_train : ggml_opt_result_t , result_eval : ggml_opt_result_t , idata_split : i64 , callback_train : ggml_opt_epoch_callback , callback_eval : ggml_opt_epoch_callback) ; } # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq)] pub struct ggml_backend_buffer { pub _address : u8 , }